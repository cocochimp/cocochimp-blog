/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50635
 Source Host           : localhost:3306
 Source Schema         : cocochimpblog

 Target Server Type    : MySQL
 Target Server Version : 50635
 File Encoding         : 65001

 Date: 09/03/2024 16:48:27
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for sg_article
-- ----------------------------
DROP TABLE IF EXISTS `sg_article`;
CREATE TABLE `sg_article`  (
  `id` bigint(200) NOT NULL AUTO_INCREMENT,
  `title` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文章内容',
  `summary` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章摘要',
  `category_id` bigint(20) NULL DEFAULT NULL COMMENT '所属分类id',
  `thumbnail` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '缩略图',
  `is_top` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '是否置顶（0否，1是）',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '1' COMMENT '状态（0已发布，1草稿）',
  `view_count` bigint(200) NULL DEFAULT 0 COMMENT '访问量',
  `is_comment` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '1' COMMENT '是否允许评论 1是，0否',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sg_article
-- ----------------------------
INSERT INTO `sg_article` VALUES (1, 'SpringSecurity从入门到精通', '## 课程介绍\n![image20211219121555979.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/e7131718e9e64faeaf3fe16404186eb4.png)\n\n## 0. 简介1\n\n​	**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\n\n​	一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\n\n​	 一般Web应用的需要进行**认证**和**授权**。\n\n​		**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\n\n​		**授权：经过认证后判断当前用户是否有权限进行某个操作**\n\n​	而认证和授权也是SpringSecurity作为安全框架的核心功能。\n\n\n\n## 1. 快速入门\n\n### 1.1 准备工作\n\n​	我们先要搭建一个简单的SpringBoot工程\n\n① 设置父工程 添加依赖\n\n~~~~\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n~~~~\n\n② 创建启动类\n\n~~~~\n@SpringBootApplication\npublic class SecurityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SecurityApplication.class,args);\n    }\n}\n\n~~~~\n\n③ 创建Controller\n\n~~~~java\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n\n~~~~\n\n\n\n### 1.2 引入SpringSecurity\n\n​	在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\n\n~~~~xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n~~~~\n\n​	引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\n\n​	必须登陆之后才能对接口进行访问。\n\n\n\n## 2. 认证\n\n### 2.1 登陆校验流程\n![image20211215094003288.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/414a87eeed344828b5b00ffa80178958.png)', 'SpringSecurity框架教程-Spring Security+JWT实现项目级前端分离认证授权', 1, 'https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/948597e164614902ab1662ba8452e106.png', '1', '0', 124, '0', 1, '2022-01-23 23:20:11', 1, '2023-02-21 22:27:54', 1);
INSERT INTO `sg_article` VALUES (8, 'Java8完整笔记（上）', '# Java1.8笔记(上)\n\n# 1. Java基本语法\n\n> Java语言跨平台原理\n\nJava程序并非是直接运行的，Java编译器将Java源程序编译成与平台无关的字节码文件(class文件)，然后由Java虚拟机（JVM）对字节码文件解释执行。所以在不同的操作系统下，只需安装不同的Java虚拟机即可实现java程序的跨平台。\n\n* JVM（Java Virtual Machine），Java虚拟机 \n* JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API） \n* JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具 \n\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\n\n\n\n> Java中的内存分配\n\n* 目前我们只需要记住两个内存，分别是：栈内存和堆内存\n\n| 区域名称   | 作用                                                       |\n| ---------- | ---------------------------------------------------------- |\n| 寄存器     | 给CPU使用，和我们开发无关。                                |\n| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关。          |\n| 方法区     | 存储可以运行的class文件。                                  |\n| **堆内存** | 存储对象或者数组，new来创建的，都存储在堆内存。            |\n| **方法栈** | 方法运行时使用的内存，比如main方法运行，进入方法栈中执行。 |\n\nJava虚拟机要运行程序，必须要对内存进行空间的分配和管理。\n\n\n\n## 1.1 Java中的数据类型\n\nJava是一个强类型语言，Java中的数据必须明确数据类型。在Java中的数据类型包括**基本数据类型**和**引用数据类型**两种。\n\n* Java中的基本数据类型\n\n| 数据类型 | 关键字         | 内存占用 | 取值范围（2的次方） |\n| -------- | -------------- | -------- | ------------------- |\n| 整数类型 | byte           | 1        | 7次                 |\n|          | short          | 2        | 15次                |\n|          | int（默认）    | 4        | 31次                |\n|          | long           | 8        | 63次                |\n| 浮点类型 | float          | 4        | 128次               |\n|          | double（默认） | 8        | 1024次              |\n| 字符类型 | char           | 2        | 0 ~ 2的16次         |\n| 布尔类型 | boolean        | 1        | true，false         |\n\n* 类型转换\n\n![image-20230127234508672](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230127234508672.png)\n\n 注：boolean类型不能与其他基本数据类型相互转换。\n\n\n\n## 1.2 字符(串)的“+”操作\n\nchar类型参与算术运算，使用的是计算机底层对应的十进制数值。\n\n需要我们记住三个字符对应的数值：\n\n* \'a\' -- 97 a-z是连续的，所以\'b\'对应的数值是98，\'c\'是99，依次递加 \n* \'A\' -- 65 A-Z是连续的，所以\'B\'对应的数值是66，\'C\'是67，依次递加 \n* \'0\' -- 48 0-9是连续的，所以\'1\'对应的数值是49，\'2\'是50，依次递加\n\n```java\nSystem.out.println(1+99+\"cc\"+1+1); //100cc11\nSystem.out.println(1+99+\"cc\"+(1+1)); //100cc2\n```\n\n\n\n## 1.3 常见运算符\n\n> 1、赋值运算符\n\n赋值运算符的作用是将一个表达式的值赋给左边，左边必须是可修改的，不能是常量。\n\n```java\nshort s = 10;\ns = s + 10; // 此行代码报出，因为运算中s提升为int类型，运算结果int赋值给short可能损失精度\ns += 10; // 此行代码没有问题，隐含了强制类型转换，相当于 s = (short) (s + 10);\n```\n\n\n\n> 2、自增自减运算符\n\n```java\nint x = 10;\nint y = x++; // 赋值运算，++在后边，所以是使用x原来的值赋值给y，x本身自增1\nSystem.out.println(\"x:\" + x + \", y:\" + y); // x:11，y:10\nint m = 10;\nint n = ++m; // 赋值运算，++在前边，所以是使用m自增后的值赋值给n，m本身自增1\nSystem.out.println(\"m:\" + m + \", m:\" + m); // m:11，m:11\n\nint x = 10;\nint y = x++ + x++ + x++;\nSystem.out.println(y); // y的值是多少？\n/*\n解析，三个表达式都是++在后，所以每次使用的都是自增前的值，但程序自左至右执行，所以第一次自增时，使用的是10进行计算，但第二次自增时，x的值已经自增到11了，所以第二次使用的是11，然后再次自增...\n所以整个式子应该是：int y = 10 + 11 + 12;\n输出结果为33。\n*/\n注意：通过此练习深刻理解自增和自减的规律，但实际开发中强烈建议不要写这样的代码！小心挨打！\n```\n\n\n\n> 3、三元运算符(案例)\n\n* 1、需求：动物园里有两只老虎，已知两只老虎的体重分别为180kg、200kg，请用程序实现判断两只老虎的体重是否相同。\n\n```java\npublic class OperatorTest01 {\n	public static void main(String[] args) {\n        //1：定义两个变量用于保存老虎的体重，单位为kg，这里仅仅体现数值即可。\n        int weight1 = 180;\n        int weight2 = 200;\n        //2：用三元运算符实现老虎体重的判断，体重相同，返回true，否则，返回false。\n        boolean b = weight1 == weight2 ? true : false;\n        //3：输出结果\n        System.out.println(\"b:\" + b);\n    }\n}\n```\n\n* 2、需求：一座寺庙里住着三个和尚，已知他们的身高分别为150cm、210cm、165cm，请用程序实现获取这三个和尚的最高身高。\n\n```java\npublic class OperatorTest02 {\n    public static void main(String[] args) {\n        //1：定义三个变量用于保存和尚的身高，单位为cm，这里仅仅体现数值即可。\n        int height1 = 150;\n        int height2 = 210;\n        int height3 = 165;\n        //2：用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。\n        int tempHeight = height1 > height2 ? height1 : height2;\n        //3：用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。\n        int maxHeight = tempHeight > height3 ? tempHeight : height3;\n        //4：输出结果\n        System.out.println(\"maxHeight:\" + maxHeight);\n    }\n}\n```\n\n\n\n## 1.4 Scanner数据输入\n\n> 步骤：\n\n1. 导包\n\n```java\nimport java.util.Scanner\n```\n\n2. 创建Scanner对象\n\n```java\nScanner sc=new Scanner(System.in);\n```\n\n3. 接收数据\n\n```java\nint i=sc.nextInt();\n```\n\n\n\n* 示例：\n\n```java\nimport java.util.Scanner;\npublic class ScannerDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Scanner sc = new Scanner(System.in);\n        //接收数据\n        int x = sc.nextInt();\n        //输出数据\n        System.out.println(\"x:\" + x);\n    }\n}\n```\n\n* 三个和尚\n\n```java\nimport java.util.Scanner;\npublic class ScannerTest {\n    public static void main(String[] args) {\n        //身高未知，采用键盘录入实现。首先导包，然后创建对象。\n        Scanner sc = new Scanner(System.in);\n        //键盘录入三个身高分别赋值给三个变量。\n        System.out.println(\"请输入第一个和尚的身高：\");\n        int height1 = sc.nextInt();\n        System.out.println(\"请输入第二个和尚的身高：\");\n        int height2 = sc.nextInt();\n        System.out.println(\"请输入第三个和尚的身高：\");\n        int height3 = sc.nextInt();\n        //用三元运算符获取前两个和尚的较高身高值，并用临时身高变量保存起来。\n        int tempHeight = height1 > height2 ? height1 : height2;\n        //用三元运算符获取临时身高值和第三个和尚身高较高值，并用最大身高变量保存。\n        int maxHeight = tempHeight > height3 ? tempHeight : height3;\n        //输出结果。\n        System.out.println(\"这三个和尚中身高最高的是：\" + maxHeight +\"cm\");\n    }\n}\n```\n\n\n\n## 1.5 switch语句\n\n* switch语句练习-春夏秋冬（应用） \n\n需求：一年有12个月，分属于春夏秋冬4个季节，键盘录入一个月份，请用程序实现判断该月份属于哪个季节，并输出。 运行结果：\n\n```\n春：3、4、5\n夏：6、7、8\n秋：9、10、11\n冬：1、2、12\n```\n\n* 示例代码：\n\n```java\npublic class Demo1 {\n    public static void main(String[] args) {\n    //键盘录入月份数据，使用变量接收\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个月份：\");\n        int month = sc.nextInt();\n        //case穿透\n        switch(month) {\n        case 1:\n        case 2:\n        case 12:\n        	System.out.println(\"冬季\");\n        	break;\n        case 3:\n        case 4:\n        case 5:\n        	System.out.println(\"春季\");\n        	break;\n        case 6:\n        case 7:\n        case 8:\n        	System.out.println(\"夏季\");\n        	break;\n        case 9:\n        case 10:\n        case 11:\n        	System.out.println(\"秋季\");\n        	break;\n        default:\n        	System.out.println(\"你输入的月份有误\");\n        }\n    }\n}\n```\n\n* 注意：如果switch中得case，没有对应break的话，则会出现case穿透的现象。\n\n\n\n## 1.6 for循环语句\n\n* for循环练习-水仙花\n\n解释：什么是水仙花数？\n\n水仙花数，指的是一个三位数，个位、十位、百位的数字立方和等于原数 \n\n例如 153 3*3*3 + 5*5*5 + 1*1*1 = 153\n\n* 示例代码\n\n```java\npublic class ForTest04 {\n    public static void main(String[] args) {\n        //输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束\n        for(int i=100; i<1000; i++) {\n            //在计算之前获取三位数中每个位上的值\n            int ge = i%10;\n            int shi = i/10%10;\n            int bai = i/10/10%10;\n            //判定条件是将三位数中的每个数值取出来，计算立方和后与原始数字比较是否相等\n            if(ge*ge*ge + shi*shi*shi + bai*bai*bai == i) {\n                //输出满足条件的数字就是水仙花数\n                System.out.println(i);\n            }\n        }\n    }\n}\n```\n\n\n\n## 1.7 while循环语句\n\n* while循环练习-珠穆朗玛峰\n\n需求：世界最高山峰是珠穆朗玛峰(8844.43米=8844430毫米)，假如我有一张足够大的纸，它的厚度是0.1毫米。请问，我折叠多少次，可以折成珠穆朗玛峰的高度?\n\n* 示例代码：\n\n```java\npublic class WhileTest {\n    public static void main(String[] args) {\n        //定义一个计数器，初始值为0\n        int count = 0;\n        //定义纸张厚度\n        double paper = 0.1;\n        //定义珠穆朗玛峰的高度\n        int zf = 8844430;\n        //因为要反复折叠，所以要使用循环，但是不知道折叠多少次，这种情况下更适合使用while循环\n        //折叠的过程中当纸张厚度大于珠峰就停止了，因此继续执行的要求是纸张厚度小于珠峰高度\n        while(paper <= zf) {\n        	//循环的执行过程中每次纸张折叠，纸张的厚度要加倍\n            paper *= 2;\n            //在循环中执行累加，对应折叠了多少次\n            count++;\n        }\n        //打印计数器的值\n        System.out.println(\"需要折叠：\" + count + \"次\");\n    }\n}\n```\n\n\n\n## 1.8 Random随机数\n\n> 步骤：\n\n1. 导包\n\n```java\nimport java.util.Random\n```\n\n2. 创建Scanner对象\n\n```java\nRandom r = new Random();\n```\n\n3. 接收数据\n\n```java\nint i=r.nextInt(10);\n```\n\n注：10代表的是一个范围，如果括号写10，产生的随机数就是0-9，括号写20，参数的随机数则是0- 19\n\n\n\n* 示例：\n\n需求： 程序自动生成一个1-100之间的数字，使用程序实现猜出这个数字是多少？\n\n当猜错的时候根据不同情况给出相应的提示 \n\nA. 如果猜的数字比真实数字大，提示你猜的数据大了 \n\nB. 如果猜的数字比真实数字小，提示你猜的数据小了 \n\nC. 如果猜的数字与真实数字相等，提示恭喜你猜中了\n\n```java\nimport java.util.Random;\nimport java.util.Scanner;\npublic class RandomTest {\n    public static void main(String[] args) {\n        //要完成猜数字的游戏，首先需要有一个要猜的数字，使用随机数生成该数字，范围1到100\n        Random r = new Random();\n        int number = r.nextInt(100) + 1;\n        while(true) {\n               //使用程序实现猜数字，每次均要输入猜测的数字值，需要使用键盘录入实现\n                Scanner sc = new Scanner(System.in);\n                System.out.println(\"请输入你要猜的数字：\");\n                int guessNumber = sc.nextInt();\n                //比较输入的数字和系统产生的数据，需要使用分支语句。\n                //这里使用if..else..if..格式，根据不同情况进行猜测结果显示\n                if(guessNumber > number) {\n                	System.out.println(\"你猜的数字\" + guessNumber + \"大了\");\n                } else if(guessNumber < number) {\n                	System.out.println(\"你猜的数字\" + guessNumber + \"小了\");\n                } else {\n                	System.out.println(\"恭喜你猜中了\");\n                break;\n            }\n        }\n    }\n}\n```\n\n\n\n## 1.9 数组\n\n* 数组定义\n\n```java\nint arr[]; //int[] arr;\ndouble arr[]; //double[] arr;\nchar arr[]; //char[] arr;\n```\n\n* 动态数组初始化\n\n```java\nint[] arr = new int[3];\n```\n\n* 静态数组初始化\n\n```java\nint[] arr = {1, 2, 3};\n```\n\n* 示例：最大值获取：从数组的所有元素中找出最大值。\n\n```java\npublic class ArrayTest02 {\n    public static void main(String[] args) {\n        //定义数组\n        int[] arr = {12, 45, 98, 73, 60};\n        //定义一个变量，用于保存最大值\n        //取数组中第一个数据作为变量的初始值\n        int max = arr[0];\n        //与数组中剩余的数据逐个比对，每次比对将最大值保存到变量中\n        for(int x=1; x<arr.length; x++) {\n            if(arr[x] > max) {\n            	max = arr[x];\n            }\n        }\n        //循环结束后打印变量的值\n        System.out.println(\"max:\"+max);\n    }\n}\n```\n\n\n\n## 1.10 方法\n\n* 方法定义\n\n```java\npublic static void method (int[] arr) {\n// 方法体;\n}\n\n//解释：\n方法权限 static 返回值类型 方法名 (参数) {\n// 方法体;\n}\n```\n\n* 方法重载\n\n定义：在同一个类中多个相同名称的方法（只与参数有关）。\n\n```java\npublic class MethodDemo {\n    public static float fn(int a) {\n    	//方法体\n    }\n    public static int fn(int a , int b) {\n    	//方法体\n    }\n}\n```\n\n错误示范：\n\n```java\npublic class MethodDemo {\n    public static void fn(int a) {\n    	//方法体\n    }\n    public static int fn(int a) { /*错误原因：重载与返回值无关*/\n    	//方法体\n    }\n}\npublic class MethodDemo01 {\n    public static void fn(int a) {\n    	//方法体\n    }\n}\npublic class MethodDemo02 {\n    public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/\n    	//方法体\n    }\n}\n```\n\n![image-20230128140823402](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230128140823402.png)\n\n\n\n## 1.11 递归\n\n* 递归的介绍 \n  * 以编程的角度来看，递归指的是方法定义中调用方法本身的现象 \n  * 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 \n  * 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n\n```java\npublic class DiGuiDemo {\n    public static void main(String[] args) {\n        //回顾不死神兔问题，求第20个月兔子的对数\n        //每个月的兔子对数：1,1,2,3,5,8，...\n        int[] arr = new int[20];\n        arr[0] = 1;\n        arr[1] = 1;\n        for (int i = 2; i < arr.length; i++) {\n            arr[i] = arr[i - 1] + arr[i - 2];\n        }\n        System.out.println(arr[19]);\n        System.out.println(f(20));\n    }\n    /*\n    递归解决问题，首先就是要定义一个方法：\n    定义一个方法f(n)：表示第n个月的兔子对数\n    那么，第n-1个月的兔子对数该如何表示呢？f(n-1)\n    同理，第n-2个月的兔子对数该如何表示呢？f(n-2)\n    StackOverflowError:当堆栈溢出发生时抛出一个应用程序递归太深\n    */\n    public static int f(int n) {\n        if(n==1 || n==2) {\n            return 1;\n        } else {\n            return f(n - 1) + f(n - 2);\n        }\n    }\n}\n```\n\n* 递归的注意事项 \n  * 递归一定要有出口。否则内存溢出 \n  * 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出\n\n\n\n> 递归求阶乘\n\n* 案例需求 \n\n  用递归求5的阶乘，并把结果在控制台输出\n\n```java\npublic class DiGuiDemo01 {\n    public static void main(String[] args) {\n        //调用方法\n        int result = jc(5);\n        //输出结果\n        System.out.println(\"5的阶乘是：\" + result);\n    }\n    \n    //定义一个方法，用于递归求阶乘，参数为一个int类型的变量\n    public static int jc(int n) {\n        //在方法内部判断该变量的值是否是1\n        if(n == 1) {\n            //是：返回1\n            return 1;\n        } else {\n            //不是：返回n*(n-1)!\n            return n*jc(n-1);\n        }\n    }\n}\n```\n\n\n\n# 2. 面向对象三大特性\n\n> 解释：\n\n面向对象的三大特性是：封装、继承、多态。\n\n\n\n## 2.1 封装\n\n> 概念\n\n1. 封装概述是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 ；\n2. 封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法 ；\n3. 封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性；\n\n\n\n> 标准类制作\n\n需求：定义标准学生类，要求分别使用空参和有参构造方法创建对象，空参创建的对象通过setXxx赋值，有参创建的对象直接赋值，并通过show方法展示数据。 \n\n示例代码：\n\n```java\nclass Student {\n    //成员变量\n    private String name;\n    private int age;\n    \n    //构造方法\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    //成员方法\n    public void setName(String name) {\n    	this.name = name;\n    }\n    public String getName() {\n    	return name;\n    }\n    public void setAge(int age) {\n    	this.age = age;\n    }\n    public int getAge() {\n    	return age;\n    }\n    public void show() {\n    	System.out.println(name + \",\" + age);\n    }\n}\n/*\n    创建对象并为其成员变量赋值的两种方式\n    1:无参构造方法创建对象后使用setXxx()赋值\n    2:使用带参构造方法直接创建带有属性值的对象\n*/\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //无参构造方法创建对象后使用setXxx()赋值\n        Student s1 = new Student();\n        s1.setName(\"林青霞\");\n        s1.setAge(30);\n        s1.show();\n        //使用带参构造方法直接创建带有属性值的对象\n        Student s2 = new Student(\"林青霞\",30);\n        s2.show();\n    }\n}\n```\n\n\n\n## 2.2 继承\n\n> 1、概念&特点\n\n继承可以让类与类之间产生关系，子父类关系，产生子父类后，**子类则可以使用父类中非私有的成员**。\n\n* 实现继承的格式\n  * 继承通过extends实现\n  * class Dog extends Animal { }\n\n* 继承的**好处**\n  * 提高了代码的复用性(多个类相同的成员可以放到同一个类中) \n  * 提高了代码的维护性(如果方法的代码需要修改，修改一处即可)\n\n* 继承的**坏处**\n  * 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性\n\n* 继承的应用场景\n  * is..a的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类\n\n\n\n> 2、继承中变量的访问特点\n\n在子类方法中访问一个变量，采用的是就近原则。 \n\n1. 子类局部范围找 \n2. 子类成员范围找\n3. 父类成员范围找 \n4. 如果都没有就报错(不考虑父亲的父亲…)\n\n\n\n> 3、super关键字\n\n* this和super的使用分别 \n  * 成员变量： \n    * this.成员变量 - 访问本类成员变量 \n    * super.成员变量 - 访问父类成员变量 \n  * 成员方法： \n    * this.成员方法 - 访问本类成员方法\n    * super.成员方法 - 访问父类成员方法 \n  * 构造方法： \n    * this(…) - 访问本类构造方法 \n    * super(…) - 访问父类构造方法\n\n* super内存图\n\n![image-20230128232119239](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230128232119239.png)\n\n\n\n> 4、方法重写\n\n概念：子类出现了和父类中一模一样的方法声明（方法名一样，参数列表也必须一样）\n\n当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了 父类的功能，又定义了子类特有的内容\n\nOverride注解：用来检测当前的方法，是否是重写的方法，起到【校验】的作用\n\n\n\n> 5、继承案例\n\n* 需求：请采用继承的思想实现猫和狗的案例，并在测试类中进行测试 \n\n* 分析： \n\n  ①猫： \n\n  成员变量：姓名，年龄 \n\n  构造方法：无参，带参 \n\n  成员方法：get/set方法，抓老鼠() \n\n  ②狗： \n\n  成员变量：姓名，年龄 \n\n  构造方法：无参，带参 \n\n  成员方法：get/set方法，看门() \n\n  ③共性： \n\n  成员变量：姓名，年龄；\n\n  构造方法：无参，带参；\n\n  成员方法：get/set方法 \n\n* 步骤： \n\n  1、定义动物类(Animal) \n\n  【成员变量：姓名，年龄】【 构造方法：无参，带参】【成员方法：get/set方法】 \n\n  2、定义猫类(Cat)，继承动物类 \n\n  【构造方法：无参，带参】【成员方法：抓老鼠() 】 \n\n  3、定义狗类(Dog)，继承动物类\n\n  【构造方法：无参，带参】【成员方法：看门() 】 \n\n  4、定义测试类(AnimalDemo)，写代码测试\n\n```java\nclass Animal {\n    private String name;\n        private int age;\n        public Animal() {\n    }\n    public Animal(String name, int age) {\n        this.name = name;\n            this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\nclass Cat extends Animal {\n    public Cat() {\n    }\n    public Cat(String name, int age) {\n        super(name, age);\n    }\n    public void catchMouse() {\n        System.out.println(\"猫抓老鼠\");\n    }\n}\nclass Dog extends Animal {\n    public Dog() {\n    }\n    public Dog(String name, int age) {\n        super(name, age);\n    }\n    public void lookDoor() {\n        System.out.println(\"狗看门\");\n    }\n\n    /*\n    测试类\n    */\n    public class AnimalDemo {\n        public static void main(String[] args) {\n            //创建猫类对象并进行测试\n            Cat c1 = new Cat();\n                c1.setName(\"加菲猫\");\n                c1.setAge(5);\n                System.out.println(c1.getName() + \",\" + c1.getAge());\n                c1.catchMouse();\n                Cat c2 = new Cat(\"加菲猫\", 5);\n                System.out.println(c2.getName() + \",\" + c2.getAge());\n                c2.catchMouse();\n        }\n    }\n```\n\n\n\n## 2.3 多态\n\n概念：同一个对象，在不同时刻表现出来的不同形态\n\n* 多态的前提\n\n  * 要有继承或实现关系 \n  * 要有方法的重写 \n  * 要有父类引用指向子类对象\n\n* 多态中的成员访问特点\n\n  * **成员变量**\n\n    编译看父类，运行看父类\n\n  * 成员方法\n\n    编译看父类，运行看子类\n\n> 代码演示\n\n* 动物类\n\n```java\npublic class Animal {\n    public int age = 40;\n        public void eat() {\n        System.out.println(\"动物吃东西\");\n    }\n}\n```\n\n* 猫类\n\n```java\npublic class Cat extends Animal {\n    public int age = 20;\n        public int weight = 10;\n        @Override\n        public void eat() {\n        System.out.println(\"猫吃鱼\");\n    }\n    public void playGame() {\n        System.out.println(\"猫捉迷藏\");\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //有父类引用指向子类对象\n        Animal a = new Cat();\n            System.out.println(a.age);\n            // System.out.println(a.weight);\n            a.eat();\n            // a.playGame();\n    }\n}\n```\n\n\n\n> 多态的好处与弊端\n\n* 好处\n\n  提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作\n\n* 弊端\n\n  **不能使用子类的特有成员**\n\n  （基于弊端，因此我们不需要在子类中定义成员方法）\n\n```java\n//向上转型\nAnimal a = new Cat();\na.eat();\n// a.playGame();//子类的特定方法\n\n//向下转型\nCat c = (Cat)a;\nc.eat();\nc.playGame();\n```\n\n\n\n# 3. 常见API\n\n> 概念\n\n* 什么是API？\n\nAPI (Application Programming Interface) ：应用程序编程接口\n\n* java中的API\n\n指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类**如何使用**即可，我们可以通过帮助文档来学习这些API如何使用。\n\n\n\n## 3.1 String类\n\nString 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序 中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！\n\n* 常用构造方法（理解）\n\n| 方法名                    | 说明                                      |\n| ------------------------- | ----------------------------------------- |\n| public String()           | 创建一个空白字符串对象，不含有任何内容    |\n| public String(char[] chs) | 根据字符数组的内容，来创建字符串对象      |\n| public String(byte[] bys) | 根据字节数组的内容，来创建字符串对象      |\n| String s = “abc”;         | 直接赋值的方式创建字符串对象，内容就是abc |\n\n* 常用方法\n\n| 方法名                                 | 说明                                           |\n| -------------------------------------- | ---------------------------------------------- |\n| public boolean equals(Object anObject) | 比较字符串的内容，严格区分大小写(用户名和密码) |\n| public char charAt(int index)          | 返回指定索引处的 char 值                       |\n| public int length()                    | 返回此字符串的长度                             |\n\n\n\n> 字符串的比较\n\n* ==号的作用\n\n比较基本数据类型：比较的是具体的值 \n\n比较引用数据类型：比较的是对象地址值\n\n\n\n> String案例\n\n1. **用户登录案例**\n\n已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示。\n\n```java\n/*\n    思路：\n    1:已知用户名和密码，定义两个字符串表示即可\n    2:键盘录入要登录的用户名和密码，用 Scanner 实现\n    3:拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用\n    equals() 方法实现\n    4:用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\n*/\npublic class StringTest01 {\n    public static void main(String[] args) {\n        //已知用户名和密码，定义两个字符串表示即可\n        String username = \"itheima\";\n        String password = \"czbk\";\n        //用循环实现多次机会，这里的次数明确，采用for循环实现，并在登录成功的时候，使用break结束循环\n        for(int i=0; i<3; i++) {\n            //键盘录入要登录的用户名和密码，用 Scanner 实现\n            Scanner sc = new Scanner(System.in);\n            System.out.println(\"请输入用户名：\");\n            String name = sc.nextLine();\n            System.out.println(\"请输入密码：\");\n            String pwd = sc.nextLine();\n            //拿键盘录入的用户名、密码和已知的用户名、密码进行比较，给出相应的提示。字符串的内容比较，用equals() 方法实现\n            if (name.equals(username) && pwd.equals(password)) {\n            	System.out.println(\"登录成功\");\n            break;\n        } else {\n            if(2-i == 0) {\n            	System.out.println(\"你的账户被锁定，请与管理员联系\");\n            } else {\n                //2,1,0\n                //i,0,1,2\n                System.out.println(\"登录失败，你还有\" + (2 - i) + \"次机会\");\n            	}\n            }\n        }\n    }\n}\n```\n\n\n\n2. **遍历字符串案例**\n\n键盘录入一个字符串，使用程序实现在控制台遍历该字符串\n\n```java\n/*\n    思路：\n    1:键盘录入一个字符串，用 Scanner 实现\n    2:遍历字符串，首先要能够获取到字符串中的每一个字符\n    public char charAt(int index)：返回指定索引处的char值，字符串的索引也是从0开始的\n    3:遍历字符串，其次要能够获取到字符串的长度\n    public int length()：返回此字符串的长度\n    数组的长度：数组名.length\n    字符串的长度：字符串对象.length()\n    4:遍历字符串的通用格式\n*/\npublic class StringTest02 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串：\");\n        String line = sc.nextLine();\n        for(int i=0; i<line.length(); i++) {\n        	System.out.println(line.charAt(i));\n        }\n    }\n}\n```\n\n\n\n3. **统计字符次数案例**\n\n键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)\n\n```java\n/*\n    思路：\n    1:键盘录入一个字符串，用 Scanner 实现\n    2:要统计三种类型的字符个数，需定义三个统计变量，初始值都为0\n    3:遍历字符串，得到每一个字符\n    4:判断该字符属于哪种类型，然后对应类型的统计变量+1\n    假如ch是一个字符，我要判断它属于大写字母，小写字母，还是数字，直接判断该字符是否在对应的范\n    围即可\n    大写字母：ch>=\'A\' && ch<=\'Z\'\n    小写字母： ch>=\'a\' && ch<=\'z\'\n    数字： ch>=\'0\' && ch<=\'9\'\n    5:输出三种类型的字符个数\n*/\npublic class StringTest03 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串：\");\n        String line = sc.nextLine();\n        //要统计三种类型的字符个数，需定义三个统计变量，初始值都为0\n        int bigCount = 0;\n        int smallCount = 0;\n        int numberCount = 0;\n        //遍历字符串，得到每一个字符\n        for(int i=0; i<line.length(); i++) {\n            char ch = line.charAt(i);\n            //判断该字符属于哪种类型，然后对应类型的统计变量+1\n            if(ch>=\'A\' && ch<=\'Z\') {\n            	bigCount++;\n            } else if(ch>=\'a\' && ch<=\'z\') {\n            	smallCount++;\n            } else if(ch>=\'0\' && ch<=\'9\') {\n            	numberCount++;\n            }\n        }\n        //输出三种类型的字符个数\n        System.out.println(\"大写字母：\" + bigCount + \"个\");\n        System.out.println(\"小写字母：\" + smallCount + \"个\");\n        System.out.println(\"数字：\" + numberCount + \"个\");\n    }\n}\n```\n\n\n\n4. **字符串拼接案例**\n\n定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， 并在控制台输出结果。\n\n例如，数组为 int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n```java\n/*\n    思路：\n    1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n    2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\n    返回值类型 String，参数列表 int[] arr\n    3:在方法中遍历数组，按照要求进行拼接\n    4:调用方法，用一个变量接收结果\n    5:输出结果\n*/\npublic class StringTest04 {\n    public static void main(String[] args) {\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        int[] arr = {1, 2, 3};\n        //调用方法，用一个变量接收结果\n        String s = arrayToString(arr);\n        //输出结果\n        System.out.println(\"s:\" + s);\n    }\n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\n    /*\n    两个明确：\n    返回值类型：String\n    参数：int[] arr\n    */\n    public static String arrayToString(int[] arr) {\n        //在方法中遍历数组，按照要求进行拼接\n        String s = \"\";\n        s += \"[\";\n        for(int i=0; i<arr.length; i++) {\n            if(i==arr.length-1) {\n            	s += arr[i];\n            } else {\n            	s += arr[i];\n            	s += \", \";\n            }\n        }\n        s += \"]\";\n        return s;\n    }\n}\n```\n\n\n\n5.**字符串反转案例**\n\n定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果 例如，键盘录入 abc，输出结果 cba\n\n```java\n/*\n    思路：\n    1:键盘录入一个字符串，用 Scanner 实现\n    2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s\n    3:在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回\n    4:调用方法，用一个变量接收结果\n    5:输出结果\n*/\npublic class StringTest05 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串：\");\n        String line = sc.nextLine();\n        //调用方法，用一个变量接收结果\n        String s = reverse(line);\n        //输出结果\n        System.out.println(\"s:\" + s);\n     }\n    //定义一个方法，实现字符串反转\n    /*\n        两个明确：\n        返回值类型：String\n        参数：String s\n    */\n    public static String reverse(String s) {\n        //在方法中把字符串倒着遍历，然后把每一个得到的字符拼接成一个字符串并返回\n        String ss = \"\";\n        for(int i=s.length()-1; i>=0; i--) {\n            ss += s.charAt(i);\n        }\n        return ss;\n    }\n}\n```\n\n\n\n## 3.2 StringBuilder类\n\nStringBuilder 是一个可变的字符串类，我们可以把它看成是一个容器，这里的可变指的是 StringBuilder 对象中的 内容是可变的\n\n* StringBuilder类和String类的区别\n  * String类：内容是不可变的\n  * StringBuilder类：内容是可变的\n\n* 常用的构造方法\n\n| 方法名                           | 说明                                       |\n| -------------------------------- | ------------------------------------------ |\n| public StringBuilder()           | 创建一个空白可变字符串对象，不含有任何内容 |\n| public StringBuilder(String str) | 根据字符串的内容，来创建可变字符串对象     |\n\n* 常用的方法\n\n| 方法名                                 | 说明                                                |\n| -------------------------------------- | --------------------------------------------------- |\n| public StringBuilder append (任意类型) | 添加数据，并返回对象本身                            |\n| public StringBuilder reverse()         | 返回相反的字符序列                                  |\n| public int length()                    | 返回长度，实际存储值                                |\n| public String toString()               | 通过toString()就可以实现把StringBuilder转换为String |\n\n\n\n>StringBuilder和String相互转换\n\n* StringBuilder转换为String\n\npublic String toString()：通过 **toString()** 就可以实现把 StringBuilder 转换为 String \n\n```java\nStringBuilder sb = new StringBuilder();\nString s = sb.toString();\n```\n\n* String转换为StringBuilder \n\npublic StringBuilder(String s)：通过**构造方法**就可以实现把 String 转换为 StringBuilder\n\n```java\nString s = \"hello\";\nStringBuilder sb = new StringBuilder(s);\n```\n\n\n\n> StringBuilder案例\n\n1. **字符串拼接升级版案例**\n\n定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法， 并在控制台输出结果。例如，数组为int[] arr = {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]\n\n```java\n/*\n    思路：\n    1:定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n    2:定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回。\n    返回值类型 String，参数列表 int[] arr\n    3:在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\n    4:调用方法，用一个变量接收结果\n    5:输出结果\n*/\npublic class StringBuilderTest01 {\n    public static void main(String[] args) {\n        //定义一个 int 类型的数组，用静态初始化完成数组元素的初始化\n        int[] arr = {1, 2, 3};\n        //调用方法，用一个变量接收结果\n        String s = arrayToString(arr);\n        //输出结果\n        System.out.println(\"s:\" + s);\n    }\n    \n    //定义一个方法，用于把 int 数组中的数据按照指定格式拼接成一个字符串返回\n    /*\n        两个明确：\n        返回值类型：String\n        参数：int[] arr\n	*/\n    public static String arrayToString(int[] arr) {\n        //在方法中用 StringBuilder 按照要求进行拼接，并把结果转成 String 返回\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for(int i=0; i<arr.length; i++) {\n            if(i == arr.length-1) {\n                sb.append(arr[i]);\n            } else {\n                sb.append(arr[i]).append(\", \");\n            }\n        }\n        sb.append(\"]\");\n        String s = sb.toString();\n        return s;\n    }\n} \n```\n\n\n\n2. **字符串反转升级版案例**\n\n定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果 例如，键盘录入abc，输出结果 cba\n\n```java\n/*\n    思路：\n    1:键盘录入一个字符串，用 Scanner 实现\n    2:定义一个方法，实现字符串反转。返回值类型 String，参数 String s\n    3:在方法中用StringBuilder实现字符串的反转，并把结果转成String返回\n    4:调用方法，用一个变量接收结果\n    5:输出结果\n*/\npublic class StringBuilderTest02 {\n    public static void main(String[] args) {\n        //键盘录入一个字符串，用 Scanner 实现\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串：\");\n        String line = sc.nextLine();\n        //调用方法，用一个变量接收结果\n        String s = myReverse(line);\n        //输出结果\n        System.out.println(\"s:\" + s);\n    }\n    //定义一个方法，实现字符串反转。返回值类型 String，参数 String s\n    /*\n        两个明确：\n        返回值类型：String\n        参数：String s\n    */\n    public static String myReverse(String s) {\n        //在方法中用StringBuilder实现字符串的反转，并把结果转成String返回\n        //String --- StringBuilder --- reverse() --- String\n        // StringBuilder sb = new StringBuilder(s);\n        // sb.reverse();\n        // String ss = sb.toString();\n        // return ss;\n        return new StringBuilder(s).reverse().toString();\n    }\n}\n```\n\n\n\n## 3.3 Math类\n\n概述：Math 包含执行基本数字运算的方法 \n\n* Math中方法的调用方式 \n  * Math类中无构造方法，但内部的方法都是静态的，则可以通过类名进行调用。\n\n* Math类常用方法\n\n| 方法名                                           | 说明                                           |\n| ------------------------------------------------ | ---------------------------------------------- |\n| public static int **abs**(int a)                 | 返回参数的绝对值                               |\n| public static double **ceil**(double a)          | 返回大于或等于参数的最小double值，等于一个整数 |\n| public static double **floor**(double a)         | 返回小于或等于参数的最大double值，等于一个整数 |\n| public static int **round**(float a)             | 按照四舍五入返回最接近参数的int                |\n| public static int **max**(int a,int b)           | 返回两个int值中的较大值                        |\n| public static int **min**(int a,int b)           | 返回两个int值中的较小值                        |\n| public static double **pow** (double a,double b) | 返回a的b次幂的值                               |\n| public static double **random**()                | 返回值为double的正值，[0.0,1.0)                |\n\n\n\n## 3.4 System类\n\n* System类的常用方法\n\n| 方法名                                 | 说明                                         |\n| -------------------------------------- | -------------------------------------------- |\n| public static void exit(int status)    | 终止当前运行的 Java 虚拟机，非零表示异常终止 |\n| public static long currentTimeMillis() | 返回当前时间(以毫秒为单位)                   |\n\n* 示例代码\n\n需求：在控制台输出1-10000，计算这段代码执行了多少毫秒\n\n```java\npublic class SystemDemo {\n    public static void main(String[] args) {\n        // 获取开始的时间节点\n        long start = System.currentTimeMillis();\n            for (int i = 1; i <= 10000; i++) {\n                System.out.println(i);\n            }\n        // 获取代码运行结束后的时间节点\n        long end = System.currentTimeMillis();\n            System.out.println(\"共耗时：\" + (end ­ start) + \"毫秒\");\n    }\n}\n```\n\n\n\n## 3.5 Object类\n\n* Object类概述 \n  * Object 是类层次结构的根，每个类都可以将 Object 作为**超类**。所有类都直接或者间接的继承自该类， 换句话说，该类所具备的方法，所有类都会有一份。\n* 查看方法源码的方式 \n  * 选中方法，按下**Ctrl + B** \n* 重写toString方法的方式 \n  * Alt + Insert 选择toString \n  * 在类的空白区域，右键 -> Generate -> 选择toString \n* toString方法的作用： \n  * 以良好的格式，更方便的展示对象中的属性值\n\n```java\n@Override\npublic String toString() {\n    return \"Student{\" +\n        \"name=\'\" + name + \'\\\'\' +\n        \", age=\" + age +\n        \'}\';\n}\n\n//运行结果\nStudent{name=\'xxx\', age=xx}\nStudent{name=\'xxx\', age=xx}\n```\n\n* equals方法的作用\n  * 用于对象之间的比较，返回true和false的结果 \n  * 举例：s1.equals(s2); s1和s2是两个对象\n* 重写equals方法的场景 \n  * 不希望比较对象的地址值，想要**结合对象属性**进行比较的时候。 \n* 重写equals方法的方式 \n  * alt + insert 选择equals() and hashCode()，IntelliJ Default，一路next，finish即可 \n  * 在类的空白区域，右键 -> Generate -> 选择equals() and hashCode()，后面的同上。\n\n```java\n@Override\npublic boolean equals(Object o) {\n    //this -- s1\n    //o -- s2\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Student student = (Student) o; //student -- s2\n    if (age != student.age) return false;\n    return name != null ? name.equals(student.name) : student.name == null;\n}\n\n//需求：比较两个对象的内容是否相同\nSystem.out.println(s1.equals(s2));\n```\n\n\n\n## 3.6 Arrays类\n\n* Arrays的常用方法\n\n| 方法名                                 | 说明                               |\n| -------------------------------------- | ---------------------------------- |\n| public static String toString(int[] a) | 返回指定数组的内容的字符串表达形式 |\n| public static void sort(int[] a)       | 按照数字顺序排列指定的数组         |\n\n* 工具类设计思想\n  * 构造方法用private修饰\n  * 成员用public static修饰\n\n\n\n## 3.7 包装类\n\n> 1、基本类型包装类\n\n* 作用\n\n  将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 \n\n  常用的操作之一：用于**基本数据类型**与**字符串**之间的转换\n\n| 基本数据类型 | 包装类    |\n| ------------ | --------- |\n| byte         | Byte      |\n| short        | Short     |\n| int          | Integer   |\n| long         | Long      |\n| float        | Float     |\n| double       | Double    |\n| char         | Character |\n| boolean      | Boolean   |\n\n\n\n> 2、Integer类\n\nInteger类概述 包装一个对象中的原始类型 int 的值\n\n| 方法名                                  | 说明                                     |\n| --------------------------------------- | ---------------------------------------- |\n| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer 实例     |\n| public static Integer valueOf(String s) | 返回一个保存指定值的 Integer 对象 String |\n\n```java\n//public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例\nInteger i3 = Integer.valueOf(100);\nSystem.out.println(i3);\n//public static Integer valueOf(String s)：返回一个保存指定值的Integer对象String\nInteger i4 = Integer.valueOf(\"100\");\nSystem.out.println(i4);\n```\n\n\n\n> int和String类型的相互转换\n\n* int转换成String\n  * 方法一：直接在数字后加一个空字符串\n  * **方法二**：通过String类静态方法**valueOf()**\n\n```java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //int --- String\n        int number = 100;\n        //方式1\n        String s1 = number + \"\";\n        System.out.println(s1);\n        //方式2\n        //public static String valueOf(int i)\n        String s2 = String.valueOf(number);\n        System.out.println(s2);\n        System.out.println(\"--------\");\n    }\n}\n```\n\n* String转换成int\n  * 方法一：先将字符串数字转成Integer，再调用valueOf()方法\n  * **方式二**：通过Integer静态方法**parseInt()**进行转换\n\n```java\npublic class IntegerDemo {\n    public static void main(String[] args) {\n        //String --- int\n        String s = \"100\";\n        //方式1：String --- Integer --- int\n        Integer i = Integer.valueOf(s);\n        //public int intValue()\n        int x = i.intValue();\n        System.out.println(x);\n        //方式2\n        //public static int parseInt(String s)\n        int y = Integer.parseInt(s);\n        System.out.println(y);\n    }\n}\n```\n\n\n\n> 3、字符串排序案例\n\n* 案例需求 \n\n  有一个字符串：“91 27 46 38 50”，请写程序实现最终输出结果是：“27 38 46 50 91”\n\n```java\npublic class IntegerTest {\n    public static void main(String[] args) {\n        //定义一个字符串\n        String s = \"91 27 46 38 50\";\n        //把字符串中的数字数据存储到一个int类型的数组中\n        String[] strArray = s.split(\" \");\n        // for(int i=0; i<strArray.length; i++) {\n        // System.out.println(strArray[i]);\n        // }\n        //定义一个int数组，把 String[] 数组中的每一个元素存储到 int 数组中\n        int[] arr = new int[strArray.length];\n        for(int i=0; i<arr.length; i++) {\n            arr[i] = Integer.parseInt(strArray[i]);\n        }\n        //对 int 数组进行排序\n        Arrays.sort(arr);\n        \n        //把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现\n        StringBuilder sb = new StringBuilder();\n        for(int i=0; i<arr.length; i++) {\n            if(i == arr.length - 1) {\n                sb.append(arr[i]);\n            } else {\n                sb.append(arr[i]).append(\" \");\n            }\n        }\n        String result = sb.toString();\n        //输出结果\n        System.out.println(result);\n    }\n}\n```\n\n\n\n> 4、自动拆箱和自动装箱\n\n* 自动装箱 \n\n  把基本数据类型转换为对应的包装类类型 \n\n* 自动拆箱 \n\n  把包装类类型转换为对应的基本数据类型\n\n```java\nInteger i = 100; // 自动装箱\ni += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱\n```\n\n\n\n## 3.8 Date类\n\n> 1、Date类\n\n* Date类概述 \n\n  Date 代表了一个特定的时间，精确到毫秒\n\n* Date类构造方法\n\n| 方法名                 | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| public Date()          | 分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒 |\n| public Date(long date) | 分配一个 Date对象，并将其初始化为表示从**标准基准时间**起指定的毫秒数 |\n\n基准时间：Thu Jan 01 08:00:00 CST 1970\n\n```java\n//public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\nDate d1 = new Date();\nSystem.out.println(d1);//Sun Jan 29 16:23:30 CST 2023\n\n//public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\nlong date = 1000*60*60;\nDate d2 = new Date(date);\nSystem.out.println(d2);//Thu Jan 01 09:00:00 CST 1970\n```\n\n* 常用方法\n\n| 方法名                         | 说明                                                  |\n| ------------------------------ | ----------------------------------------------------- |\n| public long getTime()          | 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 |\n| public void setTime(long time) | 设置时间，给的是毫秒值                                |\n\n```java\npublic class DateDemo02 {\n    public static void main(String[] args) {\n        //创建日期对象\n        Date d = new Date();\n        //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值\n        // System.out.println(d.getTime());\n        // System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 +\n        \"年\");\n        //public void setTime(long time):设置时间，给的是毫秒值\n        // long time = 1000*60*60;\n        long time = System.currentTimeMillis();\n        d.setTime(time);\n        System.out.println(d);\n    }\n}\n```\n\n\n\n> 2、SimpleDateFormat类\n\n概述：SimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。\n\n我们重点学习日期格式化和解析\n\n| 方法名                                    | 说明                                                     |\n| ----------------------------------------- | -------------------------------------------------------- |\n| public final String **format**(Date date) | 将日期格式化成日期/时间字符串**（Date—>String）**        |\n| public Date **parse**(String source)      | 从给定字符串的开始解析文本以生成日期**（String—>Date）** |\n\n```java\npublic class SimpleDateFormatDemo {\n    public static void main(String[] args) throws ParseException {\n        //格式化：从 Date 到 String\n        Date d = new Date();\n        // SimpleDateFormat sdf = new SimpleDateFormat();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n        String s = sdf.format(d);\n        System.out.println(s);//2023年01月29日 16:36:27\n        System.out.println(\"--------\");\n        \n        //从 String 到 Date\n        String ss = \"2048-08-09 11:11:11\";\n        //ParseException\n        SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        Date dd = sdf2.parse(ss);\n        System.out.println(dd);//Sun Aug 09 11:11:11 CST 2048\n    }\n}\n```\n\n\n\n> 3、日期工具类案例\n\n定义一个日期工具类(DateUtils)，包含两个方法：把日期转换为指定格式的字符串；把字符串解析为指定格式 的日期，然后定义一个测试类(DateDemo)，测试日期工具类的方法\n\n* 工具类\n\n```java\npublic class DateUtils {\n    private DateUtils() {}\n    /*\n    把日期转为指定格式的字符串\n    返回值类型：String\n    参数：Date date, String format\n    */\n    public static String dateToString(Date date, String format) {\n        SimpleDateFormat sdf = new SimpleDateFormat(format);\n        String s = sdf.format(date);\n        return s;\n    }\n    /*\n    把字符串解析为指定格式的日期\n    返回值类型：Date\n    参数：String s, String format\n    */\n    public static Date stringToDate(String s, String format) throws\n        ParseException {\n        SimpleDateFormat sdf = new SimpleDateFormat(format);\n        Date d = sdf.parse(s);\n        return d;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class DateDemo {\n    public static void main(String[] args) throws ParseException {\n        //创建日期对象\n        Date d = new Date();\n        String s1 = DateUtils.dateToString(d, \"yyyy年MM月dd日 HH:mm:ss\");\n        System.out.println(s1);\n        String s2 = DateUtils.dateToString(d, \"yyyy年MM月dd日\");\n        System.out.println(s2);\n        String s3 = DateUtils.dateToString(d, \"HH:mm:ss\");\n        System.out.println(s3);\n        System.out.println(\"--------\");\n        String s = \"2048-08-09 12:12:12\";\n        Date dd = DateUtils.stringToDate(s, \"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(dd);\n    }\n}\n```\n\n\n\n## 3.9 Calender类\n\n概述：Calendar 为特定瞬间与一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法 。\n\nCalendar 提供了一个类方法 getInstance 用于获取这种类型的一般有用的对象。 \n\n该方法返回一个Calendar 对象。 \n\n其日历字段已使用当前日期和时间初始化：Calendar rightNow = Calendar.getInstance();\n\n| 方法名                                                 | 说明                                                   |\n| ------------------------------------------------------ | ------------------------------------------------------ |\n| public int **get**(int field)                          | 返回给定日历字段的值                                   |\n| public abstract void **add**(int field, int amount)    | 根据日历的规则，将指定的时间量添加或减去给定的日历字段 |\n| public final void **set**(int year,int month,int date) | 设置当前日历的年月日                                   |\n\n```java\npublic class CalendarDemo {\n    public static void main(String[] args) {\n        //获取日历类对象\n        Calendar c = Calendar.getInstance();\n        //public int get(int field):返回给定日历字段的值\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int date = c.get(Calendar.DATE);\n        System.out.println(year + \"年\" + month + \"月\" + date + \"日\");\n        //public abstract void add(int field, int amount):根据日历的规则，将指定的时间量添加或减去给定的日历字段\n            //需求1:3年前的今天\n            // c.add(Calendar.YEAR,-3);\n            // year = c.get(Calendar.YEAR);\n            // month = c.get(Calendar.MONTH) + 1;\n            // date = c.get(Calendar.DATE);\n            // System.out.println(year + \"年\" + month + \"月\" + date + \"日\");\n            //需求2:10年后的10天前\n            // c.add(Calendar.YEAR,10);\n            // c.add(Calendar.DATE,-10);\n            // year = c.get(Calendar.YEAR);\n            // month = c.get(Calendar.MONTH) + 1;\n            // date = c.get(Calendar.DATE);\n            // System.out.println(year + \"年\" + month + \"月\" + date + \"日\");\n            //public final void set(int year,int month,int date):设置当前日历的年月日\n            c.set(2050,10,10);\n        year = c.get(Calendar.YEAR);\n        month = c.get(Calendar.MONTH) + 1;\n        date = c.get(Calendar.DATE);\n        System.out.println(year + \"年\" + month + \"月\" + date + \"日\");\n    }\n}\n```\n\n\n\n> 二月天案例\n\n获取任意一年的二月有多少天\n\n```java\npublic class CalendarTest {\n    public static void main(String[] args) {\n        //键盘录入任意的年份\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入年：\");\n        int year = sc.nextInt();\n        //设置日历对象的年、月、日\n        Calendar c = Calendar.getInstance();\n        c.set(year, 2, 1);\n        //3月1日往前推一天，就是2月的最后一天\n        c.add(Calendar.DATE, -1);\n        //获取这一天输出即可\n        int date = c.get(Calendar.DATE);\n        System.out.println(year + \"年的2月份有\" + date + \"天\");\n    }\n}\n```\n\n\n\n# 4. Java特性\n\n## 4.1 对象内存图\n\n* 成员变量使用过程\n\n![image-20230128145801533](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230128145801533.png)\n\n* 成员方法调用过程\n\n![image-20230128145826634](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230128145826634.png)\n\n注：多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份。\n\n\n\n## 4.2 权限修饰符\n\n![image-20230128232744698](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230128232744698.png)\n\n\n\n## 4.3 final修饰符\n\n作用：final代表最终的意思，可以修饰成员方法，成员变量，类\n\n* 效果\n  * fianl修饰类：该类不能被继承（不能有子类，但是可以有父类）\n  * final修饰方法：该方法不能被重写 \n  * final修饰变量：表明该变量是一个常量，不能再次赋值\n\n* fianl修饰基本数据类型变量 \n  * final 修饰指的是基本类型的**数据值**不能发生改变 \n* final修饰引用数据类型变量 \n  * final 修饰指的是引用类型的**地址值**不能发生改变，但是地址里面的内容是可以发生改变的\n\n\n\n## 4.4 static关键字\n\n* static的概念 \n  * static关键字是静态的意思，可以修饰【成员方法】，【成员变量】 \n* static修饰的特点 \n  1. 被类的所有对象共享，这也是我们判断是否使用静态关键字的条件\n  2. 可以通过类名调用当然，也可以通过对象名调用【推荐**使用类名调用**】\n\n```java\nclass Student {\n    public String name; //姓名\n    public int age; //年龄\n    public static String university; //学校 共享数据！所以设计为静态！\n    public void show() {\n        System.out.println(name + \",\" + age + \",\" + university);\n    }\n}\npublic class StaticDemo {\n    public static void main(String[] args) {\n        // 为对象的共享数据赋值\n        Student.university = \"传智大学\";\n            Student s1 = new Student();\n            s1.name = \"林青霞\";\n            s1.age = 30;\n            s1.show();\n            Student s2 = new Student();\n            s2.name = \"风清扬\";\n            s2.age = 33;\n            s2.show();\n    }\n}\n```\n\n* static的访问特点 \n  * 非静态的成员方法 \n    * 能访问静态的成员变量 \n    * 能访问非静态的成员变量 \n    * 能访问静态的成员方法 \n    * 能访问非静态的成员方法 \n  * 静态的成员方法\n    *  能访问静态的成员变量 \n    *  能访问静态的成员方法 \n\n总结成一句话就是：静态成员方法只能访问静态成员（非静态可以为所欲为）\n\n\n\n## 4.5 抽象类\n\n当我们在做子类共性功能抽取时，**有些方法在父类中并没有具体的体现**，这个时候就需要抽象类了！ 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！\n\n```java\n//抽象类的定义\npublic abstract class 类名 {}\n//抽象方法的定义\npublic abstract void eat();\n```\n\n* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\n\n* 抽象类不能实例化\n\n  抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态\n\n* 抽象类的子类\n\n  要么**重写**抽象类中的**所有抽象方法** \n\n  要么是抽象类\n\n \n\n> 案例\n\n请采用抽象类的思想实现猫和狗的案例，并在测试类中进行测试\n\n* 动物类\n\n```java\npublic abstract class Animal {\n    private String name;\n        private int age;\n        public Animal() {\n    }\n    public Animal(String name, int age) {\n        this.name = name;\n            this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public abstract void eat();\n}\n```\n\n* 猫类\n\n```java\npublic class Cat extends Animal {\n    public Cat() {\n    }\n    public Cat(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void eat() {\n        System.out.println(\"猫吃鱼\");\n    }\n}\n```\n\n* 狗类\n\n```java\npublic class Dog extends Animal {\n    public Dog() {\n    }\n    public Dog(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void eat() {\n        System.out.println(\"狗吃骨头\");\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //创建对象，按照多态的方式\n        Animal a = new Cat();\n            a.setName(\"加菲\");\n            a.setAge(5);\n            System.out.println(a.getName()+\",\"+a.getAge());\n            a.eat();\n            System.out.println(\"­­­­­­­­\");\n            a = new Cat(\"加菲\",5);\n            System.out.println(a.getName()+\",\"+a.getAge());\n            a.eat();\n    }\n}\n```\n\n\n\n## 4.6 接口\n\n接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。\n\nJava中的接口更多的体现在对行为的抽象！\n\n```java\n//接口用关键字interface修饰\npublic interface 接口名 {}\n\n//类实现接口用implements表示\npublic class 类名 implements 接口名 {}\n```\n\n* 接口不能实例化 \n\n  接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。 \n\n  多态的形式：具体类多态，抽象类多态，接口多态。\n\n* 接口的子类 \n\n  要么重写接口中的所有抽象方法 \n\n  要么子类也是抽象类\n\n> 接口的成员特点\n\n* 成员特点 \n\n  * 成员变量 \n\n    只能是常量 \n\n    默认修饰符：public static final \n\n  * 构造方法 \n\n    没有，因为接口主要是**扩展功能**的，而没有具体存在 \n\n  * 成员方法 \n\n    只能是抽象方法 \n\n    默认修饰符：public abstract \n\n    关于接口中的方法，JDK8和JDK9中有一些新特性（暂不讲解）\n\n> 案例\n\n* 案例需求 \n\n  对猫和狗进行训练，他们就可以跳高了，这里加入跳高功能。 \n\n  请采用抽象类和接口来实现猫狗案例，并在测试类中进行测试。\n\n* 动物类\n\n```java\npublic abstract class Animal {\n    private String name;\n        private int age;\n        public Animal() {\n    }\n    public Animal(String name, int age) {\n        this.name = name;\n            this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public abstract void eat();\n}\n```\n\n* 跳高接口\n\n```java\npublic interface Jumpping {\n    public abstract void jump();\n}\n```\n\n* 猫类\n\n```java\npublic class Cat extends Animal implements Jumpping {\n    public Cat() {\n    }\n    public Cat(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void eat() {\n        System.out.println(\"猫吃鱼\");\n    }\n    @Override\n    public void jump() {\n        System.out.println(\"猫可以跳高了\");\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        //创建对象，调用方法\n        Jumpping j = new Cat();\n            j.jump();\n            System.out.println(\"­­­­­­­­\");\n\n            Animal a = new Cat();\n            a.setName(\"加菲\");\n            a.setAge(5);\n            System.out.println(a.getName()+\",\"+a.getAge());\n            a.eat();\n            // a.jump();\n\n            a = new Cat(\"加菲\",5);\n            System.out.println(a.getName()+\",\"+a.getAge());\n            a.eat();\n            System.out.println(\"­­­­­­­­\");\n\n            Cat c = new Cat();\n            c.setName(\"加菲\");\n            c.setAge(5);\n            System.out.println(c.getName()+\",\"+c.getAge());\n            c.eat();\n            c.jump();\n    }\n}\n```\n\n> 类和接口的关系\n\n* 类与类的关系 \n\n  **继承关系**，只能单继承，但是可以多层继承 \n\n* 类与接口的关系 \n\n  **实现关系**，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 \n\n* 接口与接口的关系 \n\n  **继承关系**，可以单继承，也可以多继承\n\n> 抽象类和接口的区别\n\n* 成员区别 \n\n  * 抽象类 \n\n    变量,常量；有构造方法；\n\n    有抽象方法,也有非抽象方法 \n\n  * 接口 \n\n    常量；抽象方法 \n\n* 设计理念区别 \n\n  * 抽象类 \n\n    对类抽象，包括**属性**、**行为** \n\n  * 接口 \n\n    对象为抽象，主要是**行为**\n\n\n\n## 4.7 泛型\n\n* 泛型概述 \n\n  是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型 它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方 法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具 体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称 为泛型类、泛型方法、泛型接口 \n\n* 泛型定义格式 \n\n  * <类型>：指定一种类型的格式。这里的类型可以看成是形参 \n  * <类型1,类型2…>：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参 \n  * 将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型 \n\n* 泛型的好处 \n\n  * 把运行时期的问题提前到了编译期间 \n  * 避免了强制类型转换\n\n> 1、泛型类\n\n* 定义格式\n\n```java\n修饰符 class 类名<类型> { }\n```\n\n* 泛型类\n\n```java\npublic class Generic<T> {\n    private T t;\n    public T getT() {\n        return t;\n    }\n    public void setT(T t) {\n        this.t = t;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class GenericDemo {\n    public static void main(String[] args) {\n        Generic<String> g1 = new Generic<String>();\n        g1.setT(\"林青霞\");\n        System.out.println(g1.getT());\n        Generic<Integer> g2 = new Generic<Integer>();\n        g2.setT(30);\n        System.out.println(g2.getT());\n        Generic<Boolean> g3 = new Generic<Boolean>();\n        g3.setT(true);\n        System.out.println(g3.getT());\n    }\n}\n```\n\n\n\n> 2、泛型方法\n\n* 定义格式\n\n```java\n修饰符 <类型> 返回值类型 方法名(类型 变量名) { }\n```\n\n* 带有泛型方法的类\n\n```java\npublic class Generic {\n    public <T> void show(T t) {\n        System.out.println(t);\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class GenericDemo {\n    public static void main(String[] args) {\n        Generic g = new Generic();\n        g.show(\"林青霞\");\n        g.show(30);\n        g.show(true);\n        g.show(12.34);\n    }\n}\n```\n\n\n\n> 3、泛型接口\n\n* 定义格式\n\n```java\n修饰符 interface 接口名<类型> { }\n```\n\n* 泛型接口\n\n```java\npublic interface Generic<T> {\nvoid show(T t);\n}\n```\n\n* 泛型接口实现类\n\n```java\npublic class GenericImpl<T> implements Generic<T> {\n    @Override\n    public void show(T t) {\n        System.out.println(t);\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class GenericDemo {\n    public static void main(String[] args) {\n        Generic<String> g1 = new GenericImpl<String>();\n        g1.show(\"林青霞\");\n        Generic<Integer> g2 = new GenericImpl<Integer>();\n        g2.show(30);\n    }\n}\n```\n\n\n\n> 4、类型通配符\n\n* 类型通配符的作用\n\n  为了表示各种泛型List的父类，可以使用类型通配符\n\n* 类型通配符的分类 \n\n  * 类型通配符：<?>\n    *  List<?>：表示元素类型未知的List，它的元素可以匹配任何的类型 \n    *  这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中 \n  * 类型通配符上限： <? extends 类型>\n    * List<? extends Number>：它表示的类型是Number或者其子类型 \n  * 类型通配符下限： <? super 类型> \n    * List<? super Number> ：它表示的类型是Number或者其父类型\n\n* 类型通配符的基本使用\n\n```java\npublic class GenericDemo {\n    public static void main(String[] args) {\n        //类型通配符：<?>\n        List<?> list1 = new ArrayList<Object>();\n        List<?> list2 = new ArrayList<Number>();\n        List<?> list3 = new ArrayList<Integer>();\n        System.out.println(\"--------\");\n        \n        //类型通配符上限：<? extends 类型>\n        // List<? extends Number> list4 = new ArrayList<Object>();\n        List<? extends Number> list5 = new ArrayList<Number>();\n        List<? extends Number> list6 = new ArrayList<Integer>();\n        System.out.println(\"--------\");\n        \n        //类型通配符下限：<? super 类型>\n        List<? super Number> list7 = new ArrayList<Object>();\n        List<? super Number> list8 = new ArrayList<Number>();\n        // List<? super Number> list9 = new ArrayList<Integer>();\n    }\n}\n```\n\n\n\n## 4.8 可变参数\n\n* 可变参数介绍 \n\n  可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 \n\n* 可变参数定义格式\n\n```java\n修饰符 返回值类型 方法名(数据类型… 变量名) { }\n```\n\n* 可变参数的注意事项 \n  * 这里的变量其实是一个数组 \n  * 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n* 可变参数的基本使用\n\n```java\npublic class ArgsDemo01 {\n    public static void main(String[] args) {\n        System.out.println(sum(10, 20));\n        System.out.println(sum(10, 20, 30));\n        System.out.println(sum(10, 20, 30, 40));\n        System.out.println(sum(10,20,30,40,50));\n        System.out.println(sum(10,20,30,40,50,60));\n        System.out.println(sum(10,20,30,40,50,60,70));\n        System.out.println(sum(10,20,30,40,50,60,70,80,90,100));\n    }\n    \n    // public static int sum(int b,int... a) {\n    // return 0;\n    // }\n    public static int sum(int... a) {\n        int sum = 0;\n        for(int i : a) {\n            sum += i;\n        }\n        return sum;\n    }\n}\n```\n\n>可变参数的使用\n\n* Arrays工具类中有一个静态方法： \n  * public static List **asList**(T... a)：返回由指定数组支持的固定大小的列表 \n  * 返回的集合不能做增删操作，可以做修改操作 \n* List接口中有一个静态方法： \n  * public static List **of**(E... elements)：返回包含任意数量元素的不可变列表 \n  * 返回的集合不能做增删改操作 \n* Set接口中有一个静态方法： \n  * public static Set **of**(E... elements) ：返回一个包含任意数量元素的不可变集合 \n  * 在给元素的时候，不能给重复的元素 \n  * 返回的集合不能做增删操作，没有修改的方法\n\n```java\npublic class ArgsDemo02 {\n    public static void main(String[] args) {\n        public static <T> List<T> asList(T... a)：//返回由指定数组支持的固定大小的列表\n        List<String> list = Arrays.asList(\"hello\", \"world\", \"java\");\n        list.add(\"javaee\"); //UnsupportedOperationException\n        list.remove(\"world\"); //UnsupportedOperationException\n        list.set(1,\"javaee\");\n        System.out.println(list);\n        \n        public static <E> List<E> of(E... elements)：//返回包含任意数量元素的不可变列表\n        List<String> list = List.of(\"hello\", \"world\", \"java\", \"world\");\n        list.add(\"javaee\");//UnsupportedOperationException\n        list.remove(\"java\");//UnsupportedOperationException\n        list.set(1,\"javaee\");//UnsupportedOperationException\n        System.out.println(list);\n\n        public static <E> Set<E> of(E... elements) ：//返回一个包含任意数量元素的不可变集合\n        Set<String> set = Set.of(\"hello\", \"world\", \"java\",\"world\");\n        IllegalArgumentException\n        Set<String> set = Set.of(\"hello\", \"world\", \"java\");\n        set.add(\"javaee\");//UnsupportedOperationException\n        set.remove(\"world\");//UnsupportedOperationException\n        System.out.println(set);\n    }\n}\n```\n\n\n\n# 5. 异常\n\n> 1、概念\n\n异常就是程序出现了不正常的情况\n\n![image-20230129164715505](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230129164715505.png)\n\n\n\n> 2、JVM默认处理异常的方式\n\n如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤： \n\n* 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台 \n* 程序停止执行\n\n\n\n## 5.1 try-catch方式处理异常\n\n* 程序从 try 里面的代码开始执行 \n* 出现异常，就会跳转到对应的 catch 里面去执行 \n* 执行完毕之后，程序还可以继续往下执行\n\n```java\ntry {\n    可能出现异常的代码;\n} catch(异常类名 变量名) {\n    异常的处理代码;\n}\n```\n\n* 示例代码\n\n```java\npublic class ExceptionDemo01 {\n    public static void main(String[] args) {\n        System.out.println(\"开始\");\n        method();\n        System.out.println(\"结束\");\n    }\n    public static void method() {\n        try {\n            int[] arr = {1, 2, 3};\n            System.out.println(arr[3]);\n            System.out.println(\"这里能够访问到吗\");\n        } catch (ArrayIndexOutOfBoundsException e) {\n            // System.out.println(\"你访问的数组索引不存在，请回去修改为正确的索引\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n## 5.2 Throwable成员方法\n\n* 常用方法\n\n| 方法名                        | 说明                              |\n| ----------------------------- | --------------------------------- |\n| public String getMessage()    | 返回此 throwable 的详细消息字符串 |\n| public String toString()      | 返回此可抛出的简短描述            |\n| public void printStackTrace() | 把异常的错误信息输出在控制台      |\n\n```java\npublic class ExceptionDemo02 {\n    public static void main(String[] args) {\n        System.out.println(\"开始\");\n        method();\n        System.out.println(\"结束\");\n    }\n    public static void method() {\n        try {\n            int[] arr = {1, 2, 3};\n            System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();\n            System.out.println(\"这里能够访问到吗\");\n        } catch (ArrayIndexOutOfBoundsException e) { //new\n            ArrayIndexOutOfBoundsException();\n            // e.printStackTrace();\n            //public String getMessage():返回此 throwable 的详细消息字符串\n            // System.out.println(e.getMessage());\n            //Index 3 out of bounds for length 3\n            //public String toString():返回此可抛出的简短描述\n            // System.out.println(e.toString());\n            //java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n                //public void printStackTrace():把异常的错误信息输出在控制台\n                e.printStackTrace();\n            // java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n                // at com.itheima_02.ExceptionDemo02.method(ExceptionDemo02.java:18)\n                // at com.itheima_02.ExceptionDemo02.main(ExceptionDemo02.java:11)\n        }\n    }\n}\n```\n\n\n\n>编译时异常和运行时异常的区别\n\n* 编译时异常 \n  * 都是Exception类及其子类 \n  * 必须显示处理，否则程序就会发生错误，无法通过编译 \n* 运行时异常 \n  * 都是RuntimeException类及其子类 \n  * 无需显示处理，也可以和编译时异常一样处理\n\n\n\n## 5.3 throws方式处理异常\n\n* 定义格式\n\n```java\npublic void 方法() throws 异常类名 {\n}\n```\n\n* 示例代码\n\n```java\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        System.out.println(\"开始\");\n        // method();\n        try {\n            method2();\n        }catch (ParseException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"结束\");\n    }\n    //编译时异常\n    public static void method2() throws ParseException {\n        String s = \"2048-08-09\";\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date d = sdf.parse(s);\n        System.out.println(d);\n    }\n    //运行时异常\n    public static void method() throws ArrayIndexOutOfBoundsException {\n        int[] arr = {1, 2, 3};\n        System.out.println(arr[3]);\n    }\n}\n```\n\n* 注意\n  * 这个throws格式是跟在方法的括号后面的 \n  * 编译时异常必须要进行处理，两种处理方案：try...catch …或者 throws，如果采用 throws 这种方案， 将来谁调用谁处理 \n  * 运行时异常可以不处理，出现问题后，需要我们回来修改代码\n\n\n\n>throws和throw的区别\n\n![image-20230129165721691](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230129165721691.png)\n\n\n\n## 5.4 自定义异常\n\n* 自定义异常类\n\n```java\npublic class ScoreException extends Exception {\n    public ScoreException() {}\n    public ScoreException(String message) {\n        super(message);\n    }\n}\n```\n\n* 老师类\n\n```java\npublic class Teacher {\n    public void checkScore(int score) throws ScoreException {\n        if(score<0 || score>100) {\n            // throw new ScoreException();\n            throw new ScoreException(\"你给的分数有误，分数应该在0-100之间\");\n        } else {\n            System.out.println(\"成绩正常\");\n        }\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入分数：\");\n        int score = sc.nextInt();\n        Teacher t = new Teacher();\n        try {\n            t.checkScore(score);\n        } catch (ScoreException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n# 6. 集合\n\n> 集合体系结构\n\n* 集合类的特点 \n\n  提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变 \n\n* 集合类的体系图\n\n![image-20230129190528576](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230129190528576.png)\n\n\n\n## 6.1 Collection集合\n\n> 概述\n\n* Collection集合概述 \n  * 是单例集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素 \n  * JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如**Set**和**List**）实现\n\n* Collection集合基本使用\n\n```java\npublic class CollectionDemo01 {\n    public static void main(String[] args) {\n        //创建Collection集合的对象\n        Collection<String> c = new ArrayList<String>();\n        //添加元素：boolean add(E e)\n        c.add(\"hello\");\n        c.add(\"world\");\n        c.add(\"java\");\n        //输出集合对象\n        System.out.println(c);\n    }\n}\n```\n\n* Collection集合的常用方法\n\n| 方法名                     | 说明                               |\n| -------------------------- | ---------------------------------- |\n| boolean add(E e)           | 添加元素                           |\n| boolean remove(Object o)   | 从集合中移除指定的元素             |\n| void clear()               | 清空集合中的元素                   |\n| boolean contains(Object o) | 判断集合中是否存在指定的元素       |\n| boolean isEmpty()          | 判断集合是否为空                   |\n| int size()                 | 集合的长度，也就是集合中元素的个数 |\n\n> 1、Collection集合的遍历\n\n* 迭代器的介绍 \n  * 迭代器，集合的专用遍历方式 \n  * Iterator iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 \n  * 迭代器是通过**集合的iterator()**方法得到的，所以我们说它是依赖于集合而存在的\n\n* Collection集合的遍历\n\n```java\npublic class IteratorDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        Collection<String> c = new ArrayList<>();\n        //添加元素\n        c.add(\"hello\");\n        c.add(\"world\");\n        c.add(\"java\");\n        c.add(\"javaee\");\n        //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到\n        Iterator<String> it = c.iterator();\n        //用while循环改进元素的判断和获取\n        while (it.hasNext()) {\n            String s = it.next();\n            System.out.println(s);\n        }\n    }\n}\n```\n\n\n\n> 2、集合的案例-Collection集合存储学生对象并遍历\n\n创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class CollectionDemo {\n    public static void main(String[] args) {\n        //创建Collection集合对象\n        Collection<Student> c = new ArrayList<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"张曼玉\", 35);\n        Student s3 = new Student(\"王祖贤\", 33);\n        //把学生添加到集合\n        c.add(s1);\n        c.add(s2);\n        c.add(s3);\n        //遍历集合(迭代器方式)\n        Iterator<Student> it = c.iterator();\n        while (it.hasNext()) {\n            Student s = it.next();\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n\n\n## 6.2 List集合\n\n* List集合概述 \n  * **有序集合**(也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素 \n  * 与Set集合不同，列表通常允许重复的元素\n\n* List集合特点 \n  * 有索引 \n  * 可以存储重复元素 \n  * 元素存取有序\n\n* List集合的特有方法\n\n| 方法名                        | 描述                                       |\n| ----------------------------- | ------------------------------------------ |\n| void add(int index,E element) | 在此集合中的指定位置**插入**指定的元素     |\n| E remove(int index)           | **删除**指定索引处的元素，返回被删除的元素 |\n| E set(int index,E element)    | **修改**指定索引处的元素，返回被修改的元素 |\n| E get(int index)              | 返回指定索引处的元素                       |\n\n\n\n>1、集合的案例-List集合存储学生对象并遍历\n\n创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class ListDemo {\n    public static void main(String[] args) {\n        //创建List集合对象\n        List<Student> list = new ArrayList<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"张曼玉\", 35);\n        Student s3 = new Student(\"王祖贤\", 33);\n        //把学生添加到集合\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n        \n        //迭代器方式\n        Iterator<Student> it = list.iterator();\n        while (it.hasNext()) {\n            Student s = it.next();\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n        System.out.println(\"--------\");\n        \n        //for循环方式\n        for(int i=0; i<list.size(); i++) {\n            Student s = list.get(i);\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}   \n```\n\n\n\n> 2、并发修改异常\n\n* 出现的原因 \n\n  迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException \n\n* 解决的方案 \n\n  用**for循环遍历**，然后用集合对象做对应的操作即可\n\n```java\npublic class ListDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        List<String> list = new ArrayList<String>();\n        //添加元素\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        //遍历集合，得到每一个元素，看有没有\"world\"这个元素，如果有，我就添加一个\"javaee\"元素，请写代码实现\n            // Iterator<String> it = list.iterator();\n            // while (it.hasNext()) {\n            // String s = it.next();\n            // if(s.equals(\"world\")) {\n            // list.add(\"javaee\");\n            // }\n            // }\n            for(int i=0; i<list.size(); i++) {\n                String s = list.get(i);\n                if(s.equals(\"world\")) {\n                    list.add(\"javaee\");\n                }\n            }\n        //输出集合对象\n        System.out.println(list);\n    }\n}\n```\n\n\n\n> 3、列表迭代器\n\n* ListIterator介绍 \n  * 通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器 \n  * 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置\n\n```java\npublic class ListIteratorDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        List<String> list = new ArrayList<String>();\n        //添加元素\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        //获取列表迭代器\n        ListIterator<String> lit = list.listIterator();\n        while (lit.hasNext()) {\n            String s = lit.next();\n            if(s.equals(\"world\")) {\n                lit.add(\"javaee\");\n            }\n        }\n        System.out.println(list);\n    }\n}\n```\n\n\n\n> 4、增强for循环\n\n```java\n//定义格式\nfor(元素数据类型 变量名 : 数组/集合对象名) {\n    循环体;\n}\n```\n\n* 示例代码\n\n```java\npublic class ForDemo {\n    public static void main(String[] args) {\n        int[] arr = {1,2,3,4,5};\n        for(int i : arr) {\n            System.out.println(i);\n        }\n        System.out.println(\"--------\");\n        \n        String[] strArray = {\"hello\",\"world\",\"java\"};\n        for(String s : strArray) {\n            System.out.println(s);\n        }\n        System.out.println(\"--------\");\n        \n        List<String> list = new ArrayList<String>();\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        for(String s : list) {\n            System.out.println(s);\n        }\n        System.out.println(\"--------\");\n        //内部原理是一个Iterator迭代器\n        /*\n        for(String s : list) {\n            if(s.equals(\"world\")) {\n            	list.add(\"javaee\"); //ConcurrentModificationException\n            }\n        }\n        */\n    }\n}\n```\n\n\n\n> 5、集合的案例-List集合存储学生对象三种方式遍历\n\n创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class ListDemo {\n    public static void main(String[] args) {\n        //创建List集合对象\n        List<Student> list = new ArrayList<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"张曼玉\", 35);\n        Student s3 = new Student(\"王祖贤\", 33);\n        //把学生添加到集合\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n        \n        //迭代器：集合特有的遍历方式\n        Iterator<Student> it = list.iterator();\n        while (it.hasNext()) {\n            Student s = it.next();\n            System.out.println(s.getName()+\",\"+s.getAge());\n        }\n        System.out.println(\"--------\");\n        \n        //普通for：带有索引的遍历方式\n        for(int i=0; i<list.size(); i++) {\n            Student s = list.get(i);\n            System.out.println(s.getName()+\",\"+s.getAge());\n        }\n        System.out.println(\"--------\");\n        \n        //增强for：最方便的遍历方式\n        for(Student s : list) {\n            System.out.println(s.getName()+\",\"+s.getAge());\n        }\n    }\n} \n```\n\n\n\n## 6.3 ArrayList集合\n\n* ArrayList集合 \n\n  底层是**数组结构**实现，**查询快、增删慢**\n\n* 泛型的使用 \n\n  用于约束集合中存储元素的数据类型\n\n* 构造方法\n\n| 方法名             | 说明                 |\n| ------------------ | -------------------- |\n| public ArrayList() | 创建一个空的集合对象 |\n\n* 成员方法\n\n| 方法名                               | 说明                                   |\n| ------------------------------------ | -------------------------------------- |\n| public boolean remove(Object o)      | 删除指定的元素，返回删除是否成功       |\n| public E remove(int index)           | 删除指定索引处的元素，返回被删除的元素 |\n| public E set(int index,E element)    | 修改指定索引处的元素，返回被修改的元素 |\n| public E get(int index)              | 返回指定索引处的元素                   |\n| public int size()                    | 返回集合中的元素的个数                 |\n| public boolean add(E e)              | 将指定的元素追加到此集合的末尾         |\n| public void add(int index,E element) | 在此集合中的指定位置插入指定的元素     |\n\n> 1、存储字符串并遍历\n\n创建一个存储字符串的集合，存储3个字符串元素，使用程序实现在控制台遍历该集合\n\n```java\n/*\n    思路：\n    1:创建集合对象\n    2:往集合中添加字符串对象\n    3:遍历集合，首先要能够获取到集合中的每一个元素，这个通过get(int index)方法实现\n    4:遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\n    5:遍历集合的通用格式\n*/\npublic class ArrayListTest01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        ArrayList<String> array = new ArrayList<String>();\n        //往集合中添加字符串对象\n        array.add(\"刘正风\");\n        array.add(\"左冷禅\");\n        array.add(\"风清扬\");\n        //遍历集合，其次要能够获取到集合的长度，这个通过size()方法实现\n        // System.out.println(array.size());\n        //遍历集合的通用格式\n        for(int i=0; i<array.size(); i++) {\n            String s = array.get(i);\n            System.out.println(s);\n        }\n    }\n}\n```\n\n>2、存储学生对象并遍历\n\n创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n```java\n/*\n    思路：\n    1:定义学生类\n    2:创建集合对象\n    3:创建学生对象\n    4:添加学生对象到集合中\n    5:遍历集合，采用通用遍历格式实现\n*/\npublic class ArrayListTest02 {\n    public static void main(String[] args) {\n        //创建集合对象\n        ArrayList<Student> array = new ArrayList<>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"风清扬\", 33);\n        Student s3 = new Student(\"张曼玉\", 18);\n        //添加学生对象到集合中\n        array.add(s1);\n        array.add(s2);\n        array.add(s3);\n        //遍历集合，采用通用遍历格式实现\n        for (int i = 0; i < array.size(); i++) {\n            Student s = array.get(i);\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n>3、存储学生对象并遍历升级版\n\n创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合，学生的姓名和年龄来自于键盘录入\n\n```java\n/*\n    思路：\n    1:定义学生类，为了键盘录入数据方便，把学生类中的成员变量都定义为String类型\n    2:创建集合对象\n    3:键盘录入学生对象所需要的数据\n    4:创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\n    5:往集合中添加学生对象\n    6:遍历集合，采用通用遍历格式实现\n*/\npublic class ArrayListTest {\n    public static void main(String[] args) {\n        //创建集合对象\n        ArrayList<Student> array = new ArrayList<Student>();\n        //为了提高代码的复用性，我们用方法来改进程序\n        addStudent(array);\n        addStudent(array);\n        addStudent(array);\n        //遍历集合，采用通用遍历格式实现\n        for (int i = 0; i < array.size(); i++) {\n            Student s = array.get(i);\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n    /*\n    两个明确：\n    返回值类型：void\n    参数：ArrayList<Student> array\n    */\n    public static void addStudent(ArrayList<Student> array) {\n        //键盘录入学生对象所需要的数据\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入学生姓名:\");\n        String name = sc.nextLine();\n        System.out.println(\"请输入学生年龄:\");\n        String age = sc.nextLine();\n        //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\n        Student s = new Student();\n        s.setName(name);\n        s.setAge(age);\n        //往集合中添加学生对象\n        array.add(s);\n    }\n}\n```\n\n> 4、ArrayList集合存储学生对象三种方式遍历\n\n创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class ArrayListDemo {\n    public static void main(String[] args) {\n        //创建ArrayList集合对象\n        ArrayList<Student> array = new ArrayList<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"张曼玉\", 35);\n        Student s3 = new Student(\"王祖贤\", 33);\n        //把学生添加到集合\n        array.add(s1);\n        array.add(s2);\n        array.add(s3);\n        \n        //迭代器：集合特有的遍历方式\n        Iterator<Student> it = array.iterator();\n        while (it.hasNext()) {\n            Student s = it.next();\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n        System.out.println(\"--------\");\n        \n        //普通for：带有索引的遍历方式\n        for(int i=0; i<array.size(); i++) {\n            Student s = array.get(i);\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n        System.out.println(\"--------\");\n        \n        //增强for：最方便的遍历方式\n        for(Student s : array) {\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n\n\n\n\n## 6.4 LinkedList集合\n\n* LinkedList集合\n\n  底层是**链表结构**实现，**查询慢，增删快**\n\n* 成员方法\n\n| 方法名                    | 说明                             |\n| ------------------------- | -------------------------------- |\n| public void addFirst(E e) | 在该列表开头插入指定的元素       |\n| public void addLast(E e)  | 将指定的元素追加到此列表的末尾   |\n| public E getFirst()       | 返回此列表中的第一个元素         |\n| public E getLast()        | 返回此列表中的最后一个元素       |\n| public E removeFirst()    | 从此列表中删除并返回第一个元素   |\n| public E removeLast()     | 从此列表中删除并返回最后一个元素 |\n\n\n\n## 6.5 Set集合\n\n>概述和特点\n\n* Set集合的特点 \n  * 元素存取无序 \n  * 没有索引、只能通过**迭代器**或**增强for循环**遍历 \n  * 不能存储重复元素\n\n```java\npublic class SetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        Set<String> set = new HashSet<String>();\n        //添加元素\n        set.add(\"hello\");\n        set.add(\"world\");\n        set.add(\"java\");\n        //不包含重复元素的集合\n        set.add(\"world\");\n        //遍历\n        for(String s : set) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n> 哈希值\n\n* 哈希值简介 \n\n  是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 \n\n* 如何获取哈希值 \n\n  Object类中的public int hashCode()：返回对象的哈希码值 \n\n* 哈希值的特点 \n\n  * 同一个对象多次调用hashCode()方法返回的哈希值是相同的 \n  * 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    @Override\n    public int hashCode() {\n        return 0;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class HashDemo {\n    public static void main(String[] args) {\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\",30);\n        //同一个对象多次调用hashCode()方法返回的哈希值是相同的\n        System.out.println(s1.hashCode()); //1060830840\n        System.out.println(s1.hashCode()); //1060830840\n        System.out.println(\"--------\");\n        Student s2 = new Student(\"林青霞\",30);\n        //默认情况下，不同对象的哈希值是不相同的\n        //通过方法重写，可以实现不同对象的哈希值是相同的\n        System.out.println(s2.hashCode()); //2137211482\n        System.out.println(\"--------\");\n        System.out.println(\"hello\".hashCode()); //99162322\n        System.out.println(\"world\".hashCode()); //113318802\n        System.out.println(\"java\".hashCode()); //3254818\n        System.out.println(\"world\".hashCode()); //113318802\n        System.out.println(\"--------\");\n        System.out.println(\"重地\".hashCode()); //1179395\n        System.out.println(\"通话\".hashCode()); //1179395\n    }\n}  \n```\n\n\n\n## 6.6 HashSet集合\n\n* HashSet集合的特点 \n  * 底层数据结构是哈希表 \n  * 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致 \n  * 没有带索引的方法，所以不能使用普通for循环遍历 \n  * 由于是Set集合，所以是不包含重复元素的集合\n\n```java\npublic class HashSetDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        HashSet<String> hs = new HashSet<String>();\n        //添加元素\n        hs.add(\"hello\");\n        hs.add(\"world\");\n        hs.add(\"java\");\n        hs.add(\"world\");\n        //遍历\n        for(String s : hs) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n* 哈希表\n\n![image-20230130114750179](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230130114750179.png)\n\n>1、集合存储学生对象并遍历\n\n* 案例需求 \n  * 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 \n  * 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Student student = (Student) o;\n        if (age != student.age) return false;\n        return name != null ? name.equals(student.name) : student.name ==\n            null;\n    }\n    @Override\n    public int hashCode() {\n        int result = name != null ? name.hashCode() : 0;\n        result = 31 * result + age;\n        return result;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class HashSetDemo02 {\n    public static void main(String[] args) {\n        //创建HashSet集合对象\n        HashSet<Student> hs = new HashSet<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"张曼玉\", 35);\n        Student s3 = new Student(\"王祖贤\", 33);\n        Student s4 = new Student(\"王祖贤\", 33);\n        //把学生添加到集合\n        hs.add(s1);\n        hs.add(s2);\n        hs.add(s3);\n        hs.add(s4);\n        \n        //遍历集合(增强for)\n        for (Student s : hs) {\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n\n\n> 2、LinkedHashSet集合概述和特点\n\n* LinkedHashSet集合特点 \n  * 哈希表和链表实现的Set接口，具有可预测的迭代次序 \n  * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的 \n  * 由哈希表保证元素唯一，也就是说没有重复的元素\n\n```java\npublic class LinkedHashSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<String>();\n        //添加元素\n        linkedHashSet.add(\"hello\");\n        linkedHashSet.add(\"world\");\n        linkedHashSet.add(\"java\");\n        linkedHashSet.add(\"world\");\n        //遍历集合\n        for(String s : linkedHashSet) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n\n\n## 6.7 TreeSet集合\n\n* TreeSet集合概述 \n  * 元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法 \n    * TreeSet()：根据其元素的自然排序进行排序 \n    * TreeSet(Comparator comparator) ：根据指定的比较器进行排序 \n  * 没有带索引的方法，所以不能使用普通for循环遍历 \n  * 由于是Set集合，所以不包含重复元素的集合\n\n```java\npublic class TreeSetDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Integer> ts = new TreeSet<Integer>();\n        //添加元素\n        ts.add(10);\n        ts.add(40);\n        ts.add(30);\n        ts.add(50);\n        ts.add(20);\n        ts.add(30);\n        //遍历集合\n        for(Integer i : ts) {\n            System.out.println(i);\n        }//10 20 30 40 50\n    }\n}\n```\n\n> 1、自然排序Comparable的使用\n\n* 案例需求 \n  * 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 \n  * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 \n* 实现步骤 \n  * 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 \n  * 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 \n  * 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n* 学校类\n\n```java\npublic class Student implements Comparable<Student> {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    @Override\n    public int compareTo(Student s) {\n        // return 0;\n        // return 1;\n        // return -1;\n        //按照年龄从小到大排序\n        int num = this.age - s.age;\n        // int num = s.age - this.age;\n        //年龄相同时，按照姓名的字母顺序排序\n        int num2 = num==0?this.name.compareTo(s.name):num;\n        return num2;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class TreeSetDemo02 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Student> ts = new TreeSet<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"xishi\", 29);\n        Student s2 = new Student(\"wangzhaojun\", 28);\n        Student s3 = new Student(\"diaochan\", 30);\n        Student s4 = new Student(\"yangyuhuan\", 33);\n        Student s5 = new Student(\"linqingxia\",33);\n        Student s6 = new Student(\"linqingxia\",33);\n        //把学生添加到集合\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n        //遍历集合\n        for (Student s : ts) {\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n> 2、比较器排序Comparator的使用\n\n* 案例需求 \n  * 存储学生对象并遍历，创建TreeSet集合使用带参构造方法 \n  * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 \n* 实现步骤 \n  * 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 \n  * 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 \n  * 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class TreeSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\n            @Override\n            public int compare(Student s1, Student s2) {\n            //this.age - s.age\n            //s1,s2\n            int num = s1.getAge() - s2.getAge();\n            int num2 = num == 0 ? s1.getName().compareTo(s2.getName())\n            : num;\n            return num2;\n          	}\n        });\n        \n        //创建学生对象\n        Student s1 = new Student(\"xishi\", 29);\n        Student s2 = new Student(\"wangzhaojun\", 28);\n        Student s3 = new Student(\"diaochan\", 30);\n        Student s4 = new Student(\"yangyuhuan\", 33);\n        Student s5 = new Student(\"linqingxia\",33);\n        Student s6 = new Student(\"linqingxia\",33);\n        //把学生添加到集合\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n        //遍历集合\n        for (Student s : ts) {\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n> 3、成绩排序案例\n\n* 案例需求 \n  * 用TreeSet集合存储多个学生信息(姓名，语文成绩，数学成绩)，并遍历该集合 \n  * 要求：按照总分从高到低出现\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int chinese;\n    private int math;\n    public Student() {\n    }\n    public Student(String name, int chinese, int math) {\n        this.name = name;\n        this.chinese = chinese;\n        this.math = math;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getChinese() {\n        return chinese;\n    }\n    public void setChinese(int chinese) {\n        this.chinese = chinese;\n    }\n    public int getMath() {\n        return math;\n    }\n    public void setMath(int math) {\n        this.math = math;\n    }\n    public int getSum() {\n        return this.chinese + this.math;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class TreeSetDemo {\n    public static void main(String[] args) {\n        //创建TreeSet集合对象，通过比较器排序进行排序\n        TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\n            @Override\n            public int compare(Student s1, Student s2) {\n            // int num = (s2.getChinese()+s2.getMath())-\n            (s1.getChinese()+s1.getMath());\n            //主要条件\n            int num = s2.getSum() - s1.getSum();\n            //次要条件\n            int num2 = num == 0 ? s1.getChinese() - s2.getChinese() :\n            num;\n            int num3 = num2 == 0 ? s1.getName().compareTo(s2.getName())\n            : num2;\n            return num3;\n            }\n        });\n        \n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 98, 100);\n        Student s2 = new Student(\"张曼玉\", 95, 95);\n        Student s3 = new Student(\"王祖贤\", 100, 93);\n        Student s4 = new Student(\"柳岩\", 100, 97);\n        Student s5 = new Student(\"风清扬\", 98, 98);\n        Student s6 = new Student(\"左冷禅\", 97, 99);\n        // Student s7 = new Student(\"左冷禅\", 97, 99);\n        Student s7 = new Student(\"赵云\", 97, 99);\n        //把学生对象添加到集合\n        ts.add(s1);\n        ts.add(s2);\n        ts.add(s3);\n        ts.add(s4);\n        ts.add(s5);\n        ts.add(s6);\n        ts.add(s7);\n        //遍历集合\n        for (Student s : ts) {\n            System.out.println(s.getName() + \",\" + s.getChinese() + \",\" +\n                               s.getMath() + \",\" + s.getSum());\n        }\n    }\n}\n```\n\n> 4、不重复的随机数案例\n\n* 案例需求 \n  * 编写一个程序，获取10个1-20之间的随机数，要求随机数不能重复，并在控制台输出\n\n```java\npublic class SetDemo {\n    public static void main(String[] args) {\n        //创建Set集合对象\n        // Set<Integer> set = new HashSet<Integer>();\n        Set<Integer> set = new TreeSet<Integer>();\n        //创建随机数对象\n        Random r = new Random();\n        //判断集合的长度是不是小于10\n        while (set.size()<10) {\n            //产生一个随机数，添加到集合\n            int number = r.nextInt(20) + 1;\n            set.add(number);\n        }\n        //遍历集合\n        for(Integer i : set) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n\n\n## 6.8 Map集合\n\n* Map集合概述\n\n```java\ninterface Map<K,V> //K：键的类型；V：值的类型\n```\n\n* Map集合的特点 \n  * 键值对映射关系 \n  * 一个键对应一个值 \n  * 键不能重复，值可以重复 \n  * 元素存取无序\n\n* Map集合的基本使用\n\n```java\npublic class MapDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String,String> map = new HashMap<String,String>();\n        //V put(K key, V value) 将指定的值与该映射中的指定键相关联\n        map.put(\"itheima001\",\"林青霞\");\n        map.put(\"itheima002\",\"张曼玉\");\n        map.put(\"itheima003\",\"王祖贤\");\n        map.put(\"itheima003\",\"柳岩\");\n        //输出集合对象\n        System.out.println(map);\n    }\n}\n```\n\n> 1、基本方法介绍\n\n| 方法名                              | 说明                                 |\n| ----------------------------------- | ------------------------------------ |\n| V put(K key,V value)                | 添加元素                             |\n| V remove(Object key)                | 根据键删除键值对元素                 |\n| void clear()                        | 移除所有的键值对元素                 |\n| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |\n| boolean containsValue(Object value) | 判断集合是否包含指定的值             |\n| boolean isEmpty()                   | 判断集合是否为空                     |\n| int size()                          | 集合的长度，也就是集合中键值对的个数 |\n\n* 示例代码\n\n```java\npublic class MapDemo02 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String,String> map = new HashMap<String,String>();\n        //V put(K key,V value)：添加元素\n        map.put(\"张无忌\",\"赵敏\");\n        map.put(\"郭靖\",\"黄蓉\");\n        map.put(\"杨过\",\"小龙女\");\n        \n        //V remove(Object key)：根据键删除键值对元素\n        // System.out.println(map.remove(\"郭靖\"));\n        // System.out.println(map.remove(\"郭襄\"));\n        \n        //void clear()：移除所有的键值对元素\n        // map.clear();\n        \n        //boolean containsKey(Object key)：判断集合是否包含指定的键\n        // System.out.println(map.containsKey(\"郭靖\"));\n        // System.out.println(map.containsKey(\"郭襄\"));\n        \n        //boolean isEmpty()：判断集合是否为空\n        // System.out.println(map.isEmpty());\n        \n        //int size()：集合的长度，也就是集合中键值对的个数\n        System.out.println(map.size());\n        \n        //输出集合对象\n        System.out.println(map);\n    }\n}\n```\n\n> 2、集合的获取功能\n\n| 方法名              | 说明                     |\n| ------------------- | ------------------------ |\n| V get(Object key)   | 根据键获取值             |\n| Set keySet()        | 获取所有键的集合         |\n| Collection values() | 获取所有值的集合         |\n| Set> entrySet()     | 获取所有键值对对象的集合 |\n\n* 示例代码\n\n```java\npublic class MapDemo03 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String, String> map = new HashMap<String, String>();\n        //添加元素\n        map.put(\"张无忌\", \"赵敏\");\n        map.put(\"郭靖\", \"黄蓉\");\n        map.put(\"杨过\", \"小龙女\");\n        \n        //V get(Object key):根据键获取值\n        // System.out.println(map.get(\"张无忌\"));\n        // System.out.println(map.get(\"张三丰\"));\n        \n        //Set<K> keySet():获取所有键的集合\n        // Set<String> keySet = map.keySet();\n        // for(String key : keySet) {\n        // System.out.println(key);\n        // }\n        \n        //Collection<V> values():获取所有值的集合\n        Collection<String> values = map.values();\n        for(String value : values) {\n            System.out.println(value);\n        }\n    }\n}\n```\n\n\n\n> 3、Map集合的遍历(方式1)\n\n* 遍历思路 \n  * 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 \n    * 把所有的丈夫给集中起来 \n    * 遍历丈夫的集合，获取到每一个丈夫 \n    * 根据丈夫去找对应的妻子\n\n* 步骤分析 \n  * 获取所有键的集合。用keySet()方法实现\n  * 遍历键的集合，获取到每一个键。用增强for实现 \n  * 根据键去找值，用get(Object key)方法实现\n\n```java\npublic class MapDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String, String> map = new HashMap<String, String>();\n        //添加元素\n        map.put(\"张无忌\", \"赵敏\");\n        map.put(\"郭靖\", \"黄蓉\");\n        map.put(\"杨过\", \"小龙女\");\n        //获取所有键的集合。用keySet()方法实现\n        Set<String> keySet = map.keySet();\n        //遍历键的集合，获取到每一个键。用增强for实现\n        for (String key : keySet) {\n            //根据键去找值。用get(Object key)方法实现\n            String value = map.get(key);\n            System.out.println(key + \",\" + value);\n        }\n    }\n}\n```\n\n> 4、Map集合的遍历(方式2)\n\n* 遍历思路 \n  * 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 \n    * 获取所有结婚证的集合 \n    * 遍历结婚证的集合，得到每一个结婚证 \n    * 根据结婚证获取丈夫和妻子 \n* 步骤分析 \n  * 获取所有键值对对象的集合 \n    * Set<Map,Entry<K,V>> entrySet()：获取所有键值对对象的集合 \n  * 遍历键值对对象的集合，得到每一个键值对对象 \n    * 用增强for实现，得到每一个Map.Entry \n  * 根据键值对对象获取键和值 \n    * 用getKey()得到键 \n    * 用getValue()得到值\n\n```java\npublic class MapDemo02 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String, String> map = new HashMap<String, String>();\n        //添加元素\n        map.put(\"张无忌\", \"赵敏\");\n        map.put(\"郭靖\", \"黄蓉\");\n        map.put(\"杨过\", \"小龙女\");\n        //获取所有键值对对象的集合\n        Set<Map.Entry<String, String>> entrySet = map.entrySet();\n        //遍历键值对对象的集合，得到每一个键值对对象\n        for (Map.Entry<String, String> me : entrySet) {\n            //根据键值对对象获取键和值\n            String key = me.getKey();\n            String value = me.getValue();\n            System.out.println(key + \",\" + value);\n        }                                                                 \n    }\n}\n```\n\n\n\n## 6.9 HashMap集合\n\n> 1、HashMap集合练习之键是String值是Student\n\n创建一个HashMap集合，键是学号(String)，值是学生对象(Student)。存储三个键值对元素，并遍历\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n* 测试类\n\n```java\n/*\n    需求：\n    创建一个HashMap集合，键是学号(String)，值是学生对象(Student)。存储三个键值对\n    元素，并遍历\n    思路：\n    1:定义学生类\n    2:创建HashMap集合对象\n    3:创建学生对象\n    4:把学生添加到集合\n    5:遍历集合\n    方式1：键找值\n    方式2：键值对对象找键和值\n*/\npublic class HashMapDemo {\n    public static void main(String[] args) {\n        //创建HashMap集合对象\n        HashMap<String, Student> hm = new HashMap<String, Student>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"张曼玉\", 35);\n        Student s3 = new Student(\"王祖贤\", 33);\n        //把学生添加到集合\n        hm.put(\"itheima001\", s1);\n        hm.put(\"itheima002\", s2);\n        hm.put(\"itheima003\", s3);\n        \n        //方式1：键找值\n        Set<String> keySet = hm.keySet();\n        for (String key : keySet) {\n            Student value = hm.get(key);\n            System.out.println(key + \",\" + value.getName() + \",\" +\n                               value.getAge());\n        }\n        System.out.println(\"--------\");\n        \n        //方式2：键值对对象找键和值\n        Set<Map.Entry<String, Student>> entrySet = hm.entrySet();\n        for (Map.Entry<String, Student> me : entrySet) {\n            String key = me.getKey();\n            Student value = me.getValue();\n            System.out.println(key + \",\" + value.getName() + \",\" +\n                               value.getAge());\n        }\n    }\n}\n```\n\n\n\n> 2、HashMap集合练习之键是Student值是String\n\n* 案例需求 \n  * 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 \n  * 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Student student = (Student) o;\n        if (age != student.age) return false;\n        return name != null ? name.equals(student.name) : student.name ==\n            null;\n    }\n    \n    @Override\n    public int hashCode() {\n        int result = name != null ? name.hashCode() : 0;\n        result = 31 * result + age;\n        return result;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class HashMapDemo {\n    public static void main(String[] args) {\n        //创建HashMap集合对象\n        HashMap<Student, String> hm = new HashMap<Student, String>();\n        //创建学生对象\n        Student s1 = new Student(\"林青霞\", 30);\n        Student s2 = new Student(\"张曼玉\", 35);\n        Student s3 = new Student(\"王祖贤\", 33);\n        Student s4 = new Student(\"王祖贤\", 33);\n        //把学生添加到集合\n        hm.put(s1, \"西安\");\n        hm.put(s2, \"武汉\");\n        hm.put(s3, \"郑州\");\n        hm.put(s4, \"北京\");\n        //遍历集合\n        Set<Student> keySet = hm.keySet();\n        for (Student key : keySet) {\n            String value = hm.get(key);\n            System.out.println(key.getName() + \",\" + key.getAge() + \",\" +\n                               value);\n        }\n    }\n}\n```\n\n\n\n> 3、集合嵌套之ArrayList嵌套HashMap\n\n* 案例需求 \n  * 创建一个ArrayList集合，存储三个元素，每一个元素都是HashMap \n  * 每一个HashMap的键和值都是String，并遍历。\n\n```java\npublic class ArrayListIncludeHashMapDemo {\n    public static void main(String[] args) {\n        //创建ArrayList集合\n        ArrayList<HashMap<String, String>> array = new\n            ArrayList<HashMap<String, String>>();\n        //创建HashMap集合，并添加键值对元素\n        HashMap<String, String> hm1 = new HashMap<String, String>();\n        hm1.put(\"孙策\", \"大乔\");\n        hm1.put(\"周瑜\", \"小乔\");\n        //把HashMap作为元素添加到ArrayList集合\n        array.add(hm1);\n        HashMap<String, String> hm2 = new HashMap<String, String>();\n        hm2.put(\"郭靖\", \"黄蓉\");\n        hm2.put(\"杨过\", \"小龙女\");\n        //把HashMap作为元素添加到ArrayList集合\n        array.add(hm2);\n        HashMap<String, String> hm3 = new HashMap<String, String>();\n        hm3.put(\"令狐冲\", \"任盈盈\");\n        hm3.put(\"林平之\", \"岳灵珊\");\n        //把HashMap作为元素添加到ArrayList集合\n        array.add(hm3);\n        //遍历ArrayList集合\n        for (HashMap<String, String> hm : array) {\n            Set<String> keySet = hm.keySet();\n            for (String key : keySet) {\n                String value = hm.get(key);\n                System.out.println(key + \",\" + value);\n            }\n        }\n    }\n}  \n```\n\n\n\n> 4、集合嵌套之HashMap嵌套ArrayList\n\n* 案例需求 \n  * 创建一个HashMap集合，存储三个键值对元素，每一个键值对元素的键是String，值是ArrayList \n  * 每一个ArrayList的元素是String，并遍历。\n\n```java\npublic class HashMapIncludeArrayListDemo {\n    public static void main(String[] args) {\n        //创建HashMap集合\n        HashMap<String, ArrayList<String>> hm = new HashMap<String,\n        ArrayList<String>>();\n        //创建ArrayList集合，并添加元素\n        ArrayList<String> sgyy = new ArrayList<String>();\n        sgyy.add(\"诸葛亮\");\n        sgyy.add(\"赵云\");\n        //把ArrayList作为元素添加到HashMap集合\n        hm.put(\"三国演义\",sgyy);\n        ArrayList<String> xyj = new ArrayList<String>();\n        xyj.add(\"唐僧\");\n        xyj.add(\"孙悟空\");\n        //把ArrayList作为元素添加到HashMap集合\n        hm.put(\"西游记\",xyj);\n        ArrayList<String> shz = new ArrayList<String>();\n        shz.add(\"武松\");\n        shz.add(\"鲁智深\");\n        //把ArrayList作为元素添加到HashMap集合\n        hm.put(\"水浒传\",shz);\n        //遍历HashMap集合\n        Set<String> keySet = hm.keySet();\n        for(String key : keySet) {\n            System.out.println(key);\n            ArrayList<String> value = hm.get(key);\n            for(String s : value) {\n                System.out.println(\"\\t\" + s);\n            }\n        }\n    }\n}\n```\n\n\n\n> 5、统计字符串中每个字符出现的次数\n\n* 案例需求 \n  * 键盘录入一个字符串，要求统计字符串中每个字符串出现的次数。 \n  * 举例：键盘录入“aababcabcdabcde” 在控制台输出：“a(5)b(4)c(3)d(2)e(1)”\n\n```java\npublic class HashMapDemo {\n    public static void main(String[] args) {\n        //键盘录入一个字符串\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个字符串：\");\n        String line = sc.nextLine();\n        //创建HashMap集合，键是Character，值是Integer\n        // HashMap<Character, Integer> hm = new HashMap<Character, Integer>();\n        TreeMap<Character, Integer> hm = new TreeMap<Character, Integer>();\n        //遍历字符串，得到每一个字符\n        for (int i = 0; i < line.length(); i++) {\n            char key = line.charAt(i);\n            //拿得到的每一个字符作为键到HashMap集合中去找对应的值，看其返回值\n            Integer value = hm.get(key);\n            if (value == null) {\n                //如果返回值是null：说明该字符在HashMap集合中不存在，就把该字符作为键，1作为值存储\n                hm.put(key,1);\n            } else {\n                //如果返回值不是null：说明该字符在HashMap集合中存在，把该值加1，然后重新存储该字符和对应的值\n                value++;\n                hm.put(key,value);\n            }\n        }\n        //遍历HashMap集合，得到键和值，按照要求进行拼接\n        StringBuilder sb = new StringBuilder();\n        Set<Character> keySet = hm.keySet();\n        for(Character key : keySet) {\n            Integer value = hm.get(key);\n            sb.append(key).append(\"(\").append(value).append(\")\");\n        }\n        String result = sb.toString();\n        //输出结果\n        System.out.println(result);\n    }\n} \n```\n\n\n\n## 6.10 Collections集合工具类\n\n> 1、Collections概述和使用\n\n* Collections类的作用 \n\n  是针对集合操作的工具类\n\n* Collections类常用方法\n\n| 方法名                                | 说明                               |\n| ------------------------------------- | ---------------------------------- |\n| public static void sort(List list)    | 将指定的列表按升序排序             |\n| public static void reverse(List list) | 反转指定列表中元素的顺序           |\n| public static void shuffle(List list) | 使用默认的随机源随机排列指定的列表 |\n\n```java\npublic class CollectionsDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        List<Integer> list = new ArrayList<Integer>();\n        //添加元素\n        list.add(30);\n        list.add(20);\n        list.add(50);\n        list.add(10);\n        list.add(40);\n        //public static <T extends Comparable<? super T>> void sort•(List<T> list)：将指定的列表按升序排序\n        Collections.sort(list);\n        \n        //public static void reverse•(List<?> list)：反转指定列表中元素的顺序\n        Collections.reverse(list);\n        \n        //public static void shuffle•(List<?> list)：使用默认的随机源随机排列指定的列表\n        Collections.shuffle(list);\n        System.out.println(list);\n    }\n}\n```\n\n\n\n> 2、ArrayList集合存储学生并排序\n\n* 案例需求\n  * ArrayList存储学生对象，使用Collections对ArrayList进行排序 \n  * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n* 学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class CollectionsDemo02 {\n    public static void main(String[] args) {\n        //创建ArrayList集合对象\n        ArrayList<Student> array = new ArrayList<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"linqingxia\", 30);\n        Student s2 = new Student(\"zhangmanyu\", 35);\n        Student s3 = new Student(\"wangzuxian\", 33);\n        Student s4 = new Student(\"liuyan\", 33);\n        //把学生添加到集合\n        array.add(s1);\n        array.add(s2);\n        array.add(s3);\n        array.add(s4);\n        //使用Collections对ArrayList集合排序\n        //sort•(List<T> list, Comparator<? super T> c)\n        Collections.sort(array, new Comparator<Student>() {\n            @Override\n            public int compare(Student s1, Student s2) {\n                //按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n                int num = s1.getAge() - s2.getAge();\n                int num2 = num == 0 ? s1.getName().compareTo(s2.getName())\n                    : num;\n                return num2;\n            }\n        });\n        //遍历集合\n        for (Student s : array) {\n            System.out.println(s.getName() + \",\" + s.getAge());\n        }\n    }\n}\n```\n\n\n\n# 7. IO流\n\n> 概述\n\nIO流分为“字节流”和“字符流”两种形式\n\n* 字节流\n\n![image-20230131134136890](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131134136890.png)\n\n\n\n* 字符流\n\n![image-20230131134154792](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131134154792.png)\n\n\n\n* IO流介绍 \n  * IO：输入/输出(Input/Output) \n  * 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输 \n  * IO流就是用来处理设备间数据传输问题的。常见的应用：文件复制；文件上传；文件下载 \n* IO流的分类 \n  * 按照数据的流向 \n    * 输入流：读数据 \n    * 输出流：写数据 \n  * 按照数据类型来分 \n    * 字节流 \n      * 字节输入流 \n      * 字节输出流 \n    * 字符流 \n      * 字符输入流 \n      * 字符输出流 \n* IO流的使用场景 \n  * 如果操作的是**纯文本文件**，优先使用**字符流** \n  * 如果操作的是**图片、视频、音频等二进制文件**。优先使用**字节流** \n  * 如果不确定**文件类型，优先使用字节流**。字节流是万能的流\n\n\n\n## 7.1 File类\n\n* File类介绍\n  * 它是文件和目录路径名的抽象表示 \n  * 文件和目录是可以通过File封装成对象的 \n  * 对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的\n\n* File类的构造方法\n\n| 方法名                            | 说明                                                        |\n| --------------------------------- | ----------------------------------------------------------- |\n| File(String pathname)             | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 |\n| File(String parent, String child) | 从父路径名字符串和子路径名字符串创建新的 File实例           |\n| File(File parent, String child)   | 从父抽象路径名和子路径名字符串创建新的 File实例             |\n\n```java\npublic class FileDemo01 {\n    public static void main(String[] args) {\n        //File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n        File f1 = new File(\"E:\\\\itcast\\\\java.txt\");\n        System.out.println(f1);\n        \n        //File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的File实例。\n        File f2 = new File(\"E:\\\\itcast\",\"java.txt\");\n        System.out.println(f2);\n        \n        //File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。\n        File f3 = new File(\"E:\\\\itcast\");\n        File f4 = new File(f3,\"java.txt\");\n        System.out.println(f4);\n    }\n}\n```\n\n\n\n> 1、File类的创建功能\n\n| 方法名                         | 说明                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空**文件** |\n| public boolean mkdir()         | 创建由此抽象路径名命名的**目录**                             |\n| public boolean mkdirs()        | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录**（多级目录）** |\n\n```java\npublic class FileDemo02 {\n    public static void main(String[] args) throws IOException {\n        //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt\n        File f1 = new File(\"E:\\\\itcast\\\\java.txt\");\n        System.out.println(f1.createNewFile());\n        System.out.println(\"--------\");\n        \n        //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE\n        File f2 = new File(\"E:\\\\itcast\\\\JavaSE\");\n        System.out.println(f2.mkdir());\n        System.out.println(\"--------\");\n        \n        //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML\n        File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\");\n        // System.out.println(f3.mkdir());\n        System.out.println(f3.mkdirs());\n        System.out.println(\"--------\");\n        \n        //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt\n        File f4 = new File(\"E:\\\\itcast\\\\javase.txt\");\n        // System.out.println(f4.mkdir());\n        System.out.println(f4.createNewFile());\n    }\n}\n```\n\n\n\n> 2、File类的判断和获取功能\n\n* 判断功能\n\n| 方法名                       | 说明                                 |\n| ---------------------------- | ------------------------------------ |\n| public boolean isDirectory() | 测试此抽象路径名表示的File是否为目录 |\n| public boolean isFile()      | 测试此抽象路径名表示的File是否为文件 |\n| public boolean exists()      | 测试此抽象路径名表示的File是否存在   |\n\n* 获取功能\n\n| 方法名                          | 说明                                                     |\n| ------------------------------- | -------------------------------------------------------- |\n| public String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串                       |\n| public String getPath()         | 将此抽象路径名转换为路径名字符串                         |\n| public String getName()         | 返回由此抽象路径名表示的文件或目录的名称                 |\n| public String[] list()          | 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组 |\n| public File[] listFiles()       | 返回此抽象路径名表示的目录中的文件和目录的File对象数组   |\n\n```java\npublic class FileDemo04 {\n    public static void main(String[] args) {\n        //创建一个File对象\n        File f = new File(\"myFile\\\\java.txt\");\n        // public boolean isDirectory()：测试此抽象路径名表示的File是否为目录\n        // public boolean isFile()：测试此抽象路径名表示的File是否为文件\n        // public boolean exists()：测试此抽象路径名表示的File是否存在\n        System.out.println(f.isDirectory());\n        System.out.println(f.isFile());\n        System.out.println(f.exists());\n        \n        // public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串\n        // public String getPath()：将此抽象路径名转换为路径名字符串\n        // public String getName()：返回由此抽象路径名表示的文件或目录的名称\n        System.out.println(f.getAbsolutePath());\n        System.out.println(f.getPath());\n        System.out.println(f.getName());\n        System.out.println(\"--------\");\n        \n        // public String[] list()：返回此抽象路径名表示的目录中的文件和目录的名称字符串数组\n        // public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组\n        File f2 = new File(\"E:\\\\itcast\");\n        String[] strArray = f2.list();\n        for(String str : strArray) {\n            System.out.println(str);\n        }\n        System.out.println(\"--------\");\n        \n        File[] fileArray = f2.listFiles();\n        for(File file : fileArray) {\n            // System.out.println(file);\n            // System.out.println(file.getName());\n            if(file.isFile()) {\n                System.out.println(file.getName());\n            }\n        }\n    }\n}\n```\n\n\n\n> 3、File类删除功能\n\n* 方法分类\n\n| 方法名                  | 说明                               |\n| ----------------------- | ---------------------------------- |\n| public boolean delete() | 删除由此抽象路径名表示的文件或目录 |\n\n```java\npublic class FileDemo03 {\n    public static void main(String[] args) throws IOException {\n        // File f1 = new File(\"E:\\\\itcast\\\\java.txt\");\n        //需求1：在当前模块目录下创建java.txt文件\n        File f1 = new File(\"myFile\\\\java.txt\");\n        // System.out.println(f1.createNewFile());\n        \n        //需求2：删除当前模块目录下的java.txt文件\n        System.out.println(f1.delete());\n        System.out.println(\"--------\");\n        \n        //需求3：在当前模块目录下创建itcast目录\n        File f2 = new File(\"myFile\\\\itcast\");\n        // System.out.println(f2.mkdir());\n        \n        //需求4：删除当前模块目录下的itcast目录\n        System.out.println(f2.delete());\n        System.out.println(\"--------\");\n        \n        //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt\n        File f3 = new File(\"myFile\\\\itcast\");\n        // System.out.println(f3.mkdir());\n        File f4 = new File(\"myFile\\\\itcast\\\\java.txt\");\n        // System.out.println(f4.createNewFile());\n        \n        //需求6：删除当前模块下的目录itcast\n        System.out.println(f4.delete());\n        System.out.println(f3.delete());\n    }\n}\n```\n\n* 绝对路径和相对路径的区别 \n  * 绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\\itcast\\java.txt \n  * 相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\\java.txt\n\n\n\n> 4、递归遍历目录\n\n* 案例需求 \n\n  给定一个路径(E:\\itcast)，通过递归完成遍历该目录下所有内容，并把所有文件的绝对路径输出在控制台\n\n```java\npublic class DiGuiDemo02 {\n    public static void main(String[] args) {\n        //根据给定的路径创建一个File对象\n        // File srcFile = new File(\"E:\\\\itcast\");\n        File srcFile = new File(\"E:\\\\itheima\");\n        //调用方法\n        getAllFilePath(srcFile);\n    }\n    //定义一个方法，用于获取给定目录下的所有内容，参数为第1步创建的File对象\n    public static void getAllFilePath(File srcFile) {\n        //获取给定的File目录下所有的文件或者目录的File数组\n        File[] fileArray = srcFile.listFiles();\n        //遍历该File数组，得到每一个File对象\n        if(fileArray != null) {\n            for(File file : fileArray) {\n                //判断该File对象是否是目录\n                if(file.isDirectory()) {\n                    //是：递归调用\n                    getAllFilePath(file);\n                } else {\n                    //不是：获取绝对路径输出在控制台\n                    System.out.println(file.getAbsolutePath());\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n## 7.2 字节流\n\n>概述\n\n字节流抽象基类 \n\n* InputStream：这个抽象类是表示字节输入流的所有类的超类 \n* OutputStream：这个抽象类是表示字节输出流的所有类的超类 \n* 子类名特点：子类名称都是以其父类名作为子类名的后缀 \n\n\n\n### 7.2.1 字节输出流\n\n> 1、字节流写数据\n\n* 字节输出流 \n  * FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 \n* 使用字节输出流写数据的步骤 \n  * **创建**字节输出流**对象**(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件) \n  * **调用**字节输出流对象的写数据**方法** \n  * **释放资源**(关闭此文件输出流并释放与此流相关联的任何系统资源)\n\n```java\npublic class FileOutputStreamDemo01 {\n    public static void main(String[] args) throws IOException {\n        //创建字节输出流对象\n        //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n        FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\");\n        /*\n        做了三件事情：\n        A:调用系统功能创建了文件\n        B:创建了字节输出流对象\n        C:让字节输出流对象指向创建好的文件\n        */\n        \n        //void write(int b)：将指定的字节写入此文件输出流\n        fos.write(97);\n        // fos.write(57);\n        // fos.write(55);\n        //最后都要释放资源\n        //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。\n        fos.close();\n    }\n}\n```\n\n* 字节流写数据的三种方式\n\n| 方法名                                 | 说明                                                         |\n| -------------------------------------- | ------------------------------------------------------------ |\n| void write(int b)                      | 将指定的字节写入此文件输出流 一次写一个字节数据              |\n| void write(byte[] b)                   | 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组 数据 |\n| void write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 |\n\n```java\npublic class FileOutputStreamDemo02 {\n    public static void main(String[] args) throws IOException {\n        //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件\n        FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\");\n        //new File(name)\n        // FileOutputStream fos = new FileOutputStream(new\n        File(\"myByteStream\\\\fos.txt\"));\n        //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件\n        // File file = new File(\"myByteStream\\\\fos.txt\");\n        // FileOutputStream fos2 = new FileOutputStream(file);\n        // FileOutputStream fos2 = new FileOutputStream(new\n        File(\"myByteStream\\\\fos.txt\"));\n        //void write(int b)：将指定的字节写入此文件输出流\n        // fos.write(97);\n        // fos.write(98);\n        // fos.write(99);\n        // fos.write(100);\n        // fos.write(101);\n        // void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流\n        // byte[] bys = {97, 98, 99, 100, 101};\n        //byte[] getBytes()：返回字符串对应的字节数组\n        byte[] bys = \"abcde\".getBytes();\n        // fos.write(bys);\n        //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流\n        // fos.write(bys,0,bys.length);\n        fos.write(bys,1,3);\n        //释放资源\n        fos.close();\n    }\n}\n```\n\n\n\n> 2、字节流写数据的两个小问题\n\n* 字节流写数据如何实现换行 \n  * windows:\\r\\n \n  * linux:\\n \n  * mac:\\r\n\n* 字节流写数据如何实现追加写入 \n  * public FileOutputStream(String name,boolean append) \n  * 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头\n\n```java\npublic class FileOutputStreamDemo03 {\n    public static void main(String[] args) throws IOException {\n        //创建字节输出流对象\n        // FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\");\n        FileOutputStream fos = new\n            FileOutputStream(\"myByteStream\\\\fos.txt\",true);\n        //写数据\n        for (int i = 0; i < 10; i++) {\n            fos.write(\"hello\".getBytes());\n            fos.write(\"\\r\\n\".getBytes());\n        }\n        //释放资源\n        fos.close();\n    }\n}\n```\n\n\n\n> 3、字节流写数据加异常处理\n\n* 异常处理格式 \n\n  * try-catch-finally\n\n    ```java\n    try{\n        可能出现异常的代码;\n    }catch(异常类名 变量名){\n        异常的处理代码;\n    }finally{\n        执行所有清除操作;\n    }\n    ```\n\n  * finally特点 \n\n    * 被finally控制的语句一定会执行，除非JVM退出\n\n```java\npublic class FileOutputStreamDemo04 {\n    public static void main(String[] args) {\n        //加入finally来实现释放资源\n        FileOutputStream fos = null;\n        try {\n            fos = new FileOutputStream(\"myByteStream\\\\fos.txt\");\n            fos.write(\"hello\".getBytes());\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if(fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n### 7.2.2 字节输入流\n\n> 1、字节流读数据(一次读一个字节数据)\n\n* 字节输入流 \n  * FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream ，该文件由文 件系统中的路径名name命名 \n* 字节输入流读取数据的步骤 \n  * 创建字节输入流对象 \n  * 调用字节输入流对象的读数据方法 \n  * 释放资源\n\n```java\npublic class FileInputStreamDemo01 {\n    public static void main(String[] args) throws IOException {\n        //创建字节输入流对象\n        //FileInputStream(String name)\n        FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\");\n        int by;\n        /*\n        fis.read()：读数据\n        by=fis.read()：把读取到的数据赋值给by\n        by != -1：判断读取到的数据是否是-1\n        */\n        while ((by=fis.read())!=-1) {\n            System.out.print((char)by);\n        }\n        //释放资源\n        fis.close();\n    }\n}\n```\n\n\n\n> 2、字节流复制文本文件\n\n* 案例需求 \n\n  把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” \n\n* 实现步骤 \n\n  * 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目 的地) \n  * 数据源： E:\\itcast\\窗里窗外.txt --- 读数据 --- InputStream --- FileInputStream \n  * 目的地： myByteStream\\窗里窗外.txt --- 写数据 --- OutputStream --- FileOutputStream\n\n```java\npublic class CopyTxtDemo {\n	public static void main(String[] args) throws IOException {\n        //根据数据源创建字节输入流对象\n        FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\");\n        //根据目的地创建字节输出流对象\n        FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\");\n        //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)\n        int by;\n        while ((by=fis.read())!=-1) {\n        fos.write(by);\n\n        //释放资源\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n\n\n> 3、字节流读数据(一次读一个字节数组数据)\n\n* 一次读一个字节数组的方法 \n  * public int read(byte[] b)：从输入流读取最多b.length个字节的数据 \n  * 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数\n\n```java\npublic class FileInputStreamDemo02 {\n    public static void main(String[] args) throws IOException {\n        //创建字节输入流对象\n        FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\");\n        /*\n        hello\\r\\n\n        world\\r\\n\n        第一次：hello\n        第二次：\\r\\nwor\n        第三次：ld\\r\\nr\n        */\n        byte[] bys = new byte[1024]; //1024及其整数倍\n        int len;\n        while ((len=fis.read(bys))!=-1) {\n            System.out.print(new String(bys,0,len));\n        }\n        //释放资源\n        fis.close();\n    }\n}\n```\n\n\n\n> 4、字节流复制文本文件\n\n* 案例需求 \n\n  把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” \n\n* 实现步骤 \n\n  * 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) \n\n  * 数据源： \n\n    E:\\itcast\\窗里窗外.txt --- 读数据 --- InputStream --- FileInputStream \n\n  * 目的地： \n\n    myByteStream\\窗里窗外.txt --- 写数据 --- OutputStream --- FileOutputStream\n\n```java\npublic class CopyTxtDemo {\n    public static void main(String[] args) throws IOException {\n        //根据数据源创建字节输入流对象\n        FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\");\n        //根据目的地创建字节输出流对象\n        FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\");\n        //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节)\n        int by;\n        while ((by=fis.read())!=-1) {\n            fos.write(by);\n        }\n        //释放资源\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n\n\n> 5、字节流读数据(一次读一个字节数组数据)\n\n* 一次读一个字节数组的方法 \n  * public int read(byte[] b)：从输入流读取最多b.length个字节的数据 \n  * 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数\n\n```java\npublic class FileInputStreamDemo02 {\n    public static void main(String[] args) throws IOException {\n        //创建字节输入流对象\n        FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\");\n        /*\n        hello\\r\\n\n        world\\r\\n\n        第一次：hello\n        第二次：\\r\\nwor\n        第三次：ld\\r\\nr\n        */\n        byte[] bys = new byte[1024]; //1024及其整数倍\n        int len;\n        while ((len=fis.read(bys))!=-1) {\n            System.out.print(new String(bys,0,len));\n        }\n        //释放资源\n        fis.close();\n    }\n}\n```\n\n\n\n> 6、字节流复制图片\n\n* 案例需求 \n\n  把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” \n\n* 实现步骤 \n\n  * 根据数据源创建字节输入流对象 \n  * 根据目的地创建字节输出流对象 \n  * 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) \n  * 释放资源\n\n```java\npublic class CopyJpgDemo {\n    public static void main(String[] args) throws IOException {\n        //根据数据源创建字节输入流对象\n        FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\");\n        //根据目的地创建字节输出流对象\n        FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\");\n        //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组)\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=fis.read(bys))!=-1) {\n            fos.write(bys,0,len);\n        }\n        //释放资源\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n\n\n## 7.3 字节缓冲流(*)\n\n> 1、概述\n\n* 字节缓冲流介绍 \n  * lBufferOutputStream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写 入字节，而不必为写入的每个字节导致底层系统的调用 \n  * lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过 字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节\n\n* 构造方法\n\n| 方法名                                 | 说明                   |\n| -------------------------------------- | ---------------------- |\n| BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 |\n| BufferedInputStream(InputStream in)    | 创建字节缓冲输入流对象 |\n\n```java\npublic class BufferStreamDemo {\n    public static void main(String[] args) throws IOException {\n        //字节缓冲输出流：BufferedOutputStream(OutputStream out)\n        BufferedOutputStream bos = new BufferedOutputStream(new\n                                                            FileOutputStream(\"myByteStream\\\\bos.txt\"));\n        //写数据\n        bos.write(\"hello\\r\\n\".getBytes());\n        bos.write(\"world\\r\\n\".getBytes());\n        //释放资源\n        bos.close();\n        //字节缓冲输入流：BufferedInputStream(InputStream in)\n        BufferedInputStream bis = new BufferedInputStream(new\n                                                          FileInputStream(\"myByteStream\\\\bos.txt\"));\n        //一次读取一个字节数据\n        // int by;\n        // while ((by=bis.read())!=-1) {\n        // System.out.print((char)by);\n        // }\n        //一次读取一个字节数组数据\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=bis.read(bys))!=-1) {\n            System.out.print(new String(bys,0,len));\n        }\n\n        //释放资源\n        bis.close();\n    }\n}\n```\n\n\n\n> 2、字节流复制视频\n\n* 案例需求\n\n  把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi”\n\n* 实现步骤 \n\n  * 根据数据源创建字节输入流对象 \n  * 根据目的地创建字节输出流对象 \n  * 读写数据，复制视频 \n  * 释放资源\n\n```java\npublic class CopyAviDemo {\n    public static void main(String[] args) throws IOException {\n        //记录开始时间\n        long startTime = System.currentTimeMillis();\n        //复制视频\n        // method1();\n        // method2();\n        // method3();\n        method4();\n        //记录结束时间\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"共耗时：\" + (endTime - startTime) + \"毫秒\");\n    }\n    //字节缓冲流一次读写一个字节数组\n    public static void method4() throws IOException {\n        BufferedInputStream bis = new BufferedInputStream(new\n                                                          FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\"));\n        BufferedOutputStream bos = new BufferedOutputStream(new\n                                                            FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\"));\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=bis.read(bys))!=-1) {\n            bos.write(bys,0,len);\n        }\n        bos.close();\n        bis.close();\n    }\n    //字节缓冲流一次读写一个字节\n    public static void method3() throws IOException {\n        BufferedInputStream bis = new BufferedInputStream(new\n                                                          FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\"));\n        BufferedOutputStream bos = new BufferedOutputStream(new\n                                                            FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\"));\n        int by;\n        while ((by=bis.read())!=-1) {\n            bos.write(by);\n        }\n        bos.close();\n        bis.close();\n    }\n    //基本字节流一次读写一个字节数组\n    public static void method2() throws IOException {\n        //E:\\\\itcast\\\\字节流复制图片.avi\n        //模块目录下的 字节流复制图片.avi\n        FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\");\n        FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\");\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=fis.read(bys))!=-1) {\n            fos.write(bys,0,len);\n        }\n        fos.close();\n        fis.close();\n    }\n    //基本字节流一次读写一个字节\n    public static void method1() throws IOException {\n        //E:\\\\itcast\\\\字节流复制图片.avi\n        //模块目录下的 字节流复制图片.avi\n        FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\");\n        FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\");\n        int by;\n        while ((by=fis.read())!=-1) {\n            fos.write(by);\n        }\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n\n\n## 7.4 字符流\n\n> 1、为什么会出现字符流\n\n* 字符流的介绍 \n\n  由于字节流操作中文不是特别的方便，所以Java就提供字符流 \n\n  字符流 = 字节流 + 编码表 \n\n* 中文的字节存储方式 \n\n  用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接 成中文，如何识别是中文的呢？ \n\n  汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数\n\n> 2、编码表\n\n* 什么是字符集 \n\n  是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。 常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 \n\n* 常见的字符集 \n\n  * ASCII字符集： \n\n    **lASCII**：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、 换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) \n\n    基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共 256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、 图形符号、数字等 \n\n  * GBXXX字符集： \n\n    **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了**双字节编码**方案，共收录了 21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 \n\n  * Unicode字符集： \n\n    **UTF-8编码**：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用 一至四个字节为每个字符编码 \n\n  * 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用**三个字节编码** 其他极少使用的Unicode辅助字符，使用四字节编码\n\n> 3、字符串中的编码解码问题\n\n* 相关方法\n\n| 方法名                                   | 说明                                               |\n| ---------------------------------------- | -------------------------------------------------- |\n| byte[] getBytes()                        | 使用平台的默认字符集将该 String编码为一系列字节    |\n| byte[] getBytes(String charsetName)      | 使用指定的字符集将该 String编码为一系列字节        |\n| String(byte[] bytes)                     | 使用平台的默认字符集解码指定的字节数组来创建字符串 |\n| String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串     |\n\n```java\npublic class StringDemo {\n    public static void main(String[] args) throws UnsupportedEncodingException {\n        //定义一个字符串\n        String s = \"中国\";\n        //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67]\n        //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67]\n        byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6]\n        System.out.println(Arrays.toString(bys));\n        //String ss = new String(bys);\n        //String ss = new String(bys,\"UTF-8\");\n        String ss = new String(bys,\"GBK\");\n        System.out.println(ss);\n    }\n}\n```\n\n> 4、字符流中的编码解码问题\n\n* 字符流中和编码解码问题相关的两个类 \n\n  * InputStreamReader：是从字节流到字符流的桥梁 \n\n    它读取字节，并使用指定的编码将其解码为字符 \n\n    它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 \n\n  * OutputStreamWriter：是从字符流到字节流的桥梁 \n\n    是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 \n\n    它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集\n\n* 构造方法\n\n| 方法名                                              | 说明                                         |\n| --------------------------------------------------- | -------------------------------------------- |\n| InputStreamReader(InputStream in)                   | 使用默认字符编码创建InputStreamReader对象    |\n| InputStreamReader(InputStream in,String chatset)    | 使用指定的字符编码创建InputStreamReader对象  |\n| OutputStreamWriter(OutputStream out)                | 使用默认字符编码创建OutputStreamWriter对象   |\n| OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter对象 |\n\n```java\npublic class ConversionStreamDemo {\n    public static void main(String[] args) throws IOException {\n        //OutputStreamWriter osw = new OutputStreamWriter(new\n        FileOutputStream(\"myCharStream\\\\osw.txt\"));\n        OutputStreamWriter osw = new OutputStreamWriter(new\n                                                        FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\");\n        osw.write(\"中国\");\n        osw.close();\n        //InputStreamReader isr = new InputStreamReader(new\n        FileInputStream(\"myCharStream\\\\osw.txt\"));\n        InputStreamReader isr = new InputStreamReader(new\n                                                      FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\");\n        //一次读取一个字符数据\n        int ch;\n        while ((ch=isr.read())!=-1) {\n            System.out.print((char)ch);\n        }\n        isr.close();\n    }\n}\n```\n\n\n\n### 7.4.1 字符输出流\n\n* 方法介绍\n\n| 方法名                                    | 说明                 |\n| ----------------------------------------- | -------------------- |\n| void write(int c)                         | 写一个字符           |\n| void write(char[] cbuf)                   | 写入一个字符数组     |\n| void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |\n| void write(String str)                    | 写一个字符串         |\n| void write(String str, int off, int len)  | 写一个字符串的一部分 |\n\n* 刷新和关闭的方法\n\n| 方法名  | 说明                                                         |\n| ------- | ------------------------------------------------------------ |\n| flush() | 刷新流，之后还可以继续写数据                                 |\n| close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 |\n\n```java\npublic class OutputStreamWriterDemo {\n    public static void main(String[] args) throws IOException {\n        OutputStreamWriter osw = new OutputStreamWriter(new\n                                                        FileOutputStream(\"myCharStream\\\\osw.txt\"));\n        //void write(int c)：写一个字符\n        // osw.write(97);\n        // osw.write(98);\n        // osw.write(99);\n        //void writ(char[] cbuf)：写入一个字符数组\n        char[] chs = {\'a\', \'b\', \'c\', \'d\', \'e\'};\n        // osw.write(chs);\n        //void write(char[] cbuf, int off, int len)：写入字符数组的一部分\n        // osw.write(chs, 0, chs.length);\n        // osw.write(chs, 1, 3);\n        //void write(String str)：写一个字符串\n        // osw.write(\"abcde\");\n        //void write(String str, int off, int len)：写一个字符串的一部分\n        // osw.write(\"abcde\", 0, \"abcde\".length());\n        osw.write(\"abcde\", 1, 3);\n        //释放资源\n        osw.close();\n    }\n}\n```\n\n\n\n### 7.4.2 字符输入流\n\n* 方法介绍\n\n| 方法名                | 说明                   |\n| --------------------- | ---------------------- |\n| int read()            | 一次读一个字符数据     |\n| int read(char[] cbuf) | 一次读一个字符数组数据 |\n\n```java\npublic class InputStreamReaderDemo {\n    public static void main(String[] args) throws IOException {\n        InputStreamReader isr = new InputStreamReader(new\n                                                      FileInputStream(\"myCharStream\\\\ConversionStreamDemo.java\"));\n        //int read()：一次读一个字符数据\n        // int ch;\n        // while ((ch=isr.read())!=-1) {\n        // System.out.print((char)ch);\n        // }\n        //int read(char[] cbuf)：一次读一个字符数组数据\n        char[] chs = new char[1024];\n        int len;\n        while ((len = isr.read(chs)) != -1) {\n            System.out.print(new String(chs, 0, len));\n        }\n        //释放资源\n        isr.close();\n    }\n}\n```\n\n\n\n> 1、字符流复制Java文件\n\n* 案例需求\n\n  把模块目录下的“ConversionStreamDemo.java” 复制到模块目录下的“Copy.java” \n\n* 实现步骤 \n\n  * 根据数据源创建字符输入流对象 \n  * 根据目的地创建字符输出流对象 \n  * 读写数据，复制文件 \n  * 释放资源\n\n```java\npublic class CopyJavaDemo01 {\n    public static void main(String[] args) throws IOException {\n        //根据数据源创建字符输入流对象\n        InputStreamReader isr = new InputStreamReader(new\n                                                      FileInputStream(\"myCharStream\\\\ConversionStreamDemo.java\"));\n        //根据目的地创建字符输出流对象\n        OutputStreamWriter osw = new OutputStreamWriter(new\n                                                        FileOutputStream(\"myCharStream\\\\Copy.java\"));\n        //读写数据，复制文件\n        //一次读写一个字符数据\n        // int ch;\n        // while ((ch=isr.read())!=-1) {\n        // osw.write(ch);\n        // }\n        //一次读写一个字符数组数据\n        char[] chs = new char[1024];\n        int len;\n        while ((len=isr.read(chs))!=-1) {\n            osw.write(chs,0,len);\n        }\n        //释放资源\n        osw.close();\n        isr.close();\n    }\n}\n```\n\n\n\n> 2、字符流复制Java文件改进版\n\n* 案例需求 \n\n  使用便捷流对象，把模块目录下的“ConversionStreamDemo.java” 复制到模块目录下的“Copy.java” \n\n* 实现步骤 \n\n  * 根据数据源创建字符输入流对象 \n  * 根据目的地创建字符输出流对象 \n  * 读写数据，复制文件 \n  * 释放资源\n\n```java\npublic class CopyJavaDemo02 {\n    public static void main(String[] args) throws IOException {\n        //根据数据源创建字符输入流对象\n        FileReader fr = new FileReader(\"myCharStream\\\\ConversionStreamDemo.java\");\n        //根据目的地创建字符输出流对象\n        FileWriter fw = new FileWriter(\"myCharStream\\\\Copy.java\");\n        //读写数据，复制文件\n        // int ch;\n        // while ((ch=fr.read())!=-1) {\n        // fw.write(ch);\n        // }\n        char[] chs = new char[1024];\n        int len;\n        while ((len=fr.read(chs))!=-1) {\n            fw.write(chs,0,len);\n        }\n        //释放资源\n        fw.close();\n        fr.close();\n    }\n}\n```\n\n\n\n## 7.5 字符缓冲流(*)\n\n* 字符缓冲流介绍 \n  * **BufferedWriter**：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可 以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 \n  * **BufferedReader**：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓 冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途\n\n* 构造方法\n\n| 方法名                     | 说明                   |\n| -------------------------- | ---------------------- |\n| BufferedWriter(Writer out) | 创建字符缓冲输出流对象 |\n| BufferedReader(Reader in)  | 创建字符缓冲输入流对象 |\n\n```java\npublic class BufferedStreamDemo01 {\n    public static void main(String[] args) throws IOException {\n        //BufferedWriter(Writer out)\n        BufferedWriter bw = new BufferedWriter(new\n                                               FileWriter(\"myCharStream\\\\bw.txt\"));\n        bw.write(\"hello\\r\\n\");\n        bw.write(\"world\\r\\n\");\n        bw.close();\n        //BufferedReader(Reader in)\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myCharStream\\\\bw.txt\"));\n        //一次读取一个字符数据\n        // int ch;\n        // while ((ch=br.read())!=-1) {\n        // System.out.print((char)ch);\n        // }\n        //一次读取一个字符数组数据\n        char[] chs = new char[1024];\n        int len;\n        while ((len=br.read(chs))!=-1) {\n            System.out.print(new String(chs,0,len));\n        }\n        br.close();\n    }\n}\n```\n\n\n\n> 1、字符缓冲流复制Java文件\n\n* 案例需求 \n\n  把模块目录下的ConversionStreamDemo.java 复制到模块目录下的 Copy.java \n\n* 实现步骤 \n\n  * 根据数据源创建字符缓冲输入流对象 \n  * 根据目的地创建字符缓冲输出流对象 \n  * 读写数据，复制文件，使用字符缓冲流特有功能实现 \n  * 释放资源\n\n```java\npublic class CopyJavaDemo01 {\n    public static void main(String[] args) throws IOException {\n        //根据数据源创建字符缓冲输入流对象\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myCharStream\\\\ConversionStreamDemo.java\"));\n        //根据目的地创建字符缓冲输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n                                               FileWriter(\"myCharStream\\\\Copy.java\"));\n        //读写数据，复制文件\n        //一次读写一个字符数据\n        // int ch;\n        // while ((ch=br.read())!=-1) {\n        // bw.write(ch);\n        // }\n        //一次读写一个字符数组数据\n        char[] chs = new char[1024];\n        int len;\n        while ((len=br.read(chs))!=-1) {\n            bw.write(chs,0,len);\n        }\n        //释放资源\n        bw.close();\n        br.close();\n    }\n}\n```\n\n\n\n> 2、字符缓冲流特有功能\n\n* 方法介绍\n\n  BufferedWriter\n\n  | 方法名         | 说明                                         |\n  | -------------- | -------------------------------------------- |\n  | void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义 |\n\n  BufferedReader\n\n  | 方法名            | 说明                                                         |\n  | ----------------- | ------------------------------------------------------------ |\n  | String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经 到达，则为null |\n\n```java\npublic class BufferedStreamDemo02 {\n    public static void main(String[] args) throws IOException {\n        //创建字符缓冲输出流\n        BufferedWriter bw = new BufferedWriter(new\n                                               FileWriter(\"myCharStream\\\\bw.txt\"));\n        //写数据\n        for (int i = 0; i < 10; i++) {\n            bw.write(\"hello\" + i);\n            //bw.write(\"\\r\\n\");\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        bw.close();\n        //创建字符缓冲输入流\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myCharStream\\\\bw.txt\"));\n        String line;\n        while ((line=br.readLine())!=null) {\n            System.out.println(line);\n        }\n        br.close();\n    }\n}\n```\n\n\n\n> 3、字符缓冲流特有功能复制Java文件\n\n* 案例需求 \n\n  使用特有功能把模块目录下的ConversionStreamDemo.java 复制到模块目录下的 Copy.java\n\n* 实现步骤 \n\n  * 根据数据源创建字符缓冲输入流对象 \n  * 根据目的地创建字符缓冲输出流对象 \n  * 读写数据，复制文件，使用字符缓冲流特有功能实现 \n  * 释放资源\n\n```java\npublic class CopyJavaDemo02 {\n    public static void main(String[] args) throws IOException {\n        //根据数据源创建字符缓冲输入流对象\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myCharStream\\\\ConversionStreamDemo.java\"));\n        //根据目的地创建字符缓冲输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n                                               FileWriter(\"myCharStream\\\\Copy.java\"));\n        //读写数据，复制文件\n        //使用字符缓冲流特有功能实现\n        String line;\n        while ((line=br.readLine())!=null) {\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        bw.close();\n        br.close();\n    }\n}\n```\n\n\n\n## 7.6 字节字符案例\n\n### 7.6.1 集合到文件\n\n* 案例需求 \n\n  把文本文件中的数据读取到集合中，并遍历集合。要求：文件中每一行数据是一个集合元素 \n\n* 实现步骤 \n\n  * 创建字符缓冲输入流对象 \n  * 创建ArrayList集合对象 \n  * 调用字符缓冲输入流对象的方法读数据 \n  * 把读取到的字符串数据存储到集合中 \n  * 释放资源 \n  * 遍历集合\n\n```java\npublic class TxtToArrayListDemo {\n    public static void main(String[] args) throws IOException {\n        //创建字符缓冲输入流对象\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myCharStream\\\\array.txt\"));\n        //创建ArrayList集合对象\n        ArrayList<String> array = new ArrayList<String>();\n        //调用字符缓冲输入流对象的方法读数据\n        String line;\n        while ((line=br.readLine())!=null) {\n            //把读取到的字符串数据存储到集合中\n            array.add(line);\n        }\n        //释放资源\n        br.close();\n        //遍历集合\n        for(String s : array) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n\n\n### 7.6.2 文件到集合\n\n* 案例需求 \n\n  把ArrayList集合中的字符串数据写入到文本文件。要求：每一个字符串元素作为文件中的一行数据 \n\n* 实现步骤 \n\n  * 创建ArrayList集合 \n  * 往集合中存储字符串元素 \n  * 创建字符缓冲输出流对象 \n  * 遍历集合，得到每一个字符串数据 \n  * 调用字符缓冲输出流对象的方法写数据 \n  * 释放资源\n\n```java\npublic class ArrayListToTxtDemo {\n    public static void main(String[] args) throws IOException {\n        //创建ArrayList集合\n        ArrayList<String> array = new ArrayList<String>();\n        //往集合中存储字符串元素\n        array.add(\"hello\");\n        array.add(\"world\");\n        array.add(\"java\");\n        //创建字符缓冲输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n                                               FileWriter(\"myCharStream\\\\array.txt\"));\n        //遍历集合，得到每一个字符串数据\n        for(String s : array) {\n            //调用字符缓冲输出流对象的方法写数据\n            bw.write(s);\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        bw.close();\n    }\n}\n```\n\n\n\n### 7.6.3 点名器\n\n* 案例需求 \n\n  我有一个文件里面存储了班级同学的姓名，每一个姓名占一行，要求通过程序实现随点名器 \n\n* 实现步骤 \n\n  * 创建字符缓冲输入流对象 \n  * 创建ArrayList集合对象 \n  * 调用字符缓冲输入流对象的方法读数据 \n  * 把读取到的字符串数据存储到集合中 \n  * 释放资源 \n  * 使用Random产生一个随机数，随机数的范围在：[0,集合的长度) \n  * 把第6步产生的随机数作为索引到ArrayList集合中获取值 \n  * 把第7步得到的数据输出在控制台\n\n```java\npublic class CallNameDemo {\n    public static void main(String[] args) throws IOException {\n        //创建字符缓冲输入流对象\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myCharStream\\\\names.txt\"));\n        //创建ArrayList集合对象\n        ArrayList<String> array = new ArrayList<String>();\n        //调用字符缓冲输入流对象的方法读数据\n        String line;\n        while ((line=br.readLine())!=null) {\n            //把读取到的字符串数据存储到集合中\n            array.add(line);\n        }\n        //释放资源\n        br.close();\n        //使用Random产生一个随机数，随机数的范围在：[0,集合的长度)\n        Random r = new Random();\n        int index = r.nextInt(array.size());\n        //把第6步产生的随机数作为索引到ArrayList集合中获取值\n        String name = array.get(index);\n        //把第7步得到的数据输出在控制台\n        System.out.println(\"幸运者是：\" + name);\n    }\n}\n```\n\n\n\n### 7.6.4 集合到文件【改进版】\n\n* 案例需求 \n\n  把ArrayList集合中的学生数据写入到文本文件。要求：每一个学生对象的数据作为文件中的一行数据 格式： 学号,姓名,年龄,居住地 举例：itheima001,林青霞,30,西安\n\n* 实现步骤 \n\n  * 定义学生类 \n  * 创建ArrayList集合 \n  * 创建学生对象 \n  * 把学生对象添加到集合中 \n  * 创建字符缓冲输出流对象 \n  * 遍历集合，得到每一个学生对象 \n  * 把学生对象的数据拼接成指定格式的字符串 \n  * 调用字符缓冲输出流对象的方法写数据 \n  * 释放资源\n\n* 学生类\n\n```java\npublic class Student {\n    private String sid;\n    private String name;\n    private int age;\n    private String address;\n    public Student() {\n    }\n    public Student(String sid, String name, int age, String address) {\n        this.sid = sid;\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n    public String getSid() {\n        return sid;\n    }\n    public void setSid(String sid) {\n        this.sid = sid;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class ArrayListToFileDemo {\n    public static void main(String[] args) throws IOException {\n        //创建ArrayList集合\n        ArrayList<Student> array = new ArrayList<Student>();\n        //创建学生对象\n        Student s1 = new Student(\"itheima001\", \"林青霞\", 30, \"西安\");\n        Student s2 = new Student(\"itheima002\", \"张曼玉\", 35, \"武汉\");\n        Student s3 = new Student(\"itheima003\", \"王祖贤\", 33, \"郑州\");\n        //把学生对象添加到集合中\n        array.add(s1);\n        array.add(s2);\n        array.add(s3);\n        //创建字符缓冲输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n                                               FileWriter(\"myCharStream\\\\students.txt\"));\n        //遍历集合，得到每一个学生对象\n        for (Student s : array) {\n            //把学生对象的数据拼接成指定格式的字符串\n            StringBuilder sb = new StringBuilder();\n            sb.append(s.getSid()).append(\",\").append(s.getName()).append(\",\").append(s.ge\n                                                                                     tAge()).append(\",\").append(s.getAddress());\n            //调用字符缓冲输出流对象的方法写数据\n            bw.write(sb.toString());\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        bw.close();\n    }\n}\n```\n\n\n\n### 7.6.5 文件到集合【改进版】\n\n* 案例需求 \n\n  把文本文件中的数据读取到集合中，并遍历集合。要求：文件中每一行数据是一个学生对象的成员变量值 举 例：itheima001,林青霞,30,西安\n\n* 实现步骤 \n\n  * 定义学生类 \n  * 创建字符缓冲输入流对象 \n  * 创建ArrayList集合对象 \n  * 调用字符缓冲输入流对象的方法读数据 \n  * 把读取到的字符串数据用split()进行分割，得到一个字符串数组 \n  * 创建学生对象 \n  * 把字符串数组中的每一个元素取出来对应的赋值给学生对象的成员变量值 \n  * 把学生对象添加到集合 \n  * 释放资源 \n  * 遍历集合\n\n* 学生类\n\n  同上\n\n* 测试类\n\n```java\npublic class FileToArrayListDemo {\n    public static void main(String[] args) throws IOException {\n        //创建字符缓冲输入流对象\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myCharStream\\\\students.txt\"));\n        //创建ArrayList集合对象\n        ArrayList<Student> array = new ArrayList<Student>();\n        //调用字符缓冲输入流对象的方法读数据\n        String line;\n        while ((line = br.readLine()) != null) {\n            //把读取到的字符串数据用split()进行分割，得到一个字符串数组\n            String[] strArray = line.split(\",\");\n            //创建学生对象\n            Student s = new Student();\n            //把字符串数组中的每一个元素取出来对应的赋值给学生对象的成员变量值\n            //itheima001,林青霞,30,西安\n            s.setSid(strArray[0]);\n            s.setName(strArray[1]);\n            s.setAge(Integer.parseInt(strArray[2]));\n            s.setAddress(strArray[3]);\n            //把学生对象添加到集合\n            array.add(s);\n        }\n        //释放资源\n        br.close();\n        //遍历集合\n        for (Student s : array) {\n            System.out.println(s.getSid() + \",\" + s.getName() + \",\" +\n                               s.getAge() + \",\" + s.getAddress());\n        }\n    }\n}\n```\n\n\n\n## 7.7 IO流案例\n\n### 7.7.1 集合到文件数据排序【改进版】\n\n* 案例需求\n  * 键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩)。要求按照成绩总分从高到低写入文本文件 \n  * 格式：姓名,语文成绩,数学成绩,英语成绩 举例：林青霞,98,99,100\n\n* 分析步骤\n  * 定义学生类 \n  * 创建TreeSet集合，通过比较器排序进行排序 \n  * 键盘录入学生数据 \n  * 创建学生对象，把键盘录入的数据对应赋值给学生对象的成员变量 \n  * 把学生对象添加到TreeSet集合 \n  * 创建字符缓冲输出流对象 \n  * 遍历集合，得到每一个学生对象 \n  * 把学生对象的数据拼接成指定格式的字符串 \n  * 调用字符缓冲输出流对象的方法写数据 \n  * 释放资源\n\n* 学生类\n\n```java\npublic class Student {\n    // 姓名\n    private String name;\n    // 语文成绩\n    private int chinese;\n    // 数学成绩\n    private int math;\n    // 英语成绩\n    private int english;\n    public Student() {\n        super();\n    }\n    public Student(String name, int chinese, int math, int english) {\n        super();\n        this.name = name;\n        this.chinese = chinese;\n        this.math = math;\n        this.english = english;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getChinese() {\n        return chinese;\n    }\n    public void setChinese(int chinese) {\n        this.chinese = chinese;\n    }\n    public int getMath() {\n        return math;\n    }\n    public void setMath(int math) {\n        this.math = math;\n    }\n    public int getEnglish() {\n        return english;\n    }\n    public void setEnglish(int english) {\n        this.english = english;\n    }\n    public int getSum() {\n        return this.chinese + this.math + this.english;\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class TreeSetToFileDemo {\n    public static void main(String[] args) throws IOException {\n        //创建TreeSet集合，通过比较器排序进行排序\n        TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\n            @Override\n            public int compare(Student s1, Student s2) {\n                //成绩总分从高到低\n                int num = s2.getSum() - s1.getSum();\n                //次要条件\n                int num2 = num == 0 ? s1.getChinese() - s2.getChinese() : num;\n                int num3 = num2 == 0 ? s1.getMath() - s2.getMath() : num2;\n                int num4 = num3 == 0 ? s1.getName().compareTo(s2.getName()) :\n                num3;\n                return num4;\n            }\n        });\n        //键盘录入学生数据\n        for (int i = 0; i < 5; i++) {\n            Scanner sc = new Scanner(System.in);\n            System.out.println(\"请录入第\" + (i + 1) + \"个学生信息：\");\n            System.out.println(\"姓名：\");\n            String name = sc.nextLine();\n            System.out.println(\"语文成绩：\");\n            int chinese = sc.nextInt();\n            System.out.println(\"数学成绩：\");\n            int math = sc.nextInt();\n            System.out.println(\"英语成绩：\");\n            int english = sc.nextInt();\n            //创建学生对象，把键盘录入的数据对应赋值给学生对象的成员变量\n            Student s = new Student();\n            s.setName(name);\n            s.setChinese(chinese);\n            s.setMath(math);\n            s.setEnglish(english);\n            //把学生对象添加到TreeSet集合\n            ts.add(s);\n        }\n        //创建字符缓冲输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n                                               FileWriter(\"myCharStream\\\\ts.txt\"));\n        //遍历集合，得到每一个学生对象\n        for (Student s : ts) {\n            //把学生对象的数据拼接成指定格式的字符串\n            //格式：姓名,语文成绩,数学成绩,英语成绩\n            StringBuilder sb = new StringBuilder();\n            sb.append(s.getName()).append(\",\").append(s.getChinese()).append(\",\").append(s\n                                                                                         .getMath()).append(\",\").append(s.getEnglish()).append(\",\").append(s.getSum());\n            // 调用字符缓冲输出流对象的方法写数据\n            bw.write(sb.toString());\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        bw.close();\n    }\n}\n```\n\n\n\n### 7.7.2 复制单级文件夹\n\n* 案例需求\n  * 把“E:\\itcast”这个文件夹复制到模块目录下\n\n* 分析步骤 \n  * 创建数据源目录File对象，路径是E:\\itcast\n  * 获取数据源目录File对象的名称 \n  * 创建目的地目录File对象，路径由(模块名+第2步获取的名称)组成 \n  * 判断第3步创建的File是否存在，如果不存在，就创建 \n  * 获取数据源目录下所有文件的File数组\n  * 遍历File数组，得到每一个File对象，该File对象，其实就是数据源文件\n  * 获取数据源文件File对象的名称 \n  * 创建目的地文件File对象，路径由(目的地目录+第7步获取的名称)组成 \n  * 复制文件 由于不清楚数据源目录下的文件都是什么类型的，所以采用字节流复制文件 采用参数为File的构造方法\n\n```java\npublic class CopyFolderDemo {\n    public static void main(String[] args) throws IOException {\n        //创建数据源目录File对象，路径是E:\\\\itcast\n        File srcFolder = new File(\"E:\\\\itcast\");\n        //获取数据源目录File对象的名称(itcast)\n        String srcFolderName = srcFolder.getName();\n        //创建目的地目录File对象，路径名是模块名+itcast组成(myCharStream\\\\itcast)\n        File destFolder = new File(\"myCharStream\",srcFolderName);\n        //判断目的地目录对应的File是否存在，如果不存在，就创建\n        if(!destFolder.exists()) {\n            destFolder.mkdir();\n        }\n        //获取数据源目录下所有文件的File数组\n        File[] listFiles = srcFolder.listFiles();\n        //遍历File数组，得到每一个File对象，该File对象，其实就是数据源文件\n        for(File srcFile : listFiles) {\n            //数据源文件：E:\\\\itcast\\\\mn.jpg\n            //获取数据源文件File对象的名称(mn.jpg)\n            String srcFileName = srcFile.getName();\n            //创建目的地文件File对象，路径名是目的地目录+mn.jpg组成\n            (myCharStream\\\\itcast\\\\mn.jpg)\n            File destFile = new File(destFolder,srcFileName);\n            //复制文件\n            copyFile(srcFile,destFile);\n        }\n    }\n    private static void copyFile(File srcFile, File destFile) throws IOException {\n        BufferedInputStream bis = new BufferedInputStream(new\n                                                          FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(new\n                                                            FileOutputStream(destFile));\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len=bis.read(bys))!=-1) {\n            bos.write(bys,0,len);\n        }\n        bos.close();\n        bis.close();\n    }\n}\n```\n\n\n\n### 7.7.3 复制多级文件夹\n\n* 案例需求 \n  * 把“E:\\itcast”这个文件夹复制到 F盘目录下 \n* 分析步骤 \n  * 创建数据源File对象，路径是E:\\itcast \n  * 创建目的地File对象，路径是F:\\ \n  * 写方法实现文件夹的复制，参数为数据源File对象和目的地File对象 \n  * 判断数据源File是否是文件 \n  * 是文件：直接复制，用字节流 \n  * 不是文件： 在目的地下创建该目录 遍历获取该目录下的所有文件的File数组，得到每一个File对象 回到3继续(递归)\n\n```java\npublic class CopyFoldersDemo {\n    public static void main(String[] args) throws IOException {\n        //创建数据源File对象，路径是E:\\\\itcast\n        File srcFile = new File(\"E:\\\\itcast\");\n        //创建目的地File对象，路径是F:\\\\\n        File destFile = new File(\"F:\\\\\");\n        //写方法实现文件夹的复制，参数为数据源File对象和目的地File对象\n        copyFolder(srcFile,destFile);\n    }\n    //复制文件夹\n    private static void copyFolder(File srcFile, File destFile) throws IOException\n    {\n        //判断数据源File是否是目录\n        if(srcFile.isDirectory()) {\n            //在目的地下创建和数据源File名称一样的目录\n            String srcFileName = srcFile.getName();\n            File newFolder = new File(destFile,srcFileName); //F:\\\\itcast\n            if(!newFolder.exists()) {\n                newFolder.mkdir();\n            }\n            //获取数据源File下所有文件或者目录的File数组\n            File[] fileArray = srcFile.listFiles();\n            //遍历该File数组，得到每一个File对象\n            for(File file : fileArray) {\n                //把该File作为数据源File对象，递归调用复制文件夹的方法\n                copyFolder(file,newFolder);\n            }\n        } else {\n            //说明是文件，直接复制，用字节流\n            File newFile = new File(destFile,srcFile.getName());\n            copyFile(srcFile,newFile);\n        }\n    }\n    //字节缓冲流复制文件\n    private static void copyFile(File srcFile, File destFile) throws IOException {\n        BufferedInputStream bis = new BufferedInputStream(new\n                                                          FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(new\n                                                            FileOutputStream(destFile));\n        byte[] bys = new byte[1024];\n        int len;\n        while ((len = bis.read(bys)) != -1) {\n            bos.write(bys, 0, len);\n        }\n        bos.close();\n        bis.close();\n    }\n}\n```\n\n\n\n### 7.7.4 复制文件的异常处理\n\n> 1、基本做法\n\n```java\npublic class CopyFileDemo {\n    public static void main(String[] args) {\n\n        //try...catch...finally\n        private static void method2() {\n            FileReader fr = null;\n            FileWriter fw = null;\n            try {\n                fr = new FileReader(\"fr.txt\");\n                fw = new FileWriter(\"fw.txt\");\n                char[] chs = new char[1024];\n                int len;\n                while ((len = fr.read()) != -1) {\n                    fw.write(chs, 0, len);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                if(fw!=null) {\n                    try {\n                        fw.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                if(fr!=null) {\n                    try {\n                        fr.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        //抛出处理\n        private static void method1() throws IOException {\n            FileReader fr = new FileReader(\"fr.txt\");\n            FileWriter fw = new FileWriter(\"fw.txt\");\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n            fw.close();\n            fr.close();\n        }\n    }\n```\n\n> 2、JDK7版本改进\n\n```java\npublic class CopyFileDemo {\n    public static void main(String[] args) {\n    }\n    //JDK7的改进方案\n    private static void method3() {\n        try(FileReader fr = new FileReader(\"fr.txt\");\n            FileWriter fw = new FileWriter(\"fw.txt\");){\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n> 3、JDK9版本改进\n\n```java\npublic class CopyFileDemo {\n    public static void main(String[] args) {\n    }\n    //JDK9的改进方案\n    private static void method4() throws IOException {\n        FileReader fr = new FileReader(\"fr.txt\");\n        FileWriter fw = new FileWriter(\"fw.txt\");\n        try(fr;fw){\n            char[] chs = new char[1024];\n            int len;\n            while ((len = fr.read()) != -1) {\n                fw.write(chs, 0, len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n## 7.8 IO特殊操作流\n\n### 7.8.1 标准输入流\n\n* System类中有两个静态的成员变量 \n  * public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的 另一个输入源\n  * public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的 另一个输出目标\n\n* 自己实现键盘录入数据\n\n```java\npublic class SystemInDemo {\n    public static void main(String[] args) throws IOException {\n        //public static final InputStream in：标准输入流\n        // InputStream is = System.in;\n        // int by;\n        // while ((by=is.read())!=-1) {\n        // System.out.print((char)by);\n        // }\n        //如何把字节流转换为字符流？用转换流\n        // InputStreamReader isr = new InputStreamReader(is);\n        // //使用字符流能不能够实现一次读取一行数据呢？可以\n        // //但是，一次读取一行数据的方法是字符缓冲输入流的特有方法\n        // BufferedReader br = new BufferedReader(isr);\n        BufferedReader br = new BufferedReader(new\n                                               InputStreamReader(System.in));\n        System.out.println(\"请输入一个字符串：\");\n        String line = br.readLine();\n        System.out.println(\"你输入的字符串是：\" + line);\n        System.out.println(\"请输入一个整数：\");\n        int i = Integer.parseInt(br.readLine());\n        System.out.println(\"你输入的整数是：\" + i);\n        //自己实现键盘录入数据太麻烦了，所以Java就提供了一个类供我们使用\n        Scanner sc = new Scanner(System.in);\n    }\n}\n```\n\n\n\n### 7.8.2 标准输出流\n\n* System类中有两个静态的成员变量 \n  * public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的 另一个输入源 \n  * public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的 另一个输出目标 \n* 输出语句的本质：是一个标准的输出流 \n  * PrintStream ps = System.out; \n  * PrintStream类有的方法，System.out都可以使用\n\n```java\npublic class SystemOutDemo {\n    public static void main(String[] args) {\n        //public static final PrintStream out：标准输出流\n        PrintStream ps = System.out;\n        //能够方便地打印各种数据值\n        // ps.print(\"hello\");\n        // ps.print(100);\n        // ps.println(\"hello\");\n        // ps.println(100);\n        //System.out的本质是一个字节输出流\n        System.out.println(\"hello\");\n        System.out.println(100);\n        System.out.println();\n        // System.out.print();\n    }\n}\n```\n\n\n\n\n\n### 7.8.3 字节打印流\n\n* 打印流分类 \n\n  * 字节打印流：PrintStream \n  * 字符打印流：PrintWriter \n\n* 打印流的特点 \n\n  * 只负责输出数据，不负责读取数据 \n  * 永远不会抛出IOException \n  * 有自己的特有方法 \n\n* 字节打印流 \n\n  * PrintStream(String fileName)：使用指定的文件名创建新的打印流 \n\n  * 使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出 \n\n  * 可以改变输出语句的目的地 \n\n    public static void setOut(PrintStream out)：重新分配“标准”输出流\n\n```java\npublic class PrintStreamDemo {\n    public static void main(String[] args) throws IOException {\n        //PrintStream(String fileName)：使用指定的文件名创建新的打印流\n        PrintStream ps = new PrintStream(\"myOtherStream\\\\ps.txt\");\n        //写数据\n        //字节输出流有的方法\n        // ps.write(97);\n        //使用特有方法写数据\n        // ps.print(97);\n        // ps.println();\n        // ps.print(98);\n        ps.println(97);\n        ps.println(98);\n        //释放资源\n        ps.close();\n    }\n}\n```\n\n\n\n### 7.8.4 字符打印流\n\n* 字符打印流构造房方法\n\n| 方法名                                     | 说明                                                         |\n| ------------------------------------------ | ------------------------------------------------------------ |\n| PrintWriter(String fileName)               | 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新 |\n| PrintWriter(Writer out, boolean autoFlush) | 创建一个新的PrintWriter out：字符输出流 autoFlush： 一个布尔值，如果 为真，则println ， printf ，或format方法将刷新输出缓冲区 |\n\n```java\npublic class PrintWriterDemo {\n    public static void main(String[] args) throws IOException {\n        //PrintWriter(String fileName) ：使用指定的文件名创建一个新的PrintWriter，而不需要自动执行行刷新\n        // PrintWriter pw = new PrintWriter(\"myOtherStream\\\\pw.txt\");\n        // pw.write(\"hello\");\n        // pw.write(\"\\r\\n\");\n        // pw.flush();\n        // pw.write(\"world\");\n        // pw.write(\"\\r\\n\");\n        // pw.flush();\n        // pw.println(\"hello\");\n        /*\n        pw.write(\"hello\");\n        pw.write(\"\\r\\n\");\n        */\n        // pw.flush();\n        // pw.println(\"world\");\n        // pw.flush();\n        //PrintWriter(Writer out, boolean autoFlush)：创建一个新的PrintWriter\n        PrintWriter pw = new PrintWriter(new\n                                         FileWriter(\"myOtherStream\\\\pw.txt\"),true);\n        // PrintWriter pw = new PrintWriter(new\n        FileWriter(\"myOtherStream\\\\pw.txt\"),false);\n        pw.println(\"hello\");\n        /*\n        pw.write(\"hello\");\n        pw.write(\"\\r\\n\");\n        pw.flush();\n        */\n        pw.println(\"world\");\n        pw.close();\n    }\n}\n```\n\n\n\n### 7.8.5 复制Java文件打印流【改进版】\n\n* 案例需求 \n  * 把模块目录下的PrintStreamDemo.java 复制到模块目录下的 Copy.java \n* 分析步骤 \n  * 根据数据源创建字符输入流对象 \n  * 根据目的地创建字符输出流对象 \n  * 读写数据，复制文件 \n  * 释放资源\n\n```java\npublic class CopyJavaDemo {\n    public static void main(String[] args) throws IOException {\n        /*\n        //根据数据源创建字符输入流对象\n        BufferedReader br = new BufferedReader(new\n        FileReader(\"myOtherStream\\\\PrintStreamDemo.java\"));\n        //根据目的地创建字符输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n        FileWriter(\"myOtherStream\\\\Copy.java\"));\n        //读写数据，复制文件\n        String line;\n        while ((line=br.readLine())!=null) {\n        bw.write(line);\n        bw.newLine();\n        bw.flush();\n        }\n        //释放资源\n        bw.close();\n        br.close();\n        */\n        //根据数据源创建字符输入流对象\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myOtherStream\\\\PrintStreamDemo.java\"));\n        //根据目的地创建字符输出流对象\n        PrintWriter pw = new PrintWriter(new\n                                         FileWriter(\"myOtherStream\\\\Copy.java\"),true);\n        //读写数据，复制文件\n        String line;\n        while ((line=br.readLine())!=null) {\n            pw.println(line);\n        }\n        //释放资源\n        pw.close();\n        br.close();\n    }\n}\n```\n\n\n\n\n\n## 7.9 对象序列化\n\n> 概述\n\n* 对象序列化介绍 \n  * 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 \n  * 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 \n  * 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 \n  * 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化** \n\n\n\n### 7.9.1 对象序列化流\n\n* 对象序列化流： ObjectOutputStream \n  * 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对 象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或 另一个进程中重构对象\n\n* 构造方法\n\n| 方法名                               | 说明                                                |\n| ------------------------------------ | --------------------------------------------------- |\n| ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的 ObjectOutputStream |\n\n* 序列化对象的方法\n\n| 方法名                       | 说明                               |\n| ---------------------------- | ---------------------------------- |\n| void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream |\n\n* 学生类\n\n```java\npublic class Student implements Serializable {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    @Override\n    public String toString() {\n        return \"Student{\" +\n            \"name=\'\" + name + \'\\\'\' +\n            \", age=\" + age +\n            \'}\';\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class ObjectOutputStreamDemo {\n    public static void main(String[] args) throws IOException {\n        //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream\n        ObjectOutputStream oos = new ObjectOutputStream(new\n                                                        FileOutputStream(\"myOtherStream\\\\oos.txt\"));\n        //创建对象\n        Student s = new Student(\"林青霞\",30);\n        //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream\n        oos.writeObject(s);\n        //释放资源\n        oos.close();\n    }\n}\n```\n\n* 注意事项 \n  * 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 \n  * Serializable是一个**标记接口**，实现该接口，不需要重写任何方法\n\n\n\n### 7.9.2 对象反序列化流\n\n* 对象反序列化流： ObjectInputStream \n  * ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象\n\n* 构造方法\n\n| 方法名                            | 说明                                           |\n| --------------------------------- | ---------------------------------------------- |\n| ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream |\n\n* 反序列化对象的方法\n\n| 方法名              | 说明                            |\n| ------------------- | ------------------------------- |\n| Object readObject() | 从ObjectInputStream读取一个对象 |\n\n```java\npublic class ObjectInputStreamDemo {\n    public static void main(String[] args) throws IOException,\n    ClassNotFoundException {\n        //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的\n        ObjectInputStream\n            ObjectInputStream ois = new ObjectInputStream(new\n                                                          FileInputStream(\"myOtherStream\\\\oos.txt\"));\n        //Object readObject()：从ObjectInputStream读取一个对象\n        Object obj = ois.readObject();\n        Student s = (Student) obj;\n        System.out.println(s.getName() + \",\" + s.getAge());\n        ois.close();\n    }\n}\n```\n\n\n\n### 7.9.3 serialVersionUID & transient\n\n* **serialVersionUID** \n  * 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ \n    * 会出问题，会抛出InvalidClassException异常 \n  * 如果出问题了，如何解决呢？ \n    * 重新序列化 \n    * 给对象所属的类加一个serialVersionUID \n      * private static final long serialVersionUID = 42L;\n\n* **transient** \n  * 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？\n    * 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程\n\n* 学生类\n\n```java\npublic class Student implements Serializable {\n    private static final long serialVersionUID = 42L;\n    private String name;\n    // private int age;\n    private transient int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    // @Override\n    // public String toString() {\n    // return \"Student{\" +\n    // \"name=\'\" + name + \'\\\'\' +\n    // \", age=\" + age +\n    // \'}\';\n    // }\n}\n```\n\n* 测试类\n\n```java\npublic class ObjectStreamDemo {\n    public static void main(String[] args) throws IOException,\n    ClassNotFoundException {\n        // write();\n        read();\n    }\n    //反序列化\n    private static void read() throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = new ObjectInputStream(new\n                                                      FileInputStream(\"myOtherStream\\\\oos.txt\"));\n        Object obj = ois.readObject();\n        Student s = (Student) obj;\n        System.out.println(s.getName() + \",\" + s.getAge());\n        ois.close();\n    }\n    //序列化\n    private static void write() throws IOException {\n        ObjectOutputStream oos = new ObjectOutputStream(new\n                                                        FileOutputStream(\"myOtherStream\\\\oos.txt\"));\n        Student s = new Student(\"林青霞\", 30);\n        oos.writeObject(s);\n        oos.close();\n    }\n}\n```\n\n\n\n## 7.10 Properties集合\n\n* Properties介绍 \n  * 是一个Map体系的集合类 \n  * Properties可以保存到流中或从流中加载 \n  * 属性列表中的每个键及其对应的值都是一个字符串\n\n```java\npublic class PropertiesDemo01 {\n    public static void main(String[] args) {\n        //创建集合对象\n        // Properties<String,String> prop = new Properties<String,String>(); //错误\n        Properties prop = new Properties();\n        //存储元素\n        prop.put(\"itheima001\", \"林青霞\");\n        prop.put(\"itheima002\", \"张曼玉\");\n        prop.put(\"itheima003\", \"王祖贤\");\n        //遍历集合\n        Set<Object> keySet = prop.keySet();\n        for (Object key : keySet) {\n            Object value = prop.get(key);\n            System.out.println(key + \",\" + value);\n        }\n    }\n}\n```\n\n\n\n> 1、Properties作为Map集合的特有方法\n\n* 特有方法\n\n| 方法名                                       | 说明                                                         |\n| -------------------------------------------- | ------------------------------------------------------------ |\n| Object setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put |\n| String getProperty(String key)               | 使用此属性列表中指定的键搜索属性                             |\n| Set stringPropertyNames()                    | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 |\n\n```java\npublic class PropertiesDemo02 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Properties prop = new Properties();\n        //Object setProperty(String key, String value)：设置集合的键和值，都是String类型，底层调用Hashtable方法put\n        prop.setProperty(\"itheima001\", \"林青霞\");\n        /*\n        Object setProperty(String key, String value) {\n        return put(key, value);\n        }\n        Object put(Object key, Object value) {\n        return map.put(key, value);\n        }\n        */\n        prop.setProperty(\"itheima002\", \"张曼玉\");\n        prop.setProperty(\"itheima003\", \"王祖贤\");\n        //String getProperty(String key)：使用此属性列表中指定的键搜索属性\n        // System.out.println(prop.getProperty(\"itheima001\"));\n        // System.out.println(prop.getProperty(\"itheima0011\"));\n        // System.out.println(prop);\n        //Set<String> stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串\n        Set<String> names = prop.stringPropertyNames();\n        for (String key : names) {\n            // System.out.println(key);\n            String value = prop.getProperty(key);\n            System.out.println(key + \",\" + value);\n        }\n    }\n}\n```\n\n\n\n> 2、Properties和IO流相结合的方法\n\n* 和IO流结合的方法\n\n| 方法名                                        | 说明                                                         |\n| --------------------------------------------- | ------------------------------------------------------------ |\n| void load(InputStream inStream)               | 从输入字节流读取属性列表（键和元素对）                       |\n| void load(Reader reader)                      | 从输入字符流读取属性列表（键和元素对）                       |\n| void store(OutputStream out, String comments) | 将此属性列表（键和元素对）写入此 Properties表中，以适合于使用 load(InputStream)方法的格式写入输出字节流 |\n| void store(Writer writer, String comments)    | 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 |\n\n```java\npublic class PropertiesDemo03 {\n    public static void main(String[] args) throws IOException {\n        //把集合中的数据保存到文件\n        // myStore();\n        //把文件中的数据加载到集合\n        myLoad();\n    }\n    private static void myLoad() throws IOException {\n        Properties prop = new Properties();\n        //void load(Reader reader)：\n        FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\");\n        prop.load(fr);\n        fr.close();\n        System.out.println(prop);\n    }\n    private static void myStore() throws IOException {\n        Properties prop = new Properties();\n        prop.setProperty(\"itheima001\",\"林青霞\");\n        prop.setProperty(\"itheima002\",\"张曼玉\");\n        prop.setProperty(\"itheima003\",\"王祖贤\");\n        //void store(Writer writer, String comments)：\n        FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\");\n        prop.store(fw,null);\n        fw.close();\n    }\n}\n```\n\n\n\n\n\n# 8. 经典案例\n\n## 8.1 基础练习(基本语法)\n\n1. **逢七必过**\n\n从任意一个数字开始报数，当你要报的数字包含7或者是7 的倍数时都要说：过。 为了帮助大家更好的玩这个游戏，这里我们直接在控制台打印出1-100之间的满足逢七必过 规则的数据。 这样，大家将来在玩游戏的时候，就知道哪些数据要说：过。\n\n```java\n/*\n    思路：\n    1:数据在1-100之间，用for循环实现数据的获取\n    2:根据规则，用if语句实现数据的判断：要么个位是7，要么十位是7，要么能够被7整除\n    3:在控制台输出满足规则的数据\n*/\npublic class Test03 {\n    public static void main(String[] args) {\n        //数据在1-100之间，用for循环实现数据的获取\n        for(int x=1; x<=100; x++) {\n        //根据规则，用if语句实现数据的判断：要么个位是7，要么十位是7，要么能够被7整除\n            if(x%10==7 || x/10%10==7 || x%7==0) {\n            //在控制台输出满足规则的数据\n        		System.out.println(x);\n    		}\n    	}\n    }\n}\n```\n\n\n\n2. **不死神兔**\n\n有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子， 假如兔子都 不死，问第二十个月的兔子对数为多少？\n\n```java\n/*\n    思路：\n    1:为了存储多个月的兔子对数，定义一个数组，用动态初始化完成数组元素的初始化，长度为20\n    2:因为第1个月，第2个月兔子的对数是已知的，都是1，所以数组的第1个元素，第2个元素值也都是1\n    3:用循环实现计算每个月的兔子对数\n    4:输出数组中最后一个元素的值，就是第20个月的兔子对数\n*/\npublic class Test04 {\n    public static void main(String[] args) {\n        //为了存储多个月的兔子对数，定义一个数组，用动态初始化完成数组元素的初始化，长度为20\n        int[] arr = new int[20];\n        //因为第1个月，第2个月兔子的对数是已知的，都是1，所以数组的第1个元素，第2个元素值也都是1\n        arr[0] = 1;\n        arr[1] = 1;\n        //用循环实现计算每个月的兔子对数\n        for(int x=2; x<arr.length; x++) {\n        	arr[x] = arr[x-2] + arr[x-1];\n        }\n        //输出数组中最后一个元素的值，就是第20个月的兔子对数\n        System.out.println(\"第二十个月兔子的对数是：\" + arr[19]);\n    }\n}\n```\n\n\n\n3. **百钱百鸡**\n\n我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。 百钱 买百鸡，问鸡翁、鸡母、鸡雏各几何？\n\n```java\n/*\n    思路：\n    1:第1层循环，用于表示鸡翁的范围，初始化表达式的变量定义为 x=0，判断条件是x<=20\n    2:第2层循环，用于表示鸡母的范围，初始化表达式的变量定义为 y=0，判断条件是y<=33\n    3:这个时候，用于表示鸡雏的变量 z = 100 – x – y\n    4:判断表达式 z%3==0 和表达式 5*x + 3*y + z/3 = 100 是否同时成立，如果成立，输出对应的\n    x，y，z 的值，就是对应的鸡翁，鸡母，鸡雏的值\n*/\npublic class Test05 {\n    public static void main(String[] args) {\n        //第1层循环，用于表示鸡翁的范围，初始化表达式的变量定义为 x=0，判断条件是x<=20\n        for(int x=0; x<=20; x++) {\n            //第2层循环，用于表示鸡母的范围，初始化表达式的变量定义为 y=0，判断条件是y<=33\n            for(int y=0; y<=33; y++) {\n                //这个时候，用于表示鸡雏的变量 z = 100 – x – y\n                int z = 100 - x - y;\n                //判断表达式 z%3==0 和表达式 5*x + 3*y + z/3 = 100 是否同时成立\n                if(z%3==0 && 5*x+3*y+z/3==100) {\n                     System.out.println(x+\",\"+y+\",\"+z);\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n4. **数组元素求和**\n\n有这样的一个数组，元素是{68,27,95,88,171,996,51,210}。求出该数组中满足要求的元素和， 要求是：求和的元素个位和十位都不能是7，并且只能是偶数\n\n```java\n/*\n    思路：\n    1:定义一个数组，用静态初始化完成数组元素的初始化\n    2:定义一个求和变量，初始值是0\n    3:遍历数组，获取到数组中的每一个元素\n    4:判断该元素是否满足条件，如果满足条件就累加\n    5:输出求和变量的值\n*/\npublic class Test06 {\n    public static void main(String[] args) {\n        //定义一个数组，用静态初始化完成数组元素的初始化\n        int[] arr = {68, 27, 95, 88, 171, 996, 51, 210};\n        //定义一个求和变量，初始值是0\n        int sum = 0;\n            //遍历数组，获取到数组中的每一个元素\n        for(int x=0; x<arr.length; x++) {\n            //判断该元素是否满足条件，如果满足条件就累加\n            if(arr[x]%10!=7 && arr[x]/10%10!=7 && arr[x]%2==0) {\n            	sum += arr[x];\n            }\n        }\n        //输出求和变量的值\n        System.out.println(\"sum:\" + sum);\n    }\n}\n```\n\n\n\n5. **判断两个数组是否相同**\n\n定义一个方法，用于比较两个数组的内容是否相同\n\n```java\n/*\n    思路：\n    1:定义两个数组，分别使用静态初始化完成数组元素的初始化\n    2:定义一个方法，用于比较两个数组的内容是否相同\n    3:比较两个数组的内容是否相同，按照下面的步骤实现就可以了\n    首先比较数组长度，如果长度不相同，数组内容肯定不相同，返回false\n    其次遍历，比较两个数组中的每一个元素，只要有元素不相同，返回false\n    最后循环遍历结束后，返回true\n    4:调用方法，用变量接收\n    5:输出结果\n*/\npublic class Test07 {\n    public static void main(String[] args) {\n        //定义两个数组，分别使用静态初始化完成数组元素的初始化\n        int[] arr = {11, 22, 33, 44, 55};\n        //int[] arr2 = {11, 22, 33, 44, 55};\n        int[] arr2 = {11, 22, 33, 44, 5};\n        //调用方法，用变量接收\n        boolean flag = compare(arr,arr2);\n        //输出结果\n        System.out.println(flag);\n    }\n\n    //定义一个方法，用于比较两个数组的内容是否相同\n    /*\n    两个明确：\n    返回值类型：boolean\n    参数：int[] arr, int[] arr2\n    */\n    public static boolean compare(int[] arr, int[] arr2) {\n        //首先比较数组长度，如果长度不相同，数组内容肯定不相同，返回false\n        if(arr.length != arr2.length) {\n        	return false;\n        }\n        //其次遍历，比较两个数组中的每一个元素，只要有元素不相同，返回false\n        for(int x=0; x<arr.length; x++) {\n        	if(arr[x] != arr2[x]) {\n        return false;\n        	}\n        }\n        //最后循环遍历结束后，返回true\n        return true;\n    }\n}\n```\n\n\n\n6. **查找元素在数组中出现的索引位置**\n\n已知一个数组 arr = {19, 28, 37, 46, 50}; 键盘录入一个数据，查找该数据在数组中的索引。 并在控制台输出找到的索引值。如果没有查找到，则输出-1\n\n```java\n/*\n    思路：\n    1:定义一个数组，用静态初始化完成数组元素的初始化\n    2:键盘录入要查找的数据，用一个变量接收\n    3:定义一个索引变量，初始值为-1\n    4:遍历数组，获取到数组中的每一个元素\n    5:拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量,并\n    结束循环\n    6:输出索引变量\n*/\npublic class Test08 {\n    public static void main(String[] args) {\n        //定义一个数组，用静态初始化完成数组元素的初始化\n        int[] arr = {19, 28, 37, 46, 50};\n        //键盘录入要查找的数据，用一个变量接收\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入要查找的数据：\");\n        int number = sc.nextInt();\n        //调用方法\n        int index = getIndex(arr, number);\n        //输出索引变量\n        System.out.println(\"index: \" + index);\n\n        //查找指定的数据在数组中的索引\n        /*\n        两个明确：\n        返回值类型：int\n        参数：int[] arr, int number\n        */\n        public static int getIndex(int[] arr, int number) {\n        //定义一个索引变量，初始值为-1\n        int index = -1;\n        //遍历数组，获取到数组中的每一个元素\n        for(int x=0; x<arr.length; x++) {\n            //拿键盘录入的数据和数组中的每一个元素进行比较，如果值相同，就把该值对应的索引赋值给索引变量,并结束循环\n            if(arr[x] == number) {\n                index = x;\n                break;\n            }\n        }\n        //返回索引\n        return index;\n    }\n}\n```\n\n\n\n7. **数组元素反转**\n\n已知一个数组 arr = {19, 28, 37, 46, 50}; 用程序实现把数组中的元素值交换， 交换后的数组 arr = {50, 46, 37, 28, 19}; 并在控制台输出交换后的数组元素。\n\n```java\n/*\n    思路：\n    1:定义一个数组，用静态初始化完成数组元素的初始化\n    2:循环遍历数组，这一次初始化语句定义两个索引变量，判断条件是开始索引小于等于结束索引\n    3:变量交换\n    4:遍历数组\n*/\npublic class Test09 {\n    public static void main(String[] args) {\n        //定义一个数组，用静态初始化完成数组元素的初始化\n        int[] arr = {19, 28, 37, 46, 50};\n        //调用反转的方法\n        reverse(arr);\n        //遍历数组\n        printArray(arr);\n\n        /*\n        两个明确：\n        返回值类型：void\n        参数：int[] arr\n        */\n        public static void reverse(int[] arr) {\n            //循环遍历数组，这一次初始化语句定义两个索引变量，判断条件是开始索引小于等于结束索引\n            for (int start = 0, end = arr.length - 1; start <= end; start++, end--) {\n                //变量交换\n                int temp = arr[start];\n                arr[start] = arr[end];\n                arr[end] = temp;\n            }\n        }\n        /*\n        两个明确：\n        返回值类型：void\n        参数：int[] arr\n        */\n        public static void printArray(int[] arr) {\n            System.out.print(\"[\");\n            for (int x = 0; x < arr.length; x++) {\n                if (x == arr.length - 1) {\n                    System.out.print(arr[x]);\n                } else {\n                    System.out.print(arr[x] + \", \");\n                }\n            }\n            System.out.println(\"]\");\n        }\n    }\n```\n\n\n\n8. **评委打分**\n\n在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。 选手的最后得分为：去掉一个最高分和一 个最低分后的4个评委平均值 (不考虑小数部分)。\n\n```java\n/*\n    思路：\n    1:定义一个数组，用动态初始化完成数组元素的初始化，长度为6\n    2:键盘录入评委分数\n    3:由于是6个评委打分，所以，接收评委分数的操作，用循环改进\n    4:定义方法实现获取数组中的最高分(数组最大值)，调用方法\n    5:定义方法实现获取数组中的最低分(数组最小值) ，调用方法\n    6:定义方法实现获取数组中的所有元素的和(数组元素求和) ，调用方法\n    7:按照计算规则进行计算得到平均分\n    8:输出平均分\n*/\npublic class Test10 {\n    public static void main(String[] args) {\n        //定义一个数组，用动态初始化完成数组元素的初始化，长度为6\n        int[] arr = new int[6];\n        //键盘录入评委分数\n        Scanner sc = new Scanner(System.in);\n        //由于是6个评委打分，所以，接收评委分数的操作，用循环改进\n        for(int x=0; x<arr.length; x++) {\n            System.out.println(\"请输入第\" + (x + 1) + \"个评委的打分：\");\n            arr[x] = sc.nextInt();\n    	}	\n        //printArray(arr);\n        //定义方法实现获取数组中的最高分(数组最大值)，调用方法\n        int max = getMax(arr);\n        //定义方法实现获取数组中的最低分(数组最小值) ，调用方法\n        int min = getMin(arr);\n        //定义方法实现获取数组中的所有元素的和(数组元素求和) ，调用方法\n        int sum = getSum(arr);\n        //按照计算规则进行计算得到平均分\n        int avg = (sum - max - min) / (arr.length - 2);\n        //输出平均分\n        System.out.println(\"选手的最终得分是：\" + avg);\n	}\n    /*\n    两个明确：\n    返回值类型：int\n    参数：int[] arr\n    */\n    public static int getSum(int[] arr) {\n    	int sum = 0;\n        for(int x=0; x<arr.length; x++) {\n        	sum += arr[x];\n        }\n        return sum;\n    }\n	/*\n    两个明确：\n    返回值类型：int\n    参数：int[] arr\n	*/\n    public static int getMin(int[] arr) {\n        int min = arr[0];\n        for(int x=1; x<arr.length; x++) {\n            if(arr[x] < min) {\n            	min = arr[x];\n            }\n        }\n        return min;\n    }\n    /*\n    两个明确：\n    返回值类型：int\n    参数：int[] arr\n    */\n    public static int getMax(int[] arr) {\n        int max = arr[0];\n        for(int x=1; x<arr.length; x++) {\n            if(arr[x] > max) {\n                max = arr[x];\n            }\n        }\n        return max;\n    }\n    //遍历数组\n    public static void printArray(int[] arr) {\n    	System.out.print(\"[\");\n        for (int x = 0; x < arr.length; x++) {\n            if (x == arr.length - 1) {\n            	System.out.print(arr[x]);\n            } else {\n            	System.out.print(arr[x] + \", \");\n            }\n        }\n        System.out.println(\"]\");\n    }\n}\n\n```\n\n\n\n9. **冒泡排序**\n\n概述：一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序 \n\n* 如果有n个数据进行排序，总共需要比较n-1次 \n* 每一次比较完毕，下一次的比较就会少一个数据参与\n\n```java\n/*\n冒泡排序：\n一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，\n依次对所有的数据进行操作，直至所有数据按要求完成排序\n*/\npublic class ArrayDemo {\n    public static void main(String[] args) {\n        //定义一个数组\n        int[] arr = {24, 69, 80, 57, 13};\n            System.out.println(\"排序前：\" + arrayToString(arr));\n            // 这里减1，是控制每轮比较的次数\n            for (int x = 0; x < arr.length ­ 1; x++) {\n                // ­1是为了避免索引越界，­x是为了调高比较效率\n                for (int i = 0; i < arr.length ­ 1 ­ x; i++) {\n                    if (arr[i] > arr[i + 1]) {\n                        int temp = arr[i];\n                            arr[i] = arr[i + 1];\n                            arr[i + 1] = temp;\n                    }\n                }\n            }\n        System.out.println(\"排序后：\" + arrayToString(arr));\n    }\n    //把数组中的元素按照指定的规则组成一个字符串：[元素1, 元素2, ...]\n    public static String arrayToString(int[] arr) {\n        StringBuilder sb = new StringBuilder();\n            sb.append(\"[\");\n            for (int i = 0; i < arr.length; i++) {\n                if (i == arr.length ­ 1) {\n                    sb.append(arr[i]);\n                } else {\n                    sb.append(arr[i]).append(\", \");\n                }\n            }\n        sb.append(\"]\");\n            String s = sb.toString();\n            return s;\n    }\n}\n```\n\n\n\n## 8.2 运动员案例(面向对象)\n\n我们现在有乒乓球运动员和篮球运动员，乒乓球教练和篮球教练。 \n\n为了出国交流，跟乒乓球相关的人员都需要学习英语。 \n\n请用所学知识分析，这个案例中有哪些**具体类**，哪些**抽象类**，哪些**接口**，并用代码实现。\n\n![image-20230129122048888](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230129122048888.png)\n\n* 抽象人类\n\n```java\npublic abstract class Person {\n    private String name;\n        private int age;\n        public Person() {\n    }\n    public Person(String name, int age) {\n        this.name = name;\n            this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public abstract void eat();\n}\n```\n\n* 抽象运动员类\n\n```java\npublic abstract class Player extends Person {\n    public Player() {\n    }\n    public Player(String name, int age) {\n        super(name, age);\n    }\n    public abstract void study();\n}\n```\n\n* 抽象教练类\n\n```java\npublic abstract class Player extends Person {\n    public Player() {\n    }\n    public Player(String name, int age) {\n        super(name, age);\n    }\n    public abstract void study();\n}\n```\n\n* 学英语接口\n\n```java\npublic interface SpeakEnglish {\n    public abstract void speak();\n}\n```\n\n* 篮球教练\n\n```java\npublic class BasketballCoach extends Coach {\n    public BasketballCoach() {\n    }\n    public BasketballCoach(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void teach() {\n        System.out.println(\"篮球教练教如何运球和投篮\");\n    }\n    @Override\n    public void eat() {\n        System.out.println(\"篮球教练吃羊肉，喝羊奶\");\n    }\n}\n```\n\n* 乒乓球教练\n\n```java\npublic class PingPangCoach extends Coach implements SpeakEnglish {\n    public PingPangCoach() {\n    }\n    public PingPangCoach(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void teach() {\n        System.out.println(\"乒乓球教练教如何发球和接球\");\n    }\n    @Override\n    public void eat() {\n        System.out.println(\"乒乓球教练吃小白菜，喝大米粥\");\n    }\n    @Override\n    public void speak() {\n        System.out.println(\"乒乓球教练说英语\");\n    }\n}\n```\n\n* 乒乓球运动员\n\n```java\npublic class PingPangPlayer extends Player implements SpeakEnglish {\n    public PingPangPlayer() {\n    }\n    public PingPangPlayer(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void study() {\n        System.out.println(\"乒乓球运动员学习如何发球和接球\");\n    }\n    @Override\n    public void eat() {\n        System.out.println(\"乒乓球运动员吃大白菜，喝小米粥\");\n    }\n    @Override\n    public void speak() {\n        System.out.println(\"乒乓球运动员说英语\");\n    }\n}\n```\n\n* 篮球运动员\n\n```java\npublic class BasketballPlayer extends Player {\n    public BasketballPlayer() {\n    }\n    public BasketballPlayer(String name, int age) {\n        super(name, age);\n    }\n    @Override\n    public void study() {\n        System.out.println(\"篮球运动员学习如何运球和投篮\");\n    }\n    @Override\n    public void eat() {\n        System.out.println(\"篮球运动员吃牛肉，喝牛奶\");\n    }\n}\n```\n\n\n\n## 8.3 学生管理系统(面向对象)\n\n> 实现步骤\n\n* 案例需求 \n\n针对目前我们的所学内容，完成一个综合案例：学生管理系统！该系统主要功能如下： \n\n添加学生：通过键盘录入学生信息，添加到集合中 \n\n删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除 \n\n修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改 \n\n查看学生：将集合中的学生对象信息进行展示 \n\n退出系统：结束程序 \n\n* 实现步骤 \n\n1. 定义学生类，包含以下成员变量 \n\n   private String sid // 学生id \n\n   private String name // 学生姓名 \n\n   private String age // 学生年龄 \n\n   private String address // 学生所在地 \n\n2. 学生管理系统主界面的搭建步骤 \n\n   2.1 用输出语句完成主界面的编写\n\n   2.2 用Scanner实现键盘输入 \n\n   2.3 用switch语句完成选择的功能 \n\n   2.4 用 循环完成功能结束后再次回到主界面 \n\n3. 学生管理系统的添加学生功能实现步骤 \n\n   3.1 定义一个方法，接收ArrayList集合 \n\n   3.2 方法内完成添加学生的功能 ①键盘录入学生信息 ②根据录 入的信息创建学生对象 ③将学生对象添加到集合中 ④提示添加成功信息 \n\n   3.3 在添加学生的选项里调用 添加学生的方法 \n\n4. 学生管理系统的查看学生功能实现步骤 \n\n   4.1 定义一个方法，接收ArrayList集合 \n\n   4.2 方法内遍历集合，将学生信息进行输出 \n\n   4.3 在查看所有学生选 项里调用查看学生方法 \n\n5. 学生管理系统的删除学生功能实现步骤 \n\n   5.1 定义一个方法，接收ArrayList集合 \n\n   5.2 方法中接收要删除学生的学号 \n\n   5.3 遍历集合，获取每个学生对 象 \n\n   5.4 使用学生对象的学号和录入的要删除的学号进行比较,如果相同，则将当前学生对象从集合中删除 5.5 在删除学生选项里调用删除学生的方法 \n\n6. 学生管理系统的修改学生功能实现步骤\n\n   6.1 定义一个方法，接收ArrayList集合 \n\n   6.2 方法中接收要修改学生的学号 \n\n   6.3 通过键盘录入学生对象所需 的信息，并创建对象 \n\n   6.4 遍历集合，获取每一个学生对象。并和录入的修改学生学号进行比较.如果相 同，则使用新学生对象替换当前学生对象 \n\n   6.5 在修改学生选项里调用修改学生的方法 \n\n7. 退出系统 \n\n   使用System.exit(0);退出JVM\n\n\n\n> 实现流程\n\n* 学生类的定义\n\n```java\npublic class Student {\n    //学号\n    private String sid;\n    //姓名\n    private String name;\n    //年龄\n    private String age;\n    //居住地\n    private String address;\n    public Student() {\n    }\n    public Student(String sid, String name, String age, String address) {\n        this.sid = sid;\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n    public String getSid() {\n        return sid;\n    }\n    public void setSid(String sid) {\n        this.sid = sid;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public String getAge() {\n        return age;\n    }\n    public void setAge(String age) {\n        this.age = age;\n    }\n    public String getAddress() {\n        return address;\n    }\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n* 测试类的定义\n\n```java\npublic class StudentManager {\n    /*\n1:用输出语句完成主界面的编写\n2:用Scanner实现键盘录入数据\n3:用switch语句完成操作的选择\n4:用循环完成再次回到主界面\n*/\n    public static void main(String[] args) {\n        //创建集合对象，用于保存学生数据信息\n        ArrayList<Student> array = new ArrayList<Student>();\n        //用循环完成再次回到主界面\n        while (true) {\n            //用输出语句完成主界面的编写\n            System.out.println(\"--------欢迎来到学生管理系统--------\");\n            System.out.println(\"1 添加学生\");\n            System.out.println(\"2 删除学生\");\n            System.out.println(\"3 修改学生\");\n            System.out.println(\"4 查看所有学生\");\n            System.out.println(\"5 退出\");\n            System.out.println(\"请输入你的选择：\");\n            //用Scanner实现键盘录入数据\n            Scanner sc = new Scanner(System.in);\n            String line = sc.nextLine();\n            //用switch语句完成操作的选择\n            switch (line) {\n                case \"1\":\n                    addStudent(array);\n                    break;\n                case \"2\":\n                    deleteStudent(array);\n                    break;\n                case \"3\":\n                    updateStudent(array);\n                    break;\n                case \"4\":\n                    findAllStudent(array);\n                    break;\n                case \"5\":\n                    System.out.println(\"谢谢使用\");\n                    System.exit(0); //JVM退出\n            }\n        }\n    }\n    //定义一个方法，用于添加学生信息\n    public static void addStudent(ArrayList<Student> array) {\n        //键盘录入学生对象所需要的数据,显示提示信息，提示要输入何种信息\n        Scanner sc = new Scanner(System.in);\n        String sid;\n        while (true) {\n            System.out.println(\"请输入学生学号：\");\n            sid = sc.nextLine();\n            boolean flag = isUsed(array, sid);\n            if (flag) {\n                System.out.println(\"你输入的学号已经被占用，请重新输入\");\n            } else {\n                break;\n            }\n        }\n        System.out.println(\"请输入学生姓名：\");\n        String name = sc.nextLine();\n        System.out.println(\"请输入学生年龄：\");\n        String age = sc.nextLine();\n        System.out.println(\"请输入学生居住地：\");\n        String address = sc.nextLine();\n        //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量\n        Student s = new Student();\n        s.setSid(sid);\n        s.setName(name);\n        s.setAge(age);\n        s.setAddress(address);\n        //将学生对象添加到集合中\n        array.add(s);\n        //给出添加成功提示\n        System.out.println(\"添加学生成功\");\n    }\n    //定义一个方法，判断学号是否被使用\n    public static boolean isUsed(ArrayList<Student> array, String sid) {\n        //如果与集合中的某一个学生学号相同，返回true;如果都不相同，返回false\n        boolean flag = false;\n        for(int i=0; i<array.size(); i++) {\n            Student s = array.get(i);\n            if(s.getSid().equals(sid)) {\n                flag = true;\n                break;\n            }\n        }\n        return flag;\n    }\n    //定义一个方法，用于查看学生信息\n    public static void findAllStudent(ArrayList<Student> array) {\n        //判断集合中是否有数据，如果没有显示提示信息\n        if (array.size() == 0) {\n            System.out.println(\"无信息，请先添加信息再查询\");\n            //为了让程序不再往下执行，我们在这里写上return;\n            return;\n        }\n        //显示表头信息\n        //\\t其实是一个tab键的位置\n        System.out.println(\"学号\\t\\t\\t姓名\\t\\t年龄\\t\\t居住地\");\n        //将集合中数据取出按照对应格式显示学生信息，年龄显示补充“岁”\n        for (int i = 0; i < array.size(); i++) {\n            Student s = array.get(i);\n            System.out.println(s.getSid() + \"\\t\" + s.getName() + \"\\t\" + s.getAge() +\n                               \"岁\\t\\t\" + s.getAddress());\n        }\n    }\n    //定义一个方法，用于删除学生信息\n    public static void deleteStudent(ArrayList<Student> array) {\n        //键盘录入要删除的学生学号,显示提示信息\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入你要删除的学生的学号：\");\n        String sid = sc.nextLine();\n        //在删除/修改学生操作前，对学号是否存在进行判断\n        //如果不存在，显示提示信息\n        //如果存在，执行删除/修改操作\n        int index = -1;\n        for (int i = 0; i < array.size(); i++) {\n            Student s = array.get(i);\n            if (s.getSid().equals(sid)) {\n                index = i;\n                break;\n            }\n        }\n        if (index == -1) {\n            System.out.println(\"该信息不存在，请重新输入\");\n        } else {\n            array.remove(index);\n            //给出删除成功提示\n            System.out.println(\"删除学生成功\");\n        }\n    }\n    //定义一个方法，用于修改学生信息\n    public static void updateStudent(ArrayList<Student> array) {\n        //键盘录入要修改的学生学号，显示提示信息\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入你要修改的学生的学号：\");\n        String sid = sc.nextLine();\n        //键盘录入要修改的学生信息\n        System.out.println(\"请输入学生新姓名：\");\n        String name = sc.nextLine();\n        System.out.println(\"请输入学生新年龄：\");\n        String age = sc.nextLine();\n        System.out.println(\"请输入学生新居住地：\");\n        String address = sc.nextLine();\n        //创建学生对象\n        Student s = new Student();\n        s.setSid(sid);\n        s.setName(name);\n        s.setAge(age);\n        s.setAddress(address);\n        //遍历集合修改对应的学生信息\n        for (int i = 0; i < array.size(); i++) {\n            Student student = array.get(i);\n            if (student.getSid().equals(sid)) {\n                array.set(i, s);\n            }\n        }\n        //给出修改成功提示\n        System.out.println(\"修改学生成功\");\n    }\n}\n```\n\n\n\n\n\n## 8.4 斗地主案例(集合)\n\n> 1、模拟斗地主案例-普通版本\n\n通过程序实现斗地主过程中的洗牌，发牌和看牌\n\n```java\npublic class PokerDemo {\n    public static void main(String[] args) {\n        //创建一个牌盒，也就是定义一个集合对象，用ArrayList集合实现\n        ArrayList<String> array = new ArrayList<String>();\n        //往牌盒里面装牌\n        /*\n        ♦2,♦3,♦4...♦K,♦A\n        ♣2,...\n        ♥2,...\n        ♠2,...\n        小王，大王\n        */\n        //定义花色数组\n        String[] colors = {\"♦\", \"♣\", \"♥\", \"♠\"};\n        //定义点数数组\n        String[] numbers = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\",\"Q\", \"K\", \"A\"};\n        for (String color : colors) {\n            for (String number : numbers) {\n                array.add(color + number);\n            }\n        }\n        array.add(\"小王\");\n        array.add(\"大王\");\n        //洗牌，也就是把牌打撒，用Collections的shuffle()方法实现\n        Collections.shuffle(array);\n        // System.out.println(array);\n        //发牌，也就是遍历集合，给三个玩家发牌\n        ArrayList<String> lqxArray = new ArrayList<String>();\n        ArrayList<String> lyArray = new ArrayList<String>();\n        ArrayList<String> fqyArray = new ArrayList<String>();\n        ArrayList<String> dpArray = new ArrayList<String>();\n        for (int i = 0; i < array.size(); i++) {\n            String poker = array.get(i);\n            if (i >= array.size() - 3) {\n                dpArray.add(poker);\n            } else if (i % 3 == 0) {\n                lqxArray.add(poker);\n            } else if (i % 3 == 1) {\n                lyArray.add(poker);\n            } else if (i % 3 == 2) {\n                fqyArray.add(poker);\n            }\n        }\n        //看牌，也就是三个玩家分别遍历自己的牌\n        lookPoker(\"林青霞\", lqxArray);\n        lookPoker(\"柳岩\", lyArray);\n        lookPoker(\"风清扬\", fqyArray);\n        lookPoker(\"底牌\", dpArray);\n    }\n    //看牌的方法\n    public static void lookPoker(String name, ArrayList<String> array) {\n        System.out.print(name + \"的牌是：\");\n        for (String poker : array) {\n            System.out.print(poker + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n\n\n> 2、模拟斗地主案例-升级版本\n\n通过程序实现斗地主过程中的洗牌，发牌和看牌。要求：对牌进行排序\n\n```java\npublic class PokerDemo {\n    public static void main(String[] args) {\n        //创建HashMap，键是编号，值是牌\n        HashMap<Integer, String> hm = new HashMap<Integer, String>();\n        //创建ArrayList，存储编号\n        ArrayList<Integer> array = new ArrayList<Integer>();\n        //创建花色数组和点数数组\n        String[] colors = {\"♦\", \"♣\", \"♥\", \"♠\"};\n        String[] numbers = {\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\",\"K\", \"A\", \"2\"};\n        //从0开始往HashMap里面存储编号，并存储对应的牌。同时往ArrayList里面存储编号\n        int index = 0;\n        for (String number : numbers) {\n            for (String color : colors) {\n                hm.put(index, color + number);\n                array.add(index);\n                index++;\n            }\n        }\n        hm.put(index, \"小王\");\n        array.add(index);\n        index++;\n        hm.put(index, \"大王\");\n        array.add(index);\n        //洗牌(洗的是编号)，用Collections的shuffle()方法实现\n        Collections.shuffle(array);\n        //发牌(发的也是编号，为了保证编号是排序的，创建TreeSet集合接收)\n        TreeSet<Integer> lqxSet = new TreeSet<Integer>();\n        TreeSet<Integer> lySet = new TreeSet<Integer>();\n        TreeSet<Integer> fqySet = new TreeSet<Integer>();\n        TreeSet<Integer> dpSet = new TreeSet<Integer>();\n        for (int i = 0; i < array.size(); i++) {\n            int x = array.get(i);\n            if (i >= array.size() - 3) {\n                dpSet.add(x);\n            } else if (i % 3 == 0) {\n                lqxSet.add(x);\n            } else if (i % 3 == 1) {\n                lySet.add(x);\n            } else if (i % 3 == 2) {\n                fqySet.add(x);\n            }\n        }\n        //调用看牌方法\n        lookPoker(\"林青霞\", lqxSet, hm);\n        lookPoker(\"柳岩\", lySet, hm);\n        lookPoker(\"风清扬\", fqySet, hm);\n        lookPoker(\"底牌\", dpSet, hm);\n    }\n    //定义方法看牌(遍历TreeSet集合，获取编号，到HashMap集合找对应的牌)\n    public static void lookPoker(String name, TreeSet<Integer> ts,\n                                 HashMap<Integer, String> hm) {\n        System.out.print(name + \"的牌是：\");\n        for (Integer key : ts) {\n            String poker = hm.get(key);\n            System.out.print(poker + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n\n\n## 8.5 游戏次数案例(IO流)\n\n* 案例需求 \n\n  * 实现猜数字小游戏只能试玩3次，如果还想玩，提示：游戏试玩已结束，想玩请充值(www.itcast.cn) \n\n* 分析步骤 \n\n  * 写一个游戏类，里面有一个猜数字的小游戏 \n\n  * 写一个测试类，测试类中有main()方法，main()方法中写如下代码： \n\n    从文件中读取数据到Properties集合，用load()方法实现 \n\n    文件已经存在：game.txt \n\n    里面有一个数据值：count=0 \n\n    通过Properties集合获取到玩游戏的次数 \n\n    判断次数是否到到3次了 \n\n    如果到了，给出提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n\n    如果不到3次： 次数+1，重新写回文件，用Properties的store()方法实现玩游戏\n\n```java\npublic class PropertiesTest {\n    public static void main(String[] args) throws IOException {\n        //从文件中读取数据到Properties集合，用load()方法实现\n        Properties prop = new Properties();\n        FileReader fr = new FileReader(\"myOtherStream\\\\game.txt\");\n        prop.load(fr);\n        fr.close();\n        //通过Properties集合获取到玩游戏的次数\n        String count = prop.getProperty(\"count\");\n        int number = Integer.parseInt(count);\n        //判断次数是否到到3次了\n        if(number >= 3) {\n            //如果到了，给出提示：游戏试玩已结束，想玩请充值(www.itcast.cn)\n            System.out.println(\"游戏试玩已结束，想玩请充值(www.itcast.cn)\");\n        } else {\n            //玩游戏\n            GuessNumber.start();\n            //次数+1，重新写回文件，用Properties的store()方法实现\n            number++;\n            prop.setProperty(\"count\",String.valueOf(number));\n            FileWriter fw = new FileWriter(\"myOtherStream\\\\game.txt\");\n            prop.store(fw,null);\n            fw.close();\n        }\n    }\n}\n```\n\n', '关于Java8的完整笔记框架知识', 1, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/9671f17c-5684-45e3-860b-c45535540dca.jpg', '0', '0', 235, '0', 1, '2023-02-21 22:16:53', 1, '2023-02-21 22:27:54', 0);
INSERT INTO `sg_article` VALUES (9, 'Java8完整笔记（下）', '# Java1.8笔记(下)\n\n# 9.多线程\n\n> 1、进程和线程\n\n* 进程：是正在运行的程序 \n\n  是系统进行**资源分配**和**调用**的**独立单位** \n\n  每一个进程都有它自己的**内存空间**和**系统资源** \n\n* 线程：是进程中的单个顺序控制流，是一条执行路径 \n\n  单线程：一个进程如果只有一条执行路径，则称为单线程程序 \n\n  多线程：一个进程如果有多条执行路径，则称为多线程程序\n\n\n\n> 2、线程的生命周期\n\n线程一共有五种状态，线程在各种状态之间转换。\n\n![image-20230131182636946](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131182636946.png)\n\n\n\n## 9.1 实现多线程\n\n> 1、概述\n\n* 多线程的实现方案有两种 \n  * 继承Thread类 \n  * 实现Runnable接口 \n* 相比继承Thread类，实现Runnable接口的好处 \n  * 避免了Java单继承的局限性 \n  * 适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现 了面向对象的设计思想\n\n\n\n> 2、实现多线程方式一：继承Thread类\n\n* 方法介绍\n\n| 方法名       | 说明                                        |\n| ------------ | ------------------------------------------- |\n| void run()   | 在线程开启后，此方法将被调用执行            |\n| void start() | 使此线程开始执行，Java虚拟机会调用run方法() |\n\n* 实现步骤\n  * 定义一个类MyThread继承Thread类 \n  * 在MyThread类中重写run()方法 \n  * 创建MyThread类的对象 \n  * 启动线程\n\n```java\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        for(int i=0; i<100; i++) {\n            System.out.println(i);\n        }\n    }\n}\npublic class MyThreadDemo {\n    public static void main(String[] args) {\n        MyThread my1 = new MyThread();\n        MyThread my2 = new MyThread();\n        // my1.run();\n        // my2.run();\n        //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法\n        my1.start();\n        my2.start();\n    }\n}\n```\n\n* 两个小问题 \n\n  * 为什么要重写run()方法？ \n\n    因为run()是用来封装被线程执行的代码 \n\n  * run()方法和start()方法的区别？ \n\n    run()：封装线程执行的代码，直接调用，相当于普通方法的调用 \n\n    start()：启动线程；然后由JVM调用此线程的run()方法\n\n> 设置和获取线程名称\n\n* 方法介绍\n\n| 方法名                    | 说明                               |\n| ------------------------- | ---------------------------------- |\n| void setName(String name) | 将此线程的名称更改为等于参数name   |\n| String getName()          | 返回此线程的名称                   |\n| Thread currentThread()    | 返回对当前正在执行的线程对象的引用 |\n\n```java\npublic class MyThread extends Thread {\n    public MyThread() {}\n    public MyThread(String name) {\n        super(name);\n    }\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(getName()+\":\"+i);\n        }\n    }\n}\npublic class MyThreadDemo {\n    public static void main(String[] args) {\n        MyThread my1 = new MyThread();\n        MyThread my2 = new MyThread();\n        //void setName(String name)：将此线程的名称更改为等于参数 name\n        my1.setName(\"高铁\");\n        my2.setName(\"飞机\");\n        //Thread(String name)\n        MyThread my1 = new MyThread(\"高铁\");\n        MyThread my2 = new MyThread(\"飞机\");\n        my1.start();\n        my2.start();\n        //static Thread currentThread() 返回对当前正在执行的线程对象的引用\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n```\n\n\n\n> 3、实现多线程方式二：实现Runnable接口\n\n* Thread构造方法\n\n| 方法名                               | 说明                   |\n| ------------------------------------ | ---------------------- |\n| Thread(Runnable target)              | 分配一个新的Thread对象 |\n| Thread(Runnable target, String name) | 分配一个新的Thread对象 |\n\n* 实现步骤\n  * 定义一个类MyRunnable实现Runnable接口 \n  * 在MyRunnable类中重写run()方法 \n  * 创建MyRunnable类的对象 \n  * 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 \n  * 启动线程\n\n```java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        for(int i=0; i<100; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n        }\n    }\n}\npublic class MyRunnableDemo {\n    public static void main(String[] args) {\n        //创建MyRunnable类的对象\n        MyRunnable my = new MyRunnable();\n        //创建Thread类的对象，把MyRunnable对象作为构造方法的参数\n        //Thread(Runnable target)\n        // Thread t1 = new Thread(my);\n        // Thread t2 = new Thread(my);\n        //Thread(Runnable target, String name)\n        Thread t1 = new Thread(my,\"高铁\");\n        Thread t2 = new Thread(my,\"飞机\");\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n\n\n## 9.2 线程优先级\n\n* 线程调度 \n\n  * 两种调度方式 \n\n    * 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 \n    * 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 \n\n  * Java使用的是抢占式调度模型 \n\n  * 随机性 \n\n    假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也 就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的\n\n* 优先级相关方法\n\n| 方法名                                  | 说明                                                         |\n| --------------------------------------- | ------------------------------------------------------------ |\n| final int getPriority()                 | 返回此线程的优先级                                           |\n| final void setPriority(int newPriority) | 更改此线程的优先级 线程默认优先级是5；线程优先级的范围是：1-10 |\n\n```java\npublic class ThreadPriority extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(getName() + \":\" + i);\n        }\n    }\n}\n\npublic class ThreadPriorityDemo {\n    public static void main(String[] args) {\n        ThreadPriority tp1 = new ThreadPriority();\n        ThreadPriority tp2 = new ThreadPriority();\n        ThreadPriority tp3 = new ThreadPriority();\n        tp1.setName(\"高铁\");\n        tp2.setName(\"飞机\");\n        tp3.setName(\"汽车\");\n        //public final int getPriority()：返回此线程的优先级\n        System.out.println(tp1.getPriority()); //5\n        System.out.println(tp2.getPriority()); //5\n        System.out.println(tp3.getPriority()); //5\n        //public final void setPriority(int newPriority)：更改此线程的优先级\n        // tp1.setPriority(10000); //IllegalArgumentException\n        System.out.println(Thread.MAX_PRIORITY); //10\n        System.out.println(Thread.MIN_PRIORITY); //1\n        System.out.println(Thread.NORM_PRIORITY); //5\n        //设置正确的优先级\n        tp1.setPriority(5);\n        tp2.setPriority(10);\n        tp3.setPriority(1);\n        tp1.start();\n        tp2.start();\n        tp3.start();\n    }\n}\n```\n\n\n\n## 9.3 线程控制\n\n* 相关方法\n\n| 方法名                         | 说明                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| static void sleep(long millis) | 使当前正在执行的线程停留（暂停执行）指定的毫秒数             |\n| void join()                    | 等待这个线程死亡                                             |\n| void setDaemon(boolean on)     | 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 |\n\n1. sleep演示：\n\n```java\npublic class ThreadSleep extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(getName() + \":\" + i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\npublic class ThreadSleepDemo {\n    public static void main(String[] args) {\n        ThreadSleep ts1 = new ThreadSleep();\n        ThreadSleep ts2 = new ThreadSleep();\n        ThreadSleep ts3 = new ThreadSleep();\n        ts1.setName(\"曹操\");\n        ts2.setName(\"刘备\");\n        ts3.setName(\"孙权\");\n        ts1.start();\n        ts2.start();\n        ts3.start();\n    }\n}\n```\n\n2. Join演示：\n\n```java\npublic class ThreadJoin extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(getName() + \":\" + i);\n        }\n    }\n}\npublic class ThreadJoinDemo {\n    public static void main(String[] args) {\n        ThreadJoin tj1 = new ThreadJoin();\n        ThreadJoin tj2 = new ThreadJoin();\n        ThreadJoin tj3 = new ThreadJoin();\n        tj1.setName(\"康熙\");\n        tj2.setName(\"四阿哥\");\n        tj3.setName(\"八阿哥\");\n        tj1.start();\n        try {\n            tj1.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        tj2.start();\n        tj3.start();\n    }\n}\n```\n\n3. Daemon演示：\n\n```java\npublic class ThreadDaemon extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(getName() + \":\" + i);\n        }\n    }\n}\npublic class ThreadDaemonDemo {\n    public static void main(String[] args) {\n        ThreadDaemon td1 = new ThreadDaemon();\n        ThreadDaemon td2 = new ThreadDaemon();\n        td1.setName(\"关羽\");\n        td2.setName(\"张飞\");\n        //设置主线程为刘备\n        Thread.currentThread().setName(\"刘备\");\n        //设置守护线程\n        td1.setDaemon(true);\n        td2.setDaemon(true);\n        td1.start();\n        td2.start();\n        for(int i=0; i<10; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n        }\n    }\n}\n```\n\n\n\n## 9.4 线程同步\n\n> 1、卖票\n\n* 案例需求\n\n  某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票\n\n* 实现步骤 \n\n  * 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets = 100; \n  * 在SellTicket类中重写run()方法实现卖票，代码步骤如下 \n  * 判断票数大于0，就卖票，并告知是哪个窗口卖的 \n  * 卖了票之后，总票数要减1 \n  * 票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行 \n  * 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 \n  * 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 \n  * 启动线程\n\n```java\npublic class SellTicket implements Runnable {\n    private int tickets = 100;\n    //在SellTicket类中重写run()方法实现卖票，代码步骤如下\n    @Override\n    public void run() {\n        while (true) {\n            if (tickets > 0) {\n                System.out.println(Thread.currentThread().getName() + \"正在出售第\" +tickets + \"张票\");\n                tickets--;\n            }\n        }\n    }\n}\npublic class SellTicketDemo {\n    public static void main(String[] args) {\n        //创建SellTicket类的对象\n        SellTicket st = new SellTicket();\n        //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称\n        Thread t1 = new Thread(st,\"窗口1\");\n        Thread t2 = new Thread(st,\"窗口2\");\n        Thread t3 = new Thread(st,\"窗口3\");\n        //启动线程\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n> 2、卖票案例的问题\n\n* 卖票出现了问题 \n\n  * 相同的票出现了多次 \n  * 出现了负数的票 \n\n* 问题产生原因 \n\n  线程执行的随机性导致的\n\n```java\npublic class SellTicket implements Runnable {\n    private int tickets = 100;\n    @Override\n    public void run() {\n        //相同的票出现了多次\n        // while (true) {\n        // //tickets = 100;\n        // //t1,t2,t3\n        // //假设t1线程抢到CPU的执行权\n        // if (tickets > 0) {\n        // //通过sleep()方法来模拟出票时间\n        // try {\n        // Thread.sleep(100);\n        // //t1线程休息100毫秒\n        // //t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒\n        // //t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒\n        // } catch (InterruptedException e) {\n        // e.printStackTrace();\n        // }\n        // //假设线程按照顺序醒过来\n        // //t1抢到CPU的执行权，在控制台输出：窗口1正在出售第100张票\n        // System.out.println(Thread.currentThread().getName() + \"正在出售第\"+ tickets + \"张票\");\n        // //t2抢到CPU的执行权，在控制台输出：窗口2正在出售第100张票\n        // //t3抢到CPU的执行权，在控制台输出：窗口3正在出售第100张票\n        // tickets--;\n        // //如果这三个线程还是按照顺序来，这里就执行了3次--的操作，最终票就变成了97\n        // }\n        // }\n        //出现了负数的票\n        while (true) {\n            //tickets = 1;\n            //t1,t2,t3\n            //假设t1线程抢到CPU的执行权\n            if (tickets > 0) {\n                //通过sleep()方法来模拟出票时间\n                try {\n                    Thread.sleep(100);\n                    //t1线程休息100毫秒\n                    //t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒\n                    //t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                //假设线程按照顺序醒过来\n                //t1抢到了CPU的执行权，在控制台输出：窗口1正在出售第1张票\n                //假设t1继续拥有CPU的执行权，就会执行tickets--;操作，tickets = 0;\n                //t2抢到了CPU的执行权，在控制台输出：窗口1正在出售第0张票\n                //假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -1;\n                //t3抢到了CPU的执行权，在控制台输出：窗口3正在出售第-1张票\n                //假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -2;\n                System.out.println(Thread.currentThread().getName() + \"正在出售第\" +tickets + \"张票\");\n                tickets--;\n            }\n        }\n    }\n}\n```\n\n\n\n### 9.4.1 同步代码块解决数据安全问题\n\n* 安全问题出现的条件 \n  * 是多线程环境 \n  * 有共享数据 \n  * 有多条语句操作共享数据 \n* 如何解决多线程安全问题呢? \n  * 基本思想：让程序没有安全问题的环境 \n* 怎么实现呢? \n  * 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可 \n  * Java提供了同步代码块的方式来解决 \n* 同步代码块格式：\n\n```java\nsynchronized(任意对象) {\n    多条语句操作共享数据的代码\n}\n```\n\n**synchronized**(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁 \n\n* 同步的好处和弊端 \n  * 好处：解决了多线程的数据安全问题 \n  * 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的 运行效率\n\n```java\npublic class SellTicket implements Runnable {\n    private int tickets = 100;\n    private Object obj = new Object();\n    @Override\n    public void run() {\n        while (true) {\n            //tickets = 100;\n            //t1,t2,t3\n            //假设t1抢到了CPU的执行权\n            //假设t2抢到了CPU的执行权\n            synchronized (obj) {\n                //t1进来后，就会把这段代码给锁起来\n                if (tickets > 0) {\n                    try {\n                        Thread.sleep(100);\n                        //t1休息100毫秒\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    //窗口1正在出售第100张票\n                    System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n                    tickets--; //tickets = 99;\n                }\n            }\n            //t1出来了，这段代码的锁就被释放了\n        }\n    }\n}\npublic class SellTicketDemo {\n    public static void main(String[] args) {\n        SellTicket st = new SellTicket();\n        Thread t1 = new Thread(st, \"窗口1\");\n        Thread t2 = new Thread(st, \"窗口2\");\n        Thread t3 = new Thread(st, \"窗口3\");\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n\n\n### 9.4.2 同步方法解决数据安全问题\n\n* 同步方法的格式 \n\n  同步方法：就是把synchronized关键字加到方法上\n\n```java\n修饰符 synchronized 返回值类型 方法名(方法参数) {\n    方法体；\n}\n```\n\n同步方法的锁对象是什么呢? **this** \n\n* 静态同步方法 \n\n  同步静态方法：就是把synchronized关键字加到静态方法上\n\n```java\n修饰符 static synchronized 返回值类型 方法名(方法参数) {\n    方法体；\n}\n```\n\n同步静态方法的锁对象是什么呢? **类名.class**\n\n```java\npublic class SellTicket implements Runnable {\n    private static int tickets = 100;\n    private int x = 0;\n    @Override\n    public void run() {\n        while (true) {\n            sellTicket()；\n        }\n    }\n    // 同步方法\n    // private synchronized void sellTicket() {\n    // if (tickets > 0) {\n    // try {\n    // Thread.sleep(100);\n    // } catch (InterruptedException e) {\n    // e.printStackTrace();\n    // }\n    // System.out.println(Thread.currentThread().getName() + \"正在出售第\" +tickets + \"张票\");\n    // tickets--;\n    // }\n    // }\n    // 静态同步方法\n    private static synchronized void sellTicket() {\n        if (tickets > 0) {\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"正在出售第\" +tickets + \"张票\");\n            tickets--;\n        }\n    }\n}\npublic class SellTicketDemo {\n    public static void main(String[] args) {\n        SellTicket st = new SellTicket();\n        Thread t1 = new Thread(st, \"窗口1\");\n        Thread t2 = new Thread(st, \"窗口2\");\n        Thread t3 = new Thread(st, \"窗口3\");\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}\n```\n\n\n\n### 9.4.3 线程安全的类\n\n* **StringBuffer** \n  * 线程安全，可变的字符序列 \n  * 从版本JDK 5开始，被StringBuilder 替代。 通常应该使用**StringBuilder**类，因为它支持所有相同的操 作，但它更快，因为它不执行同步 \n* **Vector** \n  * 从Java 2平台v1.2开始，该类改进了List接口，使其成为Java Collections Framework的成员。 与新的集合实现不同， Vector被同步。 如果不需要线程安全的实现，建议使用**ArrayList**代替Vector。 \n* **Hashtable** \n  * 该类实现了一个哈希表，它将键映射到值。 任何非null对象都可以用作键或者值 \n  * 从Java 2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collections Framework的成 员。 与新的集合实现不同， Hashtable被同步。 如果不需要线程安全的实现，建议使用**HashMap**代替 Hashtable\n\n\n\n### 9.4.4 Lock锁\n\n虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了 锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock。\n\nLock是接口不能直接实例化，这里采用它的实现类**ReentrantLock**来实例化\n\n* ReentrantLock构造方法\n\n| 方法名          | 说明                        |\n| --------------- | --------------------------- |\n| ReentrantLock() | 创建一个ReentrantLock的实例 |\n\n* 加锁解锁方法\n\n| 方法名        | 说明   |\n| ------------- | ------ |\n| void lock()   | 获得锁 |\n| void unlock() | 释放锁 |\n\n```java\npublic class SellTicket implements Runnable {\n    private int tickets = 100;\n    private Lock lock = new ReentrantLock();\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                lock.lock();\n                if (tickets > 0) {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                       System.out.println(Thread.currentThread().getName() + \"正在出售第\" + tickets + \"张票\");\n                        tickets--;\n                    }\n                } finally {\n                    lock.unlock();\n                }\n            }\n        }\n    }\n    public class SellTicketDemo {\n        public static void main(String[] args) {\n            SellTicket st = new SellTicket();\n            Thread t1 = new Thread(st, \"窗口1\");\n            Thread t2 = new Thread(st, \"窗口2\");\n            Thread t3 = new Thread(st, \"窗口3\");\n            t1.start();\n            t2.start();\n            t3.start();\n        }\n    }\n```\n\n\n\n# 10. 网络编程\n\n## 10.1 网络编程入门\n\n> 1、概述\n\n* 计算机网络 \n\n  是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系 统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 \n\n* 网络编程 \n\n  在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换\n\n> 2、网络编程三要素\n\n* IP地址 \n\n  要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数 据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 \n\n* 端口 \n\n  网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区 分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 \n\n* 协议 \n\n  通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定 的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则 被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守 才能完成数据交换。常见的协议有UDP协议和TCP协议\n\n> 3、IP地址\n\nIP地址：是网络中设备的唯一标识 \n\n* IP地址分为两大类 \n  * IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每 个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制 的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这 种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 \n  * IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发 紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8 组十六进制数，这样就解决了网络地址资源数量不够的问题 \n* DOS常用命令： \n  * ipconfig：查看本机IP地址 \n  * ping IP地址：检查网络是否连通 \n* 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用\n\n\n\n> 4、InetAddress\n\nInetAddress：此类表示Internet协议（IP）地址\n\n* 相关方法\n\n| 方法名                                    | 说明                                                         |\n| ----------------------------------------- | ------------------------------------------------------------ |\n| static InetAddress getByName(String host) | 确定主机名称的IP地址。主机名称可以是机器名称，也可以 是IP地址 |\n| String getHostName()                      | 获取此IP地址的主机名                                         |\n| String getHostAddress()                   | 返回文本显示中的IP地址字符串                                 |\n\n```java\npublic class InetAddressDemo {\n    public static void main(String[] args) throws UnknownHostException {\n        //InetAddress address = InetAddress.getByName(\"itheima\");\n        InetAddress address = InetAddress.getByName(\"192.168.1.66\");\n        //public String getHostName()：获取此IP地址的主机名\n        String name = address.getHostName();\n        //public String getHostAddress()：返回文本显示中的IP地址字符串\n        String ip = address.getHostAddress();\n        System.out.println(\"主机名：\" + name);\n        System.out.println(\"IP地址：\" + ip);\n    }\n}\n```\n\n\n\n> 5、端口和协议\n\n* 端口 \n  * 设备上应用程序的唯一标识 \n* 端口号 \n  * 用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服 务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会 导致当前程序启动失败 \n* 协议 \n  * 计算机网络中，连接和通信的规则被称为网络通信协议 \n* **UDP协议** \n  * 用户数据报协议(User Datagram Protocol) \n  * UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台 计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 \n  * 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于**音频**、**视频**和**普通数据**的传输\n  * 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太 大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在 传输重要数据时不建议使用UDP协议\n* **TCP协议** \n  * 传输控制协议 (Transmission Control Protocol) \n  * TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数 据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由 客户端向服务端发出连接请求，每次连接的创建都需要经过**“三次握手”** \n  * 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 \n    * 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 \n    * 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 \n    * 第三次握手，客户端再次向服务器端发送确认信息，确认连接 \n  * 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性， TCP协议可以保证传输数据的安全，所以应用十分广泛。例如**上传文件**、**下载文件**、**浏览网页**等\n\n\n\n## 10.2 UDP通信程序\n\n> 1、UDP发送数据\n\n* Java中的UDP通信 \n  * UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发 送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 \n  * Java提供了DatagramSocket类作为基于UDP协议的Socket\n\n* 构造方法\n\n| 方法名                                                      | 说明                                                 |\n| ----------------------------------------------------------- | ---------------------------------------------------- |\n| DatagramSocket()                                            | 创建数据报套接字并将其绑定到本机地址上的任何可用端口 |\n| DatagramPacket(byte[] buf,int len,InetAddress add,int port) | 创建数据包,发送长度为len的数据包到指定主机的指定端口 |\n\n* 相关方法\n\n| 方法名                         | 说明                   |\n| ------------------------------ | ---------------------- |\n| void send(DatagramPacket p)    | 发送数据报包           |\n| void close()                   | 关闭数据报套接字       |\n| void receive(DatagramPacket p) | 从此套接字接受数据报包 |\n\n* 发送数据的步骤\n  * 创建发送端的Socket对象(DatagramSocket) \n  * 创建数据，并把数据打包\n  * 调用DatagramSocket对象的方法发送数据 \n  * 关闭发送端\n\n```java\npublic class SendDemo {\n    public static void main(String[] args) throws IOException {\n        //创建发送端的Socket对象(DatagramSocket)\n        // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口\n        DatagramSocket ds = new DatagramSocket();\n        //创建数据，并把数据打包\n        //DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n        //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。\n        byte[] bys = \"hello,udp,我来了\".getBytes();\n        DatagramPacket dp = new\n            DatagramPacket(bys,bys.length,InetAddress.getByName(\"192.168.1.66\"),10086);\n        //调用DatagramSocket对象的方法发送数据\n        //void send(DatagramPacket p) 从此套接字发送数据报包\n        ds.send(dp);\n        //关闭发送端\n        //void close() 关闭此数据报套接字\n        ds.close();\n    }\n}\n```\n\n\n\n> 2、UDP接收数据\n\n* 接收数据的步骤 \n  * 创建接收端的Socket对象(DatagramSocket) \n  * 创建一个数据包，用于接收数据 \n  * 调用DatagramSocket对象的方法接收数据 \n  * 解析数据包，并把数据在控制台显示 \n  * 关闭接收端\n\n* 构造方法\n\n| 方法名                              | 说明                                            |\n| ----------------------------------- | ----------------------------------------------- |\n| DatagramPacket(byte[] buf, int len) | 创建一个DatagramPacket用于接收长度为len的数据包 |\n\n* 相关方法\n\n| 方法名           | 说明                                     |\n| ---------------- | ---------------------------------------- |\n| byte[] getData() | 返回数据缓冲区                           |\n| int getLength()  | 返回要发送的数据的长度或接收的数据的长度 |\n\n```java\npublic class ReceiveDemo {\n    public static void main(String[] args) throws IOException {\n        //创建接收端的Socket对象(DatagramSocket)\n        DatagramSocket ds = new DatagramSocket(12345);\n        while (true) {\n            //创建一个数据包，用于接收数据\n            byte[] bys = new byte[1024];\n            DatagramPacket dp = new DatagramPacket(bys, bys.length);\n            //调用DatagramSocket对象的方法接收数据\n            ds.receive(dp);\n            //解析数据包，并把数据在控制台显示\n            System.out.println(\"数据是：\" + new String(dp.getData(), 0,\n                                                   dp.getLength()));\n        }\n    }\n}\n```\n\n\n\n> 3、UDP通信程序练习\n\n* 案例需求\n\n  UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 \n\n  UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n\n* UDP发送数据：\n\n```java\n/*\n    UDP发送数据：\n    数据来自于键盘录入，直到输入的数据是886，发送数据结束\n*/\npublic class SendDemo {\n    public static void main(String[] args) throws IOException {\n        //创建发送端的Socket对象(DatagramSocket)\n        DatagramSocket ds = new DatagramSocket();\n        //自己封装键盘录入数据\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null) {\n            //输入的数据是886，发送数据结束\n            if (\"886\".equals(line)) {\n                break;\n            }\n            //创建数据，并把数据打包\n            byte[] bys = line.getBytes();\n            DatagramPacket dp = new DatagramPacket(bys, bys.length,\n                                                   InetAddress.getByName(\"192.168.1.66\"), 12345);\n            //调用DatagramSocket对象的方法发送数据\n            ds.send(dp);\n        }\n        //关闭发送端\n        ds.close();\n    }\n}\n```\n\n* UDP接收数据：\n\n```java\n/*\n    UDP接收数据：\n    因为接收端不知道发送端什么时候停止发送，故采用死循环接收\n*/\npublic class ReceiveDemo {\n    public static void main(String[] args) throws IOException {\n        //创建接收端的Socket对象(DatagramSocket)\n        DatagramSocket ds = new DatagramSocket(12345);\n        while (true) {\n            //创建一个数据包，用于接收数据\n            byte[] bys = new byte[1024];\n            DatagramPacket dp = new DatagramPacket(bys, bys.length);\n            //调用DatagramSocket对象的方法接收数据\n            ds.receive(dp);\n            //解析数据包，并把数据在控制台显示\n            System.out.println(\"数据是：\" + new String(dp.getData(), 0,\n                                                   dp.getLength()));\n        }\n        //关闭接收端\n        // ds.close();\n    }\n}\n```\n\n\n\n## 10.3 TCP通信程序\n\n> 1、TCP发送数据\n\n* Java中的TCP通信 \n  * Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过 Socket产生IO流来进行网络通信。 \n  * Java为客户端提供了Socket类，为服务器端提供了ServerSocket类\n\n* 构造方法\n\n| 方法名                               | 说明                                           |\n| ------------------------------------ | ---------------------------------------------- |\n| Socket(InetAddress address,int port) | 创建流套接字并将其连接到指定IP指定端口号       |\n| Socket(String host, int port)        | 创建流套接字并将其连接到指定主机上的指定端口号 |\n\n* 相关方法\n\n| 方法名                         | 说明                 |\n| ------------------------------ | -------------------- |\n| InputStream getInputStream()   | 返回此套接字的输入流 |\n| OutputStream getOutputStream() | 返回此套接字的输出流 |\n\n```java\npublic class ClientDemo {\n    public static void main(String[] args) throws IOException {\n        //创建客户端的Socket对象(Socket)\n        //Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号\n        Socket s = new Socket(\"192.168.1.66\",10000);\n        //获取输出流，写数据\n        //OutputStream getOutputStream() 返回此套接字的输出流\n        OutputStream os = s.getOutputStream();\n        os.write(\"hello,tcp,我来了\".getBytes());\n        //释放资源\n        s.close();\n    }\n}\n```\n\n\n\n> 2、TCP接收数据\n\n* 构造方法\n\n| 方法名                  | 说明                             |\n| ----------------------- | -------------------------------- |\n| ServletSocket(int port) | 创建绑定到指定端口的服务器套接字 |\n\n* 相关方法\n\n| 方法名          | 说明                           |\n| --------------- | ------------------------------ |\n| Socket accept() | 监听要连接到此的套接字并接受它 |\n\n```java\npublic class ServerDemo {\n    public static void main(String[] args) throws IOException {\n        //创建服务器端的Socket对象(ServerSocket)\n        //ServerSocket(int port) 创建绑定到指定端口的服务器套接字\n        ServerSocket ss = new ServerSocket(10000);\n        //Socket accept() 侦听要连接到此套接字并接受它\n        Socket s = ss.accept();\n        //获取输入流，读数据，并把数据显示在控制台\n        InputStream is = s.getInputStream();\n        byte[] bys = new byte[1024];\n        int len = is.read(bys);\n        String data = new String(bys,0,len);\n        System.out.println(\"数据是：\" + data);\n        //释放资源\n        s.close();\n        ss.close();\n    }\n}\n```\n\n\n\n### 10.3.1 TCP练习1\n\n* 案例需求\n\n  客户端：发送数据，接受服务器反馈 \n\n  服务器：收到消息后给出反馈 \n\n* 案例分析 \n\n  * 客户端创建对象，使用输出流输出数据 \n  * 服务端创建对象，使用输入流接受数据 \n  * 服务端使用输出流给出反馈数据 \n  * 客户端使用输入流接受反馈数据\n\n```java\npublic class ServerDemo {\n    public static void main(String[] args) throws IOException {\n        //创建服务器端的Socket对象(ServerSocket)\n        ServerSocket ss = new ServerSocket(10000);\n        //监听客户端连接，返回一个Socket对象\n        Socket s = ss.accept();\n        //获取输入流，读数据，并把数据显示在控制台\n        InputStream is = s.getInputStream();\n        byte[] bys = new byte[1024];\n        int len = is.read(bys);\n        String data = new String(bys, 0, len);\n        System.out.println(\"服务器：\" + data);\n        //给出反馈\n        OutputStream os = s.getOutputStream();\n        os.write(\"数据已经收到\".getBytes());\n        //释放资源\n        // s.close();\n        ss.close();\n    }\n}\n\npublic class ClientDemo {\n    public static void main(String[] args) throws IOException {\n        //创建客户端的Socket对象(Socket)\n        Socket s = new Socket(\"192.168.1.66\", 10000);\n        //获取输出流，写数据\n        OutputStream os = s.getOutputStream();\n        os.write(\"hello,tcp,我来了\".getBytes());\n        //接收服务器反馈\n        InputStream is = s.getInputStream();\n        byte[] bys = new byte[1024];\n        int len = is.read(bys);\n        String data = new String(bys, 0, len);\n        System.out.println(\"客户端：\" + data);\n        //释放资源\n        // is.close();\n        // os.close();\n        s.close();\n    }\n}\n```\n\n\n\n### 10.3.2 TCP练习2\n\n* 案例需求 \n\n  客户端：数据来自于键盘录入, 直到输入的数据是886，发送数据结束 \n\n  服务端：接收到数据在控制台输出 \n\n* 案例分析 \n\n  * 客户端创建对象，使用键盘录入循环接受数据，接受一行发送一行，直到键盘录入886为止 \n  * 服务端创建对象，使用输入流按行循环接受数据，直到接受到null为止\n\n```java\npublic class ClientDemo {\n    public static void main(String[] args) throws IOException {\n        //创建客户端Socket对象\n        Socket s = new Socket(\"192.168.1.66\",10000);\n        //数据来自于键盘录入，直到输入的数据是886，发送数据结束\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        //封装输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n                                               OutputStreamWriter(s.getOutputStream()));\n        String line;\n        while ((line=br.readLine())!=null) {\n            if(\"886\".equals(line)) {\n                break;\n            }\n            //获取输出流对象\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        s.close();\n    }\n}\n\npublic class ServerDemo {\n    public static void main(String[] args) throws IOException {\n        //创建服务器Socket对象\n        ServerSocket ss = new ServerSocket(10000);\n        //监听客户端的连接，返回一个对应的Socket对象\n        Socket s = ss.accept();\n        //获取输入流\n        BufferedReader br = new BufferedReader(new\n                                               InputStreamReader(s.getInputStream()));\n        String line;\n        while ((line = br.readLine()) != null) {\n            System.out.println(line);\n        }\n        //释放资源\n        ss.close();\n    }\n}\n```\n\n\n\n### 10.3.3 TCP练习3\n\n* 案例需求 \n\n  客户端：数据来自于键盘录入，直到输入的数据是886,发送数据结束 \n\n  服务端：接受到的数据写入文本文件中 \n\n* 案例分析 \n\n  * 客户端创建对象，使用键盘录入循环接受数据，接受一行发送一行，直到键盘录入886为止 \n  * 服务端创建对象，创建输出流对象指向文件，每接受一行数据后使用输出流输出到文件中，直到接受到 null为止\n\n```java\npublic class ClientDemo {\n    public static void main(String[] args) throws IOException {\n        //创建客户端Socket对象\n        Socket s = new Socket(\"192.168.1.66\",10000);\n        //数据来自于键盘录入，直到输入的数据是886，发送数据结束\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        //封装输出流对象\n        BufferedWriter bw = new BufferedWriter(new\n                                               OutputStreamWriter(s.getOutputStream()));\n        String line;\n        while ((line=br.readLine())!=null) {\n            if(\"886\".equals(line)) {\n                break;\n            }\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        s.close();\n    }\n}\n\npublic class ServerDemo {\n    public static void main(String[] args) throws IOException {\n        //创建服务器Socket对象\n        ServerSocket ss = new ServerSocket(10000);\n        //监听客户端连接，返回一个对应的Socket对象\n        Socket s = ss.accept();\n        //接收数据\n        BufferedReader br = new BufferedReader(new\n                                               InputStreamReader(s.getInputStream()));\n        //把数据写入文本文件\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"myNet\\\\s.txt\"));\n        String line;\n        while ((line=br.readLine())!=null) {\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        bw.close();\n        ss.close();\n    }\n}\n```\n\n\n\n### 10.3.4 TCP练习4\n\n* 案例需求 \n\n  客户端：数据来自于文本文件 \n\n  服务器：接收到的数据写入文本文件 \n\n* 案例分析 \n\n  * 创建客户端，创建输入流对象指向文件，从文件循环读取数据，每读取一行就使用输出流给服务器输出 一行 \n  * 创建服务端，创建输出流对象指向文件，从客户端接受数据，每接受一行就给文件中输出一行\n\n```java\npublic class ClientDemo {\n    public static void main(String[] args) throws IOException {\n        //创建客户端Socket对象\n        Socket s = new Socket(\"192.168.1.66\",10000);\n        //封装文本文件的数据\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myNet\\\\InetAddressDemo.java\"));\n        //封装输出流写数据\n        BufferedWriter bw = new BufferedWriter(new\n                                               OutputStreamWriter(s.getOutputStream()));\n        String line;\n        while ((line=br.readLine())!=null) {\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        br.close();\n        s.close();\n    }\n}\npublic class ServerDemo {\n    public static void main(String[] args) throws IOException {\n        //创建服务器Socket对象\n        ServerSocket ss = new ServerSocket(10000);\n        //监听客户端连接，返回一个对应的Socket对象\n        Socket s = ss.accept();\n        //接收数据\n        BufferedReader br = new BufferedReader(new\n                                               InputStreamReader(s.getInputStream()));\n        //把数据写入文本文件\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"myNet\\\\Copy.java\"));\n        String line;\n        while ((line=br.readLine())!=null) {\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        //释放资源\n        bw.close();\n        ss.close();\n    }\n}\n```\n\n\n\n### 10.3.5 TCP练习5\n\n* 案例需求 \n\n  客户端：数据来自于文本文件，接收服务器反馈 \n\n  服务器：接收到的数据写入文本文件，给出反馈 \n\n* 案例分析 \n\n  * 创建客户端对象，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使 用shutdownOutput()方法告知服务端传输结束 \n  * 创建服务器对象，创建输出流对象指向文件，每接受一行数据就使用输出流输出到文件中，传输结束 后。使用输出流给客户端反馈信息 \n  * 客户端接受服务端的回馈信息\n\n* 相关方法\n\n| 方法名                | 说明                               |\n| --------------------- | ---------------------------------- |\n| void shutdownInput()  | 将此套接字的输入流放置在“流的末尾” |\n| void shutdownOutput() | 禁止用此套接字的输出流             |\n\n```java\npublic class ClientDemo {\n    public static void main(String[] args) throws IOException {\n        //创建客户端Socket对象\n        Socket s = new Socket(\"192.168.1.66\",10000);\n        //封装文本文件的数据\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myNet\\\\InetAddressDemo.java\"));\n        //封装输出流写数据\n        BufferedWriter bw = new BufferedWriter(new\n                                               OutputStreamWriter(s.getOutputStream()));\n        String line;\n        while ((line=br.readLine())!=null) {\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        //public void shutdownOutput()\n        s.shutdownOutput();\n        //接收反馈\n        BufferedReader brClient = new BufferedReader(new\n                                                     InputStreamReader(s.getInputStream()));\n        String data = brClient.readLine(); //等待读取数据\n        System.out.println(\"服务器的反馈：\" + data);\n        //释放资源\n        br.close();\n        s.close();\n    }\n\n    public class ServerDemo {\n        public static void main(String[] args) throws IOException {\n            //创建服务器Socket对象\n            ServerSocket ss = new ServerSocket(10000);\n            //监听客户端连接，返回一个对应的Socket对象\n            Socket s = ss.accept();\n            //接收数据\n            BufferedReader br = new BufferedReader(new\n                                                   InputStreamReader(s.getInputStream()));\n            //把数据写入文本文件\n            BufferedWriter bw = new BufferedWriter(new FileWriter(\"myNet\\\\Copy.java\"));\n            String line;\n            while ((line=br.readLine())!=null) { //等待读取数据\n                bw.write(line);\n                bw.newLine();\n                bw.flush();\n            }\n            //给出反馈\n            BufferedWriter bwServer = new BufferedWriter(new\n                                                         OutputStreamWriter(s.getOutputStream()));\n            bwServer.write(\"文件上传成功\");\n            bwServer.newLine();\n            bwServer.flush();\n            //释放资源\n            bw.close();\n            ss.close();\n        }\n    }\n}\n```\n\n\n\n### 10.3.6 TCP练习6\n\n* 案例需求\n\n  客户端：数据来自于文本文件，接收服务器反馈 \n\n  服务器：接收到的数据写入文本文件，给出反馈，代码用线程进行封装，为每一个客户端开启一个线程 \n\n* 案例分析 \n\n  * 创建**客户端对象**，创建输入流对象指向文件，每读入一行数据就给服务器输出一行数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 \n  * 创建**多线程类**，在run()方法中读取客户端发送的数据，为了防止文件重名，使用计数器给文件名编号， 接受结束后使用输出流给客户端发送反馈信息。 \n  * 创建**服务端对象**，每监听到一个客户端则开启一个新的线程接受数据。 \n  * 客户端接受服务端的回馈信息\n\n```java\npublic class ClientDemo {\n    public static void main(String[] args) throws IOException {\n        //创建客户端Socket对象\n        Socket s = new Socket(\"192.168.1.66\",10000);\n        //封装文本文件的数据\n        BufferedReader br = new BufferedReader(new\n                                               FileReader(\"myNet\\\\InetAddressDemo.java\"));\n        //封装输出流写数据\n        BufferedWriter bw = new BufferedWriter(new\n                                               OutputStreamWriter(s.getOutputStream()));\n        String line;\n        while ((line=br.readLine())!=null) {\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        s.shutdownOutput();\n        //接收反馈\n        BufferedReader brClient = new BufferedReader(new\n                                                     InputStreamReader(s.getInputStream()));\n        String data = brClient.readLine(); //等待读取数据\n        System.out.println(\"服务器的反馈：\" + data);\n        //释放资源\n        br.close();\n        s.close();\n    }\n}\npublic class ServerThread implements Runnable {\n    private Socket s;\n    public ServerThread(Socket s) {\n        this.s = s;\n    }\n    @Override\n    public void run() {\n        try {\n            //接收数据写到文本文件\n            BufferedReader br = new BufferedReader(new\n                                                   InputStreamReader(s.getInputStream()));\n            //解决名称冲突问题\n            int count = 0;\n            File file = new File(\"myNet\\\\Copy[\"+count+\"].java\");\n            while (file.exists()) {\n                count++;\n                file = new File(\"myNet\\\\Copy[\"+count+\"].java\");\n            }\n            BufferedWriter bw = new BufferedWriter(new FileWriter(file));\n            String line;\n            while ((line=br.readLine())!=null) {\n                bw.write(line);\n                bw.newLine();\n                bw.flush();\n            }\n            //给出反馈\n            BufferedWriter bwServer = new BufferedWriter(new\n                                                         OutputStreamWriter(s.getOutputStream()));\n            bwServer.write(\"文件上传成功\");\n            bwServer.newLine();\n            bwServer.flush();\n            //释放资源\n            s.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\npublic class ServerDemo {\n    public static void main(String[] args) throws IOException {\n        //创建服务器Socket对象\n        ServerSocket ss = new ServerSocket(10000);\n        while (true) {\n            //监听客户端连接，返回一个对应的Socket对象\n            Socket s = ss.accept();\n            //为每一个客户端开启一个线程\n            new Thread(new ServerThread(s)).start();\n        }\n    }\n}\n```\n\n\n\n# 11. Lambda表达式\n\n> 1、体验Lambda表达式\n\n* 案例需求 \n\n  启动一个线程，在控制台输出一句话：多线程程序启动了 \n\n* 实现方式一 \n\n  * 实现步骤 \n    * 定义一个类MyRunnable实现Runnable接口，重写run()方法 \n    * 创建MyRunnable类的对象 \n    * 创建Thread类的对象，把MyRunnable的对象作为构造参数传递 \n    * 启动线程 \n\n* 实现方式二 \n\n  * 匿名内部类的方式改进 \n\n* 实现方式三 \n\n  * Lambda表达式的方式改进\n\n```java\n//方式一的线程类\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"多线程程序启动了\");\n    }\n}\n\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        //方式一\n        MyRunnable my = new MyRunnable();\n        Thread t = new Thread(my);\n        t.start();\n        \n        //方式二\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n            System.out.println(\"多线程程序启动了\");\n            }\n        }).start();\n        \n        //方式三\n        new Thread( () -> {\n            System.out.println(\"多线程程序启动了\");\n        } ).start();\n    }\n}\n```\n\n* 函数式编程思想概述 \n\n  函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做” \n\n  而我们要学习的Lambda表达式就是函数式思想的体现\n\n\n\n> 2、Lambda表达式的标准格式\n\n* 格式： \n\n  **(形式参数) -> {代码块}** \n\n  * 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 \n  * ->：由英文中画线和大于符号组成，固定写法。代表指向动作 \n  * 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容 \n\n* 组成Lambda表达式的三要素： \n\n  * 形式参数，箭头，代码块\n\n\n\n## 11.1 Lambda练习1\n\n* Lambda表达式的使用前提 \n\n  * 有一个接口 \n  * 接口中有且仅有一个抽象方法 \n\n* 练习描述 \n\n  无参无返回值抽象方法的练习 \n\n* 操作步骤 \n\n  * 定义一个接口(Eatable)，里面定义一个抽象方法：void eat(); \n  * 定义一个测试类(EatableDemo)，在测试类中提供两个方法 \n    * 一个方法是：useEatable(Eatable e) \n    * 一个方法是主方法，在主方法中调用useEatable方法\n\n```java\n//接口\npublic interface Eatable {\n    void eat();\n}\n\n//实现类\npublic class EatableImpl implements Eatable {\n    @Override\n    public void eat() {\n        System.out.println(\"一天一苹果，医生远离我\");\n    }\n}\n\n//测试类\npublic class EatableDemo {\n    public static void main(String[] args) {\n        //在主方法中调用useEatable方法\n        Eatable e = new EatableImpl();\n        useEatable(e);\n        \n        //匿名内部类\n        useEatable(new Eatable() {\n            @Override\n            public void eat() {\n                System.out.println(\"一天一苹果，医生远离我\");\n            }\n        });\n        \n        //Lambda表达式\n        useEatable(() -> {\n            System.out.println(\"一天一苹果，医生远离我\");\n        });\n    }\n    private static void useEatable(Eatable e) {\n        e.eat();\n    }\n}\n```\n\n\n\n## 11.2 Lambda练习2\n\n* 练习描述 \n\n  有参无返回值抽象方法的练习 \n\n* 操作步骤 \n\n  * 定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s); \n  * 定义一个测试类(FlyableDemo)，在测试类中提供两个方法 \n    * 一个方法是：useFlyable(Flyable f) \n    * 一个方法是主方法，在主方法中调用useFlyable方法\n\n```java\npublic interface Flyable {\n    void fly(String s);\n}\n\npublic class FlyableDemo {\n    public static void main(String[] args) {\n        //在主方法中调用useFlyable方法\n        \n        //匿名内部类\n        useFlyable(new Flyable() {\n            @Override\n            public void fly(String s) {\n                System.out.println(s);\n                System.out.println(\"飞机自驾游\");\n            }\n        });\n        System.out.println(\"--------\");\n        \n        //Lambda\n        useFlyable((String s) -> {\n            System.out.println(s);\n            System.out.println(\"飞机自驾游\");\n        });\n    }\n    private static void useFlyable(Flyable f) {\n        f.fly(\"风和日丽，晴空万里\");\n    }\n}\n```\n\n\n\n## 11.3 Lambda练习3\n\n* 练习描述 \n\n  有参有返回值抽象方法的练习 \n\n* 操作步骤 \n\n  * 定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y); \n  * 定义一个测试类(AddableDemo)，在测试类中提供两个方法 \n    * 一个方法是：useAddable(Addable a) \n    * 一个方法是主方法，在主方法中调用useAddable方法\n\n```java\npublic interface Addable {\n    int add(int x,int y);\n}\npublic class AddableDemo {\n    public static void main(String[] args) {\n        //在主方法中调用useAddable方法\n        useAddable((int x,int y) -> {\n            return x + y;\n        });\n    }\n    private static void useAddable(Addable a) {\n        int sum = a.add(10, 20);\n        System.out.println(sum);\n    }\n}\n```\n\n\n\n## 11.4 Lambda表达式的省略模式\n\n* 省略的规则 \n  * 参数类型可以省略。但是有多个参数的情况下，不能只省略一个 \n  * 如果参数有且仅有一个，那么小括号可以省略 \n  * 如果代码块的语句只有一条，可以省略大括号和分号，和return关键字\n\n```java\npublic interface Addable {\n    int add(int x, int y);\n}\n\npublic interface Flyable {\n    void fly(String s);\n}\n\npublic class LambdaDemo {\n    public static void main(String[] args) {\n        // useAddable((int x,int y) -> {\n        // return x + y;\n        // });\n        \n        //参数的类型可以省略\n        useAddable((x, y) -> {\n            return x + y;\n        });\n     \n        // useFlyable((String s) -> {\n        // System.out.println(s);\n        // });\n        \n        //如果参数有且仅有一个，那么小括号可以省略\n        // useFlyable(s -> {\n        // System.out.println(s);\n        // });\n        \n        //如果代码块的语句只有一条，可以省略大括号和分号\n        useFlyable(s -> System.out.println(s));\n        //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉\n        useAddable((x, y) -> x + y);\n    }\n    \n    private static void useFlyable(Flyable f) {\n        f.fly(\"风和日丽，晴空万里\");\n    }\n    \n    private static void useAddable(Addable a) {\n        int sum = a.add(10, 20);\n        System.out.println(sum);\n    }\n}\n```\n\n\n\n## 11.5 Lambda表达式的注意事项\n\n* 使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法 \n\n* 必须有上下文环境，才能推导出Lambda对应的接口 \n\n  * 根据局部变量的赋值得知Lambda对应的接口 \n\n    Runnable r = () -> System.out.println(\"Lambda表达式\"); \n\n  * 根据调用方法的参数得知Lambda对应的接口\n\n    new Thread(() -> System.out.println(\"Lambda表达式\")).start();\n\n\n\n>Lambda表达式和匿名内部类的区别\n\n* 所需类型不同 \n  * 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 \n  * Lambda表达式：只能是接口 \n* 使用限制不同 \n  * 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 \n  * 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 \n* 实现原理不同 \n  * 匿名内部类：编译之后，产生一个单独的.class字节码文件 \n  * Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成\n\n\n\n# 12. 方法引用\n\n> 1、概述\n\n* 方法引用的出现原因 \n\n  在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作 \n\n  那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要 \n\n  那我们又是如何使用已经存在的方案的呢？ \n\n  这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案\n\n```java\npublic interface Printable {\n    void printString(String s);\n}\npublic class PrintableDemo {\n    public static void main(String[] args) {\n        //在主方法中调用usePrintable方法\n        // usePrintable((String s) -> {\n        // System.out.println(s);\n        // });\n        //Lambda简化写法\n        usePrintable(s -> System.out.println(s));\n        //方法引用\n        usePrintable(System.out::println);\n    }\n    private static void usePrintable(Printable p) {\n        p.printString(\"爱生活爱Java\");\n    }\n}\n```\n\n> 2、方法引用符\n\n* 方法引用符 \n\n  **::** 该符号为引用运算符，而它所在的表达式被称为方法引用 \n\n* 推导与省略 \n\n  * 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式， 它们都将被自动推导 \n  * 如果使用方法引用，也是同样可以根据上下文进行推导 \n  * 方法引用是Lambda的孪生兄弟\n\n\n\n## 12.1 引用类方法\n\n引用类方法，其实就是引用类的静态方法\n\n* 格式 \n\n  类名::静态方法 \n\n* 范例 \n\n  Integer::parseInt \n\n  Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据 \n\n* 练习描述 \n\n  * 定义一个接口(Converter)，里面定义一个抽象方法 int convert(String s); \n  * 定义一个测试类(ConverterDemo)，在测试类中提供两个方法\n    * 一个方法是：useConverter(Converter c) 、\n    * 一个方法是主方法，在主方法中调用useConverter方法\n\n```java\npublic interface Converter {\n    int convert(String s);\n}\n\npublic class ConverterDemo {\n    public static void main(String[] args) {\n        //Lambda写法\n        useConverter(s -> Integer.parseInt(s));\n        \n        //引用类方法\n        useConverter(Integer::parseInt);\n    }\n    \n    private static void useConverter(Converter c) {\n        int number = c.convert(\"666\");\n        System.out.println(number);\n    }\n}\n```\n\n* 使用说明 \n\n  Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数\n\n\n\n## 12.2 引用对象的实例方法\n\n引用对象的实例方法，其实就引用类中的成员方法 \n\n* 格式 \n\n  对象::成员方法 \n\n* 范例 \n\n  \"HelloWorld\"::toUpperCase \n\n  String类中的方法：public String toUpperCase() 将此String所有字符转换为大写 \n\n* 练习描述 \n\n  * 定义一个类(PrintString)，里面定义一个方法 \n\n  * public void printUpper(String s)：把字符串参数变成大写的数据，然后在控制台输出 \n\n  * 定义一个接口(Printer)，里面定义一个抽象方法 \n\n    void printUpperCase(String s) \n\n  * 定义一个测试类(PrinterDemo)，在测试类中提供两个方法 \n\n    * 一个方法是：usePrinter(Printer p) \n    * 一个方法是主方法，在主方法中调用usePrinter方法\n\n```java\npublic class PrintString {\n    //把字符串参数变成大写的数据，然后在控制台输出\n    public void printUpper(String s) {\n        String result = s.toUpperCase();\n        System.out.println(result);\n    }\n}\npublic interface Printer {\n    void printUpperCase(String s);\n}\npublic class PrinterDemo {\n    public static void main(String[] args) {\n        //Lambda简化写法\n        usePrinter(s -> System.out.println(s.toUpperCase()));\n        //引用对象的实例方法\n        PrintString ps = new PrintString();\n        usePrinter(ps::printUpper);\n    }\n    private static void usePrinter(Printer p) {\n        p.printUpperCase(\"HelloWorld\");\n    }\n}\n```\n\n\n\n## 12.3 引用类的实例方法\n\n引用类的实例方法，其实就是引用类中的成员方法 \n\n* 格式 \n\n  类名::成员方法 \n\n* 范例 \n\n  String::substring \n\n  public String substring(int beginIndex,int endIndex) \n\n  从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex \n\n* 练习描述 \n\n  * 定义一个接口(MyString)，里面定义一个抽象方法： \n\n    String mySubString(String s,int x,int y); \n\n  * 定义一个测试类(MyStringDemo)，在测试类中提供两个方法 \n\n    * 一个方法是：useMyString(MyString my)\n    * 一个方法是主方法，在主方法中调用useMyString方法\n\n```java\npublic interface MyString {\n    String mySubString(String s,int x,int y);\n}\npublic class MyStringDemo {\n    public static void main(String[] args) {\n        //Lambda简化写法\n        useMyString((s,x,y) -> s.substring(x,y));\n        \n        //引用类的实例方法\n        useMyString(String::substring);\n    }\n    private static void useMyString(MyString my) {\n        String s = my.mySubString(\"HelloWorld\", 2, 5);\n        System.out.println(s);\n    }\n}\n```\n\n* 使用说明 \n\n  Lambda表达式被类的实例方法替代的时候 第一个参数作为调用者 后面的参数全部传递给该方法作为参数\n\n\n\n## 12.4 引用构造器\n\n引用构造器，其实就是引用构造方法 \n\n* l格式 \n\n  类名::new \n\n* 范例 \n\n  Student::new \n\n* 练习描述 \n\n  * 定义一个**类**(Student)，里面有两个成员变量(name,age) \n\n    并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法 \n\n  * 定义一个**接口**(StudentBuilder)，里面定义一个抽象方法 \n\n    Student build(String name,int age); \n\n  * 定义一个**测试类**(StudentDemo)，在测试类中提供两个方法 \n\n    * 一个方法是：useStudentBuilder(StudentBuilder s) \n    * 一个方法是主方法，在主方法中调用useStudentBuilder方法\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\npublic interface StudentBuilder {\n    Student build(String name,int age);\n}\n\npublic class StudentDemo {\n    public static void main(String[] args) {\n        //Lambda简化写法\n        useStudentBuilder((name,age) -> new Student(name,age));\n        //引用构造器\n        useStudentBuilder(Student::new);\n    }\n    private static void useStudentBuilder(StudentBuilder sb) {\n        Student s = sb.build(\"林青霞\", 30);\n        System.out.println(s.getName() + \",\" + s.getAge());\n    }\n}\n```\n\n* 使用说明 \n\n  Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数\n\n\n\n# 13. 函数式接口\n\n> 1、概述\n\n* 概念 \n\n  有且仅有一个抽象方法的接口 \n\n* 如何检测一个接口是不是函数式接口 \n\n  @FunctionalInterface \n\n  放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败 \n\n* 注意事项 我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解\n\n\n\n> 2、函数式接口作为方法的参数\n\n* 需求描述 \n\n  定义一个类(RunnableDemo)，在类中提供两个方法 \n\n  一个方法是：startThread(Runnable r) 方法参数Runnable是一个函数式接口 \n\n  一个方法是主方法，在主方法中调用startThread方法\n\n```java\npublic class RunnableDemo {\n    public static void main(String[] args) {\n        //在主方法中调用startThread方法\n        \n        //匿名内部类的方式\n        startThread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName() + \"线程启动了\");\n            }\n        });\n        \n        //Lambda方式\n        startThread(() -> System.out.println(Thread.currentThread().getName() + \"线程启动了\"));\n    }\n    private static void startThread(Runnable r) {\n        new Thread(r).start();\n    }\n}\n```\n\n\n\n> 3、函数式接口作为方法的返回值\n\n* 需求描述 \n\n  定义一个类(ComparatorDemo)，在类中提供两个方法 \n\n  一个方法是：Comparator getComparator() 方法返回值Comparator是一个函数式接口 \n\n  一个方法是主方法，在主方法中调用getComparator方法\n\n```java\npublic class ComparatorDemo {\n    public static void main(String[] args) {\n        //定义集合，存储字符串元素\n        ArrayList<String> array = new ArrayList<String>();\n        array.add(\"cccc\");\n        array.add(\"aa\");\n        array.add(\"b\");\n        array.add(\"ddd\");\n        System.out.println(\"排序前：\" + array);\n        Collections.sort(array, getComparator());\n        System.out.println(\"排序后：\" + array);\n    }\n    private static Comparator<String> getComparator() {\n        //匿名内部类的方式实现\n        // return new Comparator<String>() {\n        // @Override\n        // public int compare(String s1, String s2) {\n        // return s1.length()-s2.length();\n        // }\n        // };\n        //Lambda方式实现\n        return (s1, s2) -> s1.length() - s2.length();\n    }\n}\n```\n\n* 以下是常用的函数式接口\n\n\n\n## 13.1 Supplier接口\n\n* Supplier接口 \n\n  Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产 什么类型的数据供我们使用。 \n\n* 常用方法 \n\n  只有一个无参的方法\n\n| 方法名  | 说明                                             |\n| ------- | ------------------------------------------------ |\n| T get() | 按照某种实现逻辑(由Lambda表达式实现)返回一个数据 |\n\n```java\npublic class SupplierDemo {\n    public static void main(String[] args) {\n        String s = getString(() -> \"林青霞\");\n        System.out.println(s);\n        Integer i = getInteger(() -> 30);\n        System.out.println(i);\n    }\n    //定义一个方法，返回一个整数数据\n    private static Integer getInteger(Supplier<Integer> sup) {\n        return sup.get();\n    }\n    //定义一个方法，返回一个字符串数据\n    private static String getString(Supplier<String> sup) {\n        return sup.get();\n    }\n}\n```\n\n>Supplier接口练习之获取最大值\n\n* 案例需求 \n\n  定义一个类(SupplierTest)，在类中提供两个方法 \n\n  一个方法是：int getMax(Supplier sup) 用于返回一个int数组中的最大值 \n\n  一个方法是主方法，在主方法中调用getMax方法\n\n```java\npublic class SupplierTest {\n    public static void main(String[] args) {\n        //定义一个int数组\n        int[] arr = {19, 50, 28, 37, 46};\n        int maxValue = getMax(()-> {\n            int max = arr[0];\n            for(int i=1; i<arr.length; i++) {\n                if(arr[i] > max) {\n                    max = arr[i];\n                }\n            }\n            return max;\n        });\n        System.out.println(maxValue);\n    }\n    //返回一个int数组中的最大值\n    private static int getMax(Supplier<Integer> sup) {\n        return sup.get();\n    }\n}\n```\n\n\n\n## 13.2 Consumer接口\n\n* Consumer接口 \n\n  Consumer接口也被称为消费型接口，它消费的数据的数据类型由泛型指定\n\n* 常用方法\n\n  Consumer：包含两个方法\n\n| 方法名                                   | 说明                                                      |\n| ---------------------------------------- | --------------------------------------------------------- |\n| void accept(T t)                         | 对给定的参数执行此操作                                    |\n| default Consumer andThen(Consumer after) | 返回一个组合的Consumer，依次执行此操作，然后执行after操作 |\n\n```java\npublic class ConsumerDemo {\n    public static void main(String[] args) {\n        //操作一\n        operatorString(\"林青霞\", s -> System.out.println(s));\n        //操作二\n        operatorString(\"林青霞\", s -> System.out.println(new\n                                                      StringBuilder(s).reverse().toString()));\n        System.out.println(\"--------\");\n        //传入两个操作使用andThen完成\n        operatorString(\"林青霞\", s -> System.out.println(s), s ->\n                       System.out.println(new StringBuilder(s).reverse().toString()));\n    }\n    \n    //定义一个方法，用不同的方式消费同一个字符串数据两次\n    private static void operatorString(String name, Consumer<String> con1,\n                                       Consumer<String> con2) {\n        // con1.accept(name);\n        // con2.accept(name);\n        con1.andThen(con2).accept(name);\n    }\n    \n    //定义一个方法，消费一个字符串数据\n    private static void operatorString(String name, Consumer<String> con) {\n        con.accept(name);\n    }\n}\n```\n\n>Consumer接口练习之按要求打印信息\n\n* 案例需求 \n\n  String[] strArray = {\"林青霞,30\", \"张曼玉,35\", \"王祖贤,33\"}; \n\n  字符串数组中有多条信息，请按照格式：“姓名：XX,年龄：XX\"的格式将信息打印出来 \n\n* 要求：\n\n  * 把打印姓名的动作作为第一个Consumer接口的Lambda实例 \n  * 把打印年龄的动作作为第二个Consumer接口的Lambda实例 \n  * 将两个Consumer接口按照顺序组合到一起使用\n\n```java\npublic class ConsumerTest {\n    public static void main(String[] args) {\n        String[] strArray = {\"林青霞,30\", \"张曼玉,35\", \"王祖贤,33\"};\n        printInfo(strArray, str -> System.out.print(\"姓名：\" + str.split(\",\")[0]),\n                  str -> System.out.println(\",年龄：\" +\n                                            Integer.parseInt(str.split(\",\")[1])));\n    }\n    private static void printInfo(String[] strArray, Consumer<String> con1,\n                                  Consumer<String> con2) {\n        for (String str : strArray) {\n            con1.andThen(con2).accept(str);\n        }\n    }\n}\n```\n\n\n\n## 13.3 Predicate接口\n\n* Predicate接口 \n\n  Predicate接口通常用于判断参数是否满足指定的条件\n\n* 常用方法\n\n| 方法名                                 | 说明                                                         |\n| -------------------------------------- | ------------------------------------------------------------ |\n| boolean test(T t)                      | 对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回 一个布尔值 |\n| default Predicate negate()             | 返回一个逻辑的否定，对应逻辑非                               |\n| default Predicate and(Predicate other) | 返回一个组合判断，对应短路与                                 |\n| default Predicate or(Predicate other)  | 返回一个组合判断，对应短路或                                 |\n\n```java\npublic class PredicateDemo01 {\n    public static void main(String[] args) {\n        boolean b1 = checkString(\"hello\", s -> s.length() > 8);\n        System.out.println(b1);\n        boolean b2 = checkString(\"helloworld\",s -> s.length() > 8);\n        System.out.println(b2);\n    }\n    //判断给定的字符串是否满足要求\n    private static boolean checkString(String s, Predicate<String> pre) {\n        // return !pre.test(s);\n        return pre.negate().test(s);\n    }\n}\n\npublic class PredicateDemo02 {\n    public static void main(String[] args) {\n        boolean b1 = checkString(\"hello\", s -> s.length() > 8);\n        System.out.println(b1);\n        boolean b2 = checkString(\"helloworld\", s -> s.length() > 8);\n        System.out.println(b2);\n        boolean b3 = checkString(\"hello\",s -> s.length() > 8, s -> s.length() <\n                                 15);\n        System.out.println(b3);\n        boolean b4 = checkString(\"helloworld\",s -> s.length() > 8, s -> s.length()\n                                 < 15);\n        System.out.println(b4);\n    }\n    //同一个字符串给出两个不同的判断条件，最后把这两个判断的结果做逻辑与运算的结果作为最终的结果\n    private static boolean checkString(String s, Predicate<String> pre1,\n                                       Predicate<String> pre2) {\n        return pre1.or(pre2).test(s);\n    }\n    //判断给定的字符串是否满足要求\n    private static boolean checkString(String s, Predicate<String> pre) {\n        return pre.test(s);\n    }\n}\n```\n\n>Predicate接口练习之筛选满足条件数据\n\n* 练习描述 \n  * String[] strArray = {\"林青霞,30\", \"柳岩,34\", \"张曼玉,35\", \"貂蝉,31\", \"王祖贤,33\"}; \n  * 字符串数组中有多条信息，请通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中，并遍历ArrayList集合 \n  * 同时满足如下要求：姓名长度大于2；年龄大于33 \n* 分析 \n  * 有两个判断条件,所以需要使用两个Predicate接口,对条件进行判断 \n  * 必须同时满足两个条件,所以可以使用and方法连接两个判断条件\n\n```java\npublic class PredicateTest {\n    public static void main(String[] args) {\n        String[] strArray = {\"林青霞,30\", \"柳岩,34\", \"张曼玉,35\", \"貂蝉,31\", \"王祖贤,33\"};\n        ArrayList<String> array = myFilter(strArray, s -> s.split(\",\")[0].length()>2,s -> Integer.parseInt(s.split(\",\")[1]) > 33);\n        for (String str : array) {\n            System.out.println(str);\n        }\n    }\n    //通过Predicate接口的拼装将符合要求的字符串筛选到集合ArrayList中\n    private static ArrayList<String> myFilter(String[] strArray, Predicate<String> pre1, Predicate<String> pre2) {\n        //定义一个集合\n        ArrayList<String> array = new ArrayList<String>();\n        //遍历数组\n        for (String str : strArray) {\n            if (pre1.and(pre2).test(str)) {\n                array.add(str);\n            }\n        }\n        return array;\n    }\n}\n\n```\n\n\n\n## 13.4 Function接口\n\n* Function接口 \n\n  Function接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值\n\n* 常用方法\n\n| 方法名                                   | 说明                                                         |\n| ---------------------------------------- | ------------------------------------------------------------ |\n| R apply(T t)                             | 将此函数应用于给定的参数                                     |\n| default Function andThen(Function after) | 返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果 |\n\n```java\npublic class FunctionDemo {\n    public static void main(String[] args) {\n        //操作一\n        convert(\"100\",s -> Integer.parseInt(s));\n        //操作二\n        convert(100,i -> String.valueOf(i + 566));\n        //使用andThen的方式连续执行两个操作\n        convert(\"100\", s -> Integer.parseInt(s), i -> String.valueOf(i + 566));\n    }\n    //定义一个方法，把一个字符串转换int类型，在控制台输出\n    private static void convert(String s, Function<String,Integer> fun) {\n        // Integer i = fun.apply(s);\n        int i = fun.apply(s);\n        System.out.println(i);\n    }\n    //定义一个方法，把一个int类型的数据加上一个整数之后，转为字符串在控制台输出\n    private static void convert(int i, Function<Integer,String> fun) {\n        String s = fun.apply(i);\n        System.out.println(s);\n    }\n    //定义一个方法，把一个字符串转换int类型，把int类型的数据加上一个整数之后，转为字符串在控制台输出\n    private static void convert(String s, Function<String,Integer> fun1,\n                                Function<Integer,String> fun2) {\n        String ss = fun1.andThen(fun2).apply(s);\n        System.out.println(ss);\n    }\n}\n\n```\n\n>Function接口练习之按照指定要求操作数据\n\n* 练习描述 \n\n  * String s = \"林青霞,30\"; \n\n  * 请按照我指定的要求进行操作： \n\n    1:将字符串截取得到数字年龄部分 \n\n    2:将上一步的年龄字符串转换成为int类型的数据 \n\n    3:将上一步的int数据加70，得到一个int结果，在控制台输出 \n\n  * 请通过Function接口来实现函数拼接\n\n```java\npublic class FunctionTest {\n    public static void main(String[] args) {\n        String s = \"林青霞,30\";\n        convert(s, ss -> ss.split(\",\")[1], Integer::parseInt, i -> i + 70);\n    }\n    private static void convert(String s, Function<String, String> fun1,\n                                Function<String, Integer> fun2, Function<Integer, Integer> fun3) {\n        int i = fun1.andThen(fun2).andThen(fun3).apply(s);\n        System.out.println(i);\n    }\n}\n```\n\n\n\n# 14. Stream流\n\n* 案例需求 \n\n  按照下面的要求完成集合的创建和遍历 \n\n  * 创建一个集合，存储多个字符串元素 \n  * 把集合中所有以\"张\"开头的元素存储到一个新的集合 \n  * 把\"张\"开头的集合中的长度为3的元素存储到一个新的集合 \n  * 遍历上一步得到的集合\n\n* 原始方式示例代码\n\n```java\npublic class StreamDemo {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"林青霞\");\n        list.add(\"张曼玉\");\n        list.add(\"王祖贤\");\n        list.add(\"柳岩\");\n        list.add(\"张敏\");\n        list.add(\"张无忌\");\n        \n        //把集合中所有以\"张\"开头的元素存储到一个新的集合\n        ArrayList<String> zhangList = new ArrayList<String>();\n        for(String s : list) {\n            if(s.startsWith(\"张\")) {\n                zhangList.add(s);\n            }\n        }\n        // System.out.println(zhangList);\n        \n        //把\"张\"开头的集合中的长度为3的元素存储到一个新的集合\n        ArrayList<String> threeList = new ArrayList<String>();\n        for(String s : zhangList) {\n            if(s.length() == 3) {\n                threeList.add(s);\n            }\n        }\n        // System.out.println(threeList);\n        \n        //遍历上一步得到的集合\n        for(String s : threeList) {\n            System.out.println(s);\n        }\n        System.out.println(\"--------\");\n        \n        //Stream流来改进\n        // list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() ==\n        3).forEach(s -> System.out.println(s));\n        list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() ==\n                                                            3).forEach(System.out::println);\n    }\n}\n```\n\n* 使用Stream流示例代码\n\n```java\npublic class StreamDemo {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"林青霞\");\n        list.add(\"张曼玉\");\n        list.add(\"王祖贤\");\n        list.add(\"柳岩\");\n        list.add(\"张敏\");\n        list.add(\"张无忌\");\n        //Stream流来改进\n        list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() ==\n                                                            3).forEach(System.out::println);\n    }\n}\n```\n\n* Stream流的好处 \n  * 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 \n  * Stream流把真正的函数式编程风格引入到Java中\n\n\n\n## 14.1 Stream流的常见生成方式\n\n* Stream流的思想\n\n![image-20230201132306658](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230201132306658.png)\n\n* 生成Stream流的方式 \n\n  * Collection体系集合 \n\n    使用默认方法stream()生成流， default Stream stream() \n\n  * Map体系集合 \n\n    把Map转成Set集合，间接的生成流 \n\n  * 数组 \n\n    通过Stream接口的静态方法of(T... values)生成流\n\n```java\npublic class StreamDemo {\n    public static void main(String[] args) {\n        //Collection体系的集合可以使用默认方法stream()生成流\n        List<String> list = new ArrayList<String>();\n        Stream<String> listStream = list.stream();\n        Set<String> set = new HashSet<String>();\n        Stream<String> setStream = set.stream();\n        \n        //Map体系的集合间接的生成流\n        Map<String,Integer> map = new HashMap<String, Integer>();\n        Stream<String> keyStream = map.keySet().stream();\n        Stream<Integer> valueStream = map.values().stream();\n        Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream();\n        \n        //数组可以通过Stream接口的静态方法of(T... values)生成流\n        String[] strArray = {\"hello\",\"world\",\"java\"};\n        Stream<String> strArrayStream = Stream.of(strArray);\n        Stream<String> strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\");\n        Stream<Integer> intStream = Stream.of(10, 20, 30);\n    }\n}\n```\n\n\n\n## 14.2 Stream流中间操作方法\n\n* 概述\n\n  中间操作的意思是，执行完此方法之后，Stream流依然可以继续执行其他操作。\n\n* 常见方法\n\n| 方法名                                   | 说明                                                       |\n| ---------------------------------------- | ---------------------------------------------------------- |\n| Stream filter(Predicate predicate)       | 用于对流中的数据进行过滤                                   |\n| Stream limit(long maxSize)               | 返回此流中的元素组成的流，截取前指定参数个数的数据         |\n| Stream skip(long n)                      | 跳过指定参数个数的数据，返回由该流的剩余元素组成的流       |\n| static Stream concat(Stream a, Stream b) | 合并a和b两个流为一个流                                     |\n| Stream distinct()                        | 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 |\n| Stream sorted()                          | 返回由此流的元素组成的流，根据自然顺序排序                 |\n| Stream sorted(Comparator comparator)     | 返回由该流的元素组成的流，根据提供的Comparator进行排序     |\n| Stream map(Function mapper)              | 返回由给定函数应用于此流的元素的结果组成的流               |\n| IntStream mapToInt(ToIntFunction mapper) | 返回一个IntStream其中包含将给定函数应用于此流的元素的结果  |\n\n* filter代码演示\n\n```java\npublic class StreamDemo01 {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"林青霞\");\n        list.add(\"张曼玉\");\n        list.add(\"王祖贤\");\n        list.add(\"柳岩\");\n        list.add(\"张敏\");\n        list.add(\"张无忌\");\n        \n        //需求1：把list集合中以张开头的元素在控制台输出\n        list.stream().filter(s -> s.startsWith(\"张\")).forEach(System.out::println);\n        System.out.println(\"--------\");\n        \n        //需求2：把list集合中长度为3的元素在控制台输出\n        list.stream().filter(s -> s.length() == 3).forEach(System.out::println);\n        System.out.println(\"--------\");\n        \n        //需求3：把list集合中以张开头的，长度为3的元素在控制台输出\n        list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() ==\n                                                            3).forEach(System.out::println);\n    }\n}\n```\n\n* limit&skip代码演示\n\n```java\npublic class StreamDemo02 {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"林青霞\");\n        list.add(\"张曼玉\");\n        list.add(\"王祖贤\");\n        list.add(\"柳岩\");\n        list.add(\"张敏\");\n        list.add(\"张无忌\");\n        //需求1：取前3个数据在控制台输出\n        list.stream().limit(3).forEach(System.out::println);\n        System.out.println(\"--------\");\n        //需求2：跳过3个元素，把剩下的元素在控制台输出\n        list.stream().skip(3).forEach(System.out::println);\n        System.out.println(\"--------\");\n        //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出\n        list.stream().skip(2).limit(2).forEach(System.out::println);\n    }\n}\n```\n\n* concat&distinct代码演示\n\n```java\npublic class StreamDemo03 {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"林青霞\");\n        list.add(\"张曼玉\");\n        list.add(\"王祖贤\");\n        list.add(\"柳岩\");\n        list.add(\"张敏\");\n        list.add(\"张无忌\");\n        //需求1：取前4个数据组成一个流\n        Stream<String> s1 = list.stream().limit(4);\n        //需求2：跳过2个数据组成一个流\n        Stream<String> s2 = list.stream().skip(2);\n        //需求3：合并需求1和需求2得到的流，并把结果在控制台输出\n        // Stream.concat(s1,s2).forEach(System.out::println);\n        //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复\n        Stream.concat(s1,s2).distinct().forEach(System.out::println);\n    }\n}\n```\n\n* sorted代码演示\n\n```java\npublic class StreamDemo04 {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"linqingxia\");\n        list.add(\"zhangmanyu\");\n        list.add(\"wangzuxian\");\n        list.add(\"liuyan\");\n        list.add(\"zhangmin\");\n        list.add(\"zhangwuji\");\n        //需求1：按照字母顺序把数据在控制台输出\n        // list.stream().sorted().forEach(System.out::println);\n        //需求2：按照字符串长度把数据在控制台输出\n        list.stream().sorted((s1,s2) -> {\n            int num = s1.length()-s2.length();\n            int num2 = num==0?s1.compareTo(s2):num;\n            return num2;\n        }).forEach(System.out::println);\n    }\n}\n```\n\n* map&mapToInt代码演示\n\n```java\npublic class StreamDemo05 {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"10\");\n        list.add(\"20\");\n        list.add(\"30\");\n        list.add(\"40\");\n        list.add(\"50\");\n        //需求：将集合中的字符串数据转换为整数之后在控制台输出\n        // list.stream().map(s -> Integer.parseInt(s)).forEach(System.out::println);\n        // list.stream().map(Integer::parseInt).forEach(System.out::println);\n        // list.stream().mapToInt(Integer::parseInt).forEach(System.out::println);\n        //int sum() 返回此流中元素的总和\n        int result = list.stream().mapToInt(Integer::parseInt).sum();\n        System.out.println(result);\n    }\n}\n```\n\n\n\n## 14.3 Stream流终结操作方法\n\n* 概念 \n\n  终结操作的意思是，执行完此方法之后，Stream流将不能再执行其他操作。\n\n* 常见方法\n\n| 方法名                        | 说明                     |\n| ----------------------------- | ------------------------ |\n| void forEach(Consumer action) | 对此流的每个元素执行操作 |\n| long count()                  | 返回此流中的元素数       |\n\n```java\npublic class StreamDemo {\n    public static void main(String[] args) {\n        //创建一个集合，存储多个字符串元素\n        ArrayList<String> list = new ArrayList<String>();\n        list.add(\"林青霞\");\n        list.add(\"张曼玉\");\n        list.add(\"王祖贤\");\n        list.add(\"柳岩\");\n        list.add(\"张敏\");\n        list.add(\"张无忌\");\n        //需求1：把集合中的元素在控制台输出\n        // list.stream().forEach(System.out::println);\n        //需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出\n        long count = list.stream().filter(s -> s.startsWith(\"张\")).count();\n        System.out.println(count);\n    }\n}\n```\n\n\n\n## 14.4 Stream流的收集操作\n\n* 概念 \n\n  对数据使用Stream流的方式操作完毕后，可以把流中的数据收集到集合中。\n\n* 常见方法\n\n| 方法名                         | 说明               |\n| ------------------------------ | ------------------ |\n| R collect(Collector collector) | 把结果收集到集合中 |\n\n* 工具类Collectors提供了具体的收集方式\n\n| 方法名                                                       | 说明                   |\n| ------------------------------------------------------------ | ---------------------- |\n| public static Collector toList()                             | 把元素收集到List集合中 |\n| public static Collector toSet()                              | 把元素收集到Set集合中  |\n| public static Collector toMap(Function keyMapper,Function valueMapper) | 把元素收集到Map集合中  |\n\n```java\npublic class CollectDemo {\n    public static void main(String[] args) {\n        //创建List集合对象\n        List<String> list = new ArrayList<String>();\n        list.add(\"林青霞\");\n        list.add(\"张曼玉\");\n        list.add(\"王祖贤\");\n        list.add(\"柳岩\");\n        /*\n        //需求1：得到名字为3个字的流\n        Stream<String> listStream = list.stream().filter(s -> s.length() == 3);\n        //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历\n        List<String> names = listStream.collect(Collectors.toList());\n        for(String name : names) {\n        System.out.println(name);\n        }\n        */\n        //创建Set集合对象\n        Set<Integer> set = new HashSet<Integer>();\n        set.add(10);\n        set.add(20);\n        set.add(30);\n        set.add(33);\n        set.add(35);\n        /*\n        //需求3：得到年龄大于25的流\n        Stream<Integer> setStream = set.stream().filter(age -> age > 25);\n        //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历\n        Set<Integer> ages = setStream.collect(Collectors.toSet());\n        for(Integer age : ages) {\n        System.out.println(age);\n        }\n        */\n        //定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组合而成\n        String[] strArray = {\"林青霞,30\", \"张曼玉,35\", \"王祖贤,33\", \"柳岩,25\"};\n        //需求5：得到字符串中年龄数据大于28的流\n        Stream<String> arrayStream = Stream.of(strArray).filter(s ->\n                                                                Integer.parseInt(s.split(\",\")[1]) > 28);\n        //需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值\n        Map<String, Integer> map = arrayStream.collect(Collectors.toMap(s ->\n                                                                        s.split(\",\")[0], s -> Integer.parseInt(s.split(\",\")[1])));\n        Set<String> keySet = map.keySet();\n        for (String key : keySet) {\n            Integer value = map.get(key);\n            System.out.println(key + \",\" + value);\n        }\n    }\n}\n```\n\n\n\n# 15. 类加载器\n\n## 15.1 类加载\n\n* 类加载的描述 \n  * 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始 化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化\n* 类的加载\n  * 就是指将class文件读入内存，并为之创建一个 java.lang.Class 对象 \n  * 任何类被使用时，系统都会为之建立一个 java.lang.Class 对象 \n* 类的连接 \n  * **验证阶段**：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致 \n  * **准备阶段**：负责为类的类变量分配内存，并设置默认初始化值 \n  * **解析阶段**：将类的二进制数据中的符号引用替换为直接引用 \n* 类的初始化 \n  * 在该阶段，主要就是对类变量进行初始化 \n* 类的初始化步骤 \n  * 假如类还未被加载和连接，则程序先加载并连接该类 \n  * 假如该类的直接父类还未被初始化，则先初始化其直接父类 \n  * 假如类中有初始化语句，则系统依次执行这些初始化语句 \n  * 注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3 \n* 类的初始化时机 \n  * 创建类的实例 \n  * 调用类的类方法 \n  * 访问类或者接口的类变量，或者为该类变量赋值 \n  * 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 \n  * 初始化某个类的子类 直接使用java.exe命令来运行某个主类\n\n\n\n## 15.2 类加载器\n\n> 1、类加载器的作用\n\n* 负责将.class文件加载到内存中，并为之生成对应的 java.lang.Class 对象。虽然我们不用过分关心类加载机 制，但是了解这个机制我们就能更好的理解程序的运行！\n\n> 2、JVM的类加载机制\n\n* 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载 器负责载入，除非显示使用另外一个类加载器来载入 \n* 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器 无法加载该类时才尝试从自己的类路径中加载该类 \n* 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜 索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区\n\n> 3、Java中的内置类加载器\n\n* **Bootstrap class loader**：它是虚拟机的内置类加载器，通常表示为null ，并且没有父null \n* **Platform class loader**：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先定义的Java SE平台API，其实现类和JDK特定的运行时类 \n* **System class loader**：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常用于定义应 用程序类路径，模块路径和JDK特定工具上的类 \n* 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap\n\n> 4、ClassLoader 中的两个方法\n\n* 方法分类\n\n| 方法名                                    | 说明                       |\n| ----------------------------------------- | -------------------------- |\n| static ClassLoader getSystemClassLoader() | 返回用于委派的系统类加载器 |\n| ClassLoader getParent()                   | 返回父类加载器进行委派     |\n\n```java\npublic class ClassLoaderDemo {\n    public static void main(String[] args) {\n        //static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器\n        ClassLoader c = ClassLoader.getSystemClassLoader();\n        System.out.println(c); //AppClassLoader\n        //ClassLoader getParent()：返回父类加载器进行委派\n        ClassLoader c2 = c.getParent();\n        System.out.println(c2); //PlatformClassLoader\n        ClassLoader c3 = c2.getParent();\n        System.out.println(c3); //null\n    }\n}\n```\n\n\n\n# 16. 反射\n\n> 概述\n\n* 是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。 由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展\n\n\n\n## 16.1 获取Class类对象的三种方式\n\n* 三种方式分类\n  * 类名.class属性 \n  * 对象名.getClass()方法\n  * Class.forName(全类名)方法\n\n```java\npublic class ReflectDemo {\n    public static void main(String[] args) throws ClassNotFoundException {\n        //使用类的class属性来获取该类对应的Class对象\n        Class<Student> c1 = Student.class;\n        System.out.println(c1);\n        Class<Student> c2 = Student.class;\n        System.out.println(c1 == c2);\n        System.out.println(\"--------\");\n        //调用对象的getClass()方法，返回该对象所属类对应的Class对象\n        Student s = new Student();\n        Class<? extends Student> c3 = s.getClass();\n        System.out.println(c1 == c3);\n        System.out.println(\"--------\");\n        //使用Class类中的静态方法forName(String className)\n        Class<?> c4 = Class.forName(\"com.itheima_02.Student\");\n        System.out.println(c1 == c4);\n    }\n}\n```\n\n\n\n## 16.2 反射获取构造方法\n\n> 1、Class类获取构造方法对象的方法\n\n| 方法名                                                      | 说明                           |\n| ----------------------------------------------------------- | ------------------------------ |\n| Constructor[] getConstructors()                             | 返回所有公共构造方法对象的数组 |\n| Constructor[] getDeclaredConstructors()                     | 返回所有构造方法对象的数组     |\n| Constructor getConstructor(Class... parameterTypes)         | 返回单个公共构造方法对象       |\n| Constructor getDeclaredConstructor(Class... parameterTypes) | 返回单个构造方法对象           |\n\n```java\npublic class ReflectDemo01 {\n    public static void main(String[] args) throws ClassNotFoundException,\n    NoSuchMethodException, IllegalAccessException, InvocationTargetException,\n    InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName(\"com.itheima_02.Student\");\n        //Constructor<?>[] getConstructors() 返回一个包含 Constructor对象的数组，Constructor对象反映了由该 Class对象表示的类的所有公共构造函数\n        // Constructor<?>[] cons = c.getConstructors();\n        //Constructor<?>[] getDeclaredConstructors() 返回反映由该 Class对象表示的类声明的所有构造函数的 Constructor对象的数组\n        Constructor<?>[] cons = c.getDeclaredConstructors();\n        for(Constructor con : cons) {\n            System.out.println(con);\n        }\n        System.out.println(\"--------\");\n        //Constructor<T> getConstructor(Class<?>... parameterTypes) 返回一个Constructor对象，该对象反映由该 Class对象表示的类的指定公共构造函数\n        //Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) 返回一个 Constructor对象，该对象反映由此 Class对象表示的类或接口的指定构造函数\n        //参数：你要获取的构造方法的参数的个数和数据类型对应的字节码文件对象\n        Constructor<?> con = c.getConstructor();\n        //Constructor提供了一个类的单个构造函数的信息和访问权限\n        //T newInstance(Object... initargs) 使用由此 Constructor对象表示的构造函数，使用指定的初始化参数来创建和初始化构造函数的声明类的新实例\n        Object obj = con.newInstance();\n        System.out.println(obj);\n        // Student s = new Student();\n        // System.out.println(s);\n    }\n}\n```\n\n\n\n> 2、Constructor类用于创建对象的方法\n\n| 方法名                           | 说明                       |\n| -------------------------------- | -------------------------- |\n| T newInstance(Object...initargs) | 根据指定的构造方法创建对象 |\n\n\n\n> 3、反射获取构造方法并使用练习1\n\n* 案例需求 \n  * 通过反射获取公共的构造方法并创建对象 \n\n* 学生类\n\n```java\npublic class Student {\n    //成员变量：一个私有，一个默认，一个公共\n    private String name;\n    int age;\n    public String address;\n    //构造方法：一个私有，一个默认，两个公共\n    public Student() {\n    }\n    private Student(String name) {\n        this.name = name;\n    }\n    Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public Student(String name, int age, String address) {\n        this.name = name;\n        this.age = age;\n        this.address = address;\n    }\n    //成员方法：一个私有，四个公共\n    private void function() {\n        System.out.println(\"function\");\n    }\n    public void method1() {\n        System.out.println(\"method\");\n    }\n    public void method2(String s) {\n        System.out.println(\"method:\" + s);\n    }\n    public String method3(String s, int i) {\n        return s + \",\" + i;\n    }\n    @Override\n    public String toString() {\n        return \"Student{\" +\n            \"name=\'\" + name + \'\\\'\' +\n            \", age=\" + age +\n            \", address=\'\" + address + \'\\\'\' +\n            \'}\';\n    }\n}\n```\n\n* 测试类\n\n```java\npublic class ReflectDemo02 {\n    public static void main(String[] args) throws ClassNotFoundException,\n    NoSuchMethodException, IllegalAccessException, InvocationTargetException,\n    InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName(\"com.itheima_02.Student\");\n        //public Student(String name, int age, String address)\n        //Constructor<T> getConstructor(Class<?>... parameterTypes)\n        Constructor<?> con = c.getConstructor(String.class, int.class,\n                                              String.class);\n        //基本数据类型也可以通过.class得到对应的Class类型\n        //T newInstance(Object... initargs)\n        Object obj = con.newInstance(\"林青霞\", 30, \"西安\");\n        System.out.println(obj);\n    }\n}\n```\n\n\n\n> 4、反射获取构造方法并使用练习2\n\n* 案例需求 \n  * 通过反射获取私有构造方法并创建对象 \n* 学生类：参见上方学生类 \n* 测试类\n\n```java\npublic class ReflectDemo03 {\n    public static void main(String[] args) throws ClassNotFoundException,\n    NoSuchMethodException, IllegalAccessException, InvocationTargetException,\n    InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName(\"com.itheima_02.Student\");\n        //private Student(String name)\n        //Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)\n        Constructor<?> con = c.getDeclaredConstructor(String.class);\n        //暴力反射\n        //public void setAccessible(boolean flag):值为true，取消访问检查\n        con.setAccessible(true);\n        Object obj = con.newInstance(\"林青霞\");\n        System.out.println(obj);\n    }\n}\n```\n\n\n\n## 16.3 反射获取成员变量\n\n> 1、Class类获取成员变量对象的方法\n\n* 方法分类\n\n| 方法名                              | 说明                           |\n| ----------------------------------- | ------------------------------ |\n| Field[] getFields()                 | 返回所有公共成员变量对象的数组 |\n| Field[] getDeclaredFields()         | 返回所有成员变量对象的数组     |\n| Field getField(String name)         | 返回单个公共成员变量对象       |\n| Field getDeclaredField(String name) | 返回单个成员变量对象           |\n\n```java\npublic class ReflectDemo01 {\n    public static void main(String[] args) throws ClassNotFoundException,\n    NoSuchFieldException, NoSuchMethodException, IllegalAccessException,\n    InvocationTargetException, InstantiationException {\n        //获取Class对象\n        Class<?> c = Class.forName(\"com.itheima_02.Student\");\n        //Field[] getFields() 返回一个包含 Field对象的数组， Field对象反映由该 Class对象表示的类或接口的所有可访问的公共字段\n        //Field[] getDeclaredFields() 返回一个 Field对象的数组，反映了由该 Class对象表示的类或接口声明的所有字段\n        // Field[] fields = c.getFields();\n        Field[] fields = c.getDeclaredFields();\n        for(Field field : fields) {\n            System.out.println(field);\n        }\n        System.out.println(\"--------\");\n        //Field getField(String name) 返回一个 Field对象，该对象反映由该 Class对象表示的类或接口的指定公共成员字段\n        //Field getDeclaredField(String name) 返回一个 Field对象，该对象反映由该Class对象表示的类或接口的指定声明字段\n        Field addressField = c.getField(\"address\");\n        //获取无参构造方法创建对象\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n        // obj.addressField = \"西安\";\n        //Field提供有关类或接口的单个字段的信息和动态访问\n        //void set(Object obj, Object value) 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值\n        addressField.set(obj,\"西安\"); //给obj的成员变量addressField赋值为西安\n        System.out.println(obj);\n        // Student s = new Student();\n        // s.address = \"西安\";\n        // System.out.println(s);\n    }\n}\n```\n\n\n\n> 2、Field类用于给成员变量赋值的方法\n\n| 方法名                           | 说明                           |\n| -------------------------------- | ------------------------------ |\n| voidset(Object obj,Object value) | 给obj对象的成员变量赋值为value |\n\n\n\n> 3、反射获取成员变量并使用练习\n\n* 案例需求 \n  * 通过反射获取成员变量并赋值 \n* 学生类：参见上方学生类 \n* 测试类\n\n```java\npublic class ReflectDemo02 {\n    public static void main(String[] args) throws Exception {\n        //获取Class对象\n        Class<?> c = Class.forName(\"com.itheima_02.Student\");\n        //Student s = new Student();\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n        System.out.println(obj);\n        //s.name = \"林青霞\";\n        // Field nameField = c.getField(\"name\"); //NoSuchFieldException:\n        name\n            Field nameField = c.getDeclaredField(\"name\");\n        nameField.setAccessible(true);\n        nameField.set(obj, \"林青霞\");\n        System.out.println(obj);\n        //s.age = 30;\n        Field ageField = c.getDeclaredField(\"age\");\n        ageField.setAccessible(true);\n        ageField.set(obj,30);\n        System.out.println(obj);\n        //s.address = \"西安\";\n        Field addressField = c.getDeclaredField(\"address\");\n        addressField.setAccessible(true);\n        addressField.set(obj,\"西安\");\n        System.out.println(obj);\n    }\n}\n```\n\n\n\n## 16.4 反射获取成员方法\n\n> 1、Class类获取成员方法对象的方法\n\n* 方法分类\n\n| 方法名                                                       | 说明                                        |\n| ------------------------------------------------------------ | ------------------------------------------- |\n| Method[] getMethods()                                        | 返回所有公共成员方法对象的数组，包 括继承的 |\n| Method[] getDeclaredMethods()                                | 返回所有成员方法对象的数组，不包括 继承的   |\n| Method getMethod(String name, Class... parameterTypes)       | 返回单个公共成员方法对象                    |\n| Method getDeclaredMethod(String name, Class... parameterTypes) | 返回单个成员方法对象                        |\n\n```java\npublic class ReflectDemo01 {\n    public static void main(String[] args) throws Exception {\n        //获取Class对象\n        Class<?> c = Class.forName(\"com.itheima_02.Student\");\n        //Method[] getMethods() 返回一个包含 方法对象的数组， 方法对象反映由该 Class对象表示的类或接口的所有公共方法，包括由类或接口声明的对象以及从超类和超级接口继承的类\n        //Method[] getDeclaredMethods() 返回一个包含 方法对象的数组， 方法对象反映由Class对象表示的类或接口的所有声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承方法\n        // Method[] methods = c.getMethods();\n        Method[] methods = c.getDeclaredMethods();\n        for(Method method : methods) {\n            System.out.println(method);\n        }\n        System.out.println(\"--------\");\n        //Method getMethod(String name, Class<?>... parameterTypes) 返回一个 方法对象，该对象反映由该 Class对象表示的类或接口的指定公共成员方法\n        //Method getDeclaredMethod(String name, Class<?>... parameterTypes) 返回一个方法对象，它反映此表示的类或接口的指定声明的方法 Class对象\n        //public void method1()\n        Method m = c.getMethod(\"method1\");\n        //获取无参构造方法创建对象\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n        // obj.m();\n        //在类或接口上提供有关单一方法的信息和访问权限\n        //Object invoke(Object obj, Object... args) 在具有指定参数的指定对象上调用此方法对象表示的基础方法\n        //Object：返回值类型\n        //obj：调用方法的对象\n        //args：方法需要的参数\n        m.invoke(obj);\n        // Student s = new Student();\n        // s.method1();\n    }\n}\n```\n\n\n\n> 2、Method类用于执行方法的方法\n\n| 方法名                                  | 说明                                                 |\n| --------------------------------------- | ---------------------------------------------------- |\n| Objectinvoke(Object obj,Object... args) | 调用obj对象的成员方法，参数是args,返回值是Object类型 |\n\n> 3、反射获取成员方法并使用练习\n\n* 案例需求 \n  * 通过反射获取成员方法并调用 \n* 学生类：参见上方学生类 \n* 测试类\n\n```java\npublic class ReflectDemo02 {\n    public static void main(String[] args) throws Exception {\n        //获取Class对象\n        Class<?> c = Class.forName(\"com.itheima_02.Student\");\n        //Student s = new Student();\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n        //s.method1();\n        Method m1 = c.getMethod(\"method1\");\n        m1.invoke(obj);\n        //s.method2(\"林青霞\");\n        Method m2 = c.getMethod(\"method2\", String.class);\n        m2.invoke(obj,\"林青霞\");\n        // String ss = s.method3(\"林青霞\",30);\n        // System.out.println(ss);\n        Method m3 = c.getMethod(\"method3\", String.class, int.class);\n        Object o = m3.invoke(obj, \"林青霞\", 30);\n        System.out.println(o);\n        //s.function();\n        // Method m4 = c.getMethod(\"function\"); //NoSuchMethodException:\n        com.itheima_02.Student.function()\n            Method m4 = c.getDeclaredMethod(\"function\");\n        m4.setAccessible(true);\n        m4.invoke(obj);\n    }\n}\n```\n\n\n\n# 17. 模块化\n\n> 1、概述\n\nJava语言随着这些年的发展已经成为了一门影响深远的编程语言，无数平台，系统都采用Java语言编写。但是，伴 随着发展，Java也越来越庞大，逐渐发展成为一门“臃肿” 的语言。而且，无论是运行一个大型的软件系统，还是运 行一个小的程序，即使程序只需要使用Java的部分核心功能， JVM也要加载整个JRE环境。 为了给Java“瘦身”，让 Java实现轻量化，Java 9正式的推出了模块化系统。Java被拆分为N多个模块，并允许Java程序可以根据需要选择加 载程序必须的Java模块，这样就可以让Java以轻量化的方式来运行 \n\n其实，Java 7的时候已经提出了模块化的概念，但由于其过于复杂，Java 7，Java 8都一直未能真正推出，直到Java 9才真正成熟起来。对于Java语言来说，模块化系统是一次真正的自我革新，这种革新使得“古老而庞大”的Java语言 重新焕发年轻的活力\n\n\n\n## 17.1 模块的基本使用\n\n1. 在项目中创建两个模块。一个是myOne,一个是myTwo \n2. 在myOne模块中创建以下包和以下类，并在类中添加方法\n\n![image-20230131230119666](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230119666.png)\n\n![image-20230131230131695](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230131695.png)\n\n3. 在myTwo模块中创建以下包和以下类，并在类中创建对象并使用\n\n![image-20230131230148413](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230148413.png)\n\n![image-20230131230159601](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230159601.png)\n\n4. 在myOne模块中src目录下，创建module-info.java，并写入以下内容\n\n![image-20230131230223095](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230223095.png)\n\n5. 在myTwo模块中src目录下，创建module-info.java，并写入以下内容\n\n![image-20230131230239462](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230239462.png)\n\n\n\n## 17.2 模块服务的基本使用\n\n1. 在myOne模块中新建一个包，提供一个接口和两个实现类\n\n![image-20230131230306063](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230306063.png)\n\n![image-20230131230315017](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230315017.png)\n\n![image-20230131230327025](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230327025.png)\n\n2. 在myOne模块中修改module-info.java文件，添加以下内容\n\n![image-20230131230342771](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230342771.png)\n\n3. 在myTwo模块中新建一个测试类\n\n![image-20230131230405128](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230405128.png)\n\n![image-20230131230414626](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230414626.png)\n\n4. 在myTwo模块中修改module-info.java文件，添加以下内容\n\n![image-20230131230436780](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131230436780.png)\n\n\n\n# 18.经典案例\n\n## 18.1 生产者消费者(多线程)\n\n* 概述 \n\n  生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的 理解更加深刻。\n\n  所谓生产者消费者问题，实际上主要是包含了两类线程： \n\n  一类是生产者线程用于生产数据 \n\n  一类是消费者线程用于消费数据 \n\n  为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库 \n\n  生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为 \n\n  消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为\n\n![image-20230131224502173](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230131224502173.png)\n\n* Object类的等待和唤醒方法\n\n| 方法名           | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| void wait()      | 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 |\n| void notify()    | 唤醒正在等待对象监视器的单个线程                             |\n| void notifyAll() | 唤醒正在等待对象监视器的所有线程                             |\n\n* 案例需求 \n\n  生产者消费者案例中包含的类： \n\n  奶箱类(Box)：定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作 \n\n  生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶的操作 \n\n  消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶的操作 \n\n  测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下 \n\n  ①创建奶箱对象，这是共享数据区域 \n\n  ②创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作 \n\n  ③对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作 \n\n  ④创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 \n\n  ⑤启动线程\n\n```java\npublic class Box {\n    //定义一个成员变量，表示第x瓶奶\n    private int milk;\n    //定义一个成员变量，表示奶箱的状态\n    private boolean state = false;\n    //提供存储牛奶和获取牛奶的操作\n    public synchronized void put(int milk) {\n        //如果有牛奶，等待消费\n        if(state) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        //如果没有牛奶，就生产牛奶\n        this.milk = milk;\n        System.out.println(\"送奶工将第\" + this.milk + \"瓶奶放入奶箱\");\n        //生产完毕之后，修改奶箱状态\n        state = true;\n        //唤醒其他等待的线程\n        notifyAll();\n    }\n    public synchronized void get() {\n        //如果没有牛奶，等待生产\n        if(!state) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        //如果有牛奶，就消费牛奶\n        System.out.println(\"用户拿到第\" + this.milk + \"瓶奶\");\n        //消费完毕之后，修改奶箱状态\n        state = false;\n        //唤醒其他等待的线程\n        notifyAll();\n    }\n}\npublic class Producer implements Runnable {\n    private Box b;\n    public Producer(Box b) {\n        this.b = b;\n    }\n    @Override\n    public void run() {\n        for(int i=1; i<=30; i++) {\n            b.put(i);\n        }\n    }\n}\npublic class Customer implements Runnable {\n    private Box b;\n    public Customer(Box b) {\n        this.b = b;\n    }\n    @Override\n    public void run() {\n        while (true) {\n            b.get();\n        }\n    }\n}\npublic class BoxDemo {\n    public static void main(String[] args) {\n        //创建奶箱对象，这是共享数据区域\n        Box b = new Box();\n        //创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作\n        Producer p = new Producer(b);\n        //创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作\n        Customer c = new Customer(b);\n        //创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递\n        Thread t1 = new Thread(p);\n        Thread t2 = new Thread(c);\n        //启动线程\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n\n\n## 18.2 Stream流综合练习(Stream流)\n\n* 案例需求 \n\n  现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 \n\n  * 男演员只要名字为3个字的前三人 \n  * 女演员只要姓林的，并且不要第一个 \n  * 把过滤后的男演员姓名和女演员姓名合并到一起 \n  * 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 \n\n  演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法\n\n```java\npublic class Actor {\n    private String name;\n    public Actor(String name) {\n        this.name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\npublic class StreamTest {\n    public static void main(String[] args) {\n        //创建集合\n        ArrayList<String> manList = new ArrayList<String>();\n        manList.add(\"周润发\");\n        manList.add(\"成龙\");\n        manList.add(\"刘德华\");\n        manList.add(\"吴京\");\n        manList.add(\"周星驰\");\n        manList.add(\"李连杰\");\n        ArrayList<String> womanList = new ArrayList<String>();\n        womanList.add(\"林心如\");\n        womanList.add(\"张曼玉\");\n        womanList.add(\"林青霞\");\n        womanList.add(\"柳岩\");\n        womanList.add(\"林志玲\");\n        womanList.add(\"王祖贤\");\n        /*\n        //男演员只要名字为3个字的前三人\n        Stream<String> manStream = manList.stream().filter(s -> s.length() ==\n        3).limit(3);\n        //女演员只要姓林的，并且不要第一个\n        Stream<String> womanStream = womanList.stream().filter(s ->\n        s.startsWith(\"林\")).skip(1);\n        //把过滤后的男演员姓名和女演员姓名合并到一起\n        Stream<String> stream = Stream.concat(manStream, womanStream);\n        //把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\n        // stream.map(Actor::new).forEach(System.out::println);\n        stream.map(Actor::new).forEach(p -> System.out.println(p.getName()));\n        */\n        Stream.concat(manList.stream().filter(s -> s.length() == 3).limit(3),\n                      womanList.stream().filter(s ->\n                                                s.startsWith(\"林\")).skip(1)).map(Actor::new).\n            forEach(p -> System.out.println(p.getName()));\n    }\n}\n```\n\n\n\n## 18.3 反射的案例(反射)\n\n> 1、反射练习之越过泛型检查\n\n* 案例需求 \n  * 通过反射技术，向一个泛型为Integer的集合中添加一些字符串数据\n\n```java\npublic class ReflectTest01 {\n    public static void main(String[] args) throws Exception {\n        //创建集合\n        ArrayList<Integer> array = new ArrayList<Integer>();\n        \n        // array.add(10);\n        // array.add(20);\n        // array.add(\"hello\");\n        \n        Class<? extends ArrayList> c = array.getClass();\n        Method m = c.getMethod(\"add\", Object.class);\n        m.invoke(array,\"hello\");\n        m.invoke(array,\"world\");\n        m.invoke(array,\"java\");\n        System.out.println(array);\n    }\n}\n```\n\n\n\n> 2、运行配置文件中指定类的指定方法\n\n* 案例需求 \n  * 通过反射运行配置文件中指定类的指定方法\n\n```java\npublic class ReflectTest02 {\n    public static void main(String[] args) throws Exception {\n        //加载数据\n        Properties prop = new Properties();\n        FileReader fr = new FileReader(\"myReflect\\\\class.txt\");\n        prop.load(fr);\n        fr.close();\n        /*\n        className=com.itheima_06.Student\n        methodName=study\n        */\n        String className = prop.getProperty(\"className\");\n        String methodName = prop.getProperty(\"methodName\");\n        //通过反射来使用\n        Class<?> c = Class.forName(className);//com.itheima_06.Student\n        Constructor<?> con = c.getConstructor();\n        Object obj = con.newInstance();\n        Method m = c.getMethod(methodName);//study\n        m.invoke(obj);\n    }\n}\n```\n\n\n\n\n\n', '关于Java8的完整笔记架构知识', 1, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/4f4f0fae-81ba-4471-a955-3f7cec5555bb.png', '0', '0', 255, '0', 1, '2023-02-21 22:18:58', 1, '2023-02-21 22:18:58', 0);
INSERT INTO `sg_article` VALUES (10, 'JUC完整笔记', '# JUC\n\n## 1. 什么是JUC\n\n学习方法：源码+官方文档\n\n> JUC是 java util concurrent\n\n* 面试高频问JUC~！\n\n![20200727195421667](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195421667.png)\n\njava.util 是Java的一个工具包~\n\n**业务：普通的线程代码 Thread**\n\n**Runnable：** 没有返回值、效率相比于**Callable** 相对较低！\n\n![20200727195447249](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195447249.png)\n\n\n\n## 2. 线程和进程\n\n> 1、概述\n\n**进程：一个程序，QQ.EXE Music.EXE；数据+代码+pcb**\n\n一个进程可以包含多个线程，至少包含一个线程！\n\nJava默认有几个线程？**2个线程！** main线程、GC线程\n\n**线程：开了一个进程Typora，写字，等待几分钟会进行自动保存(线程负责的)**\n\n对于Java而言：Thread、Runable、Callable进行开启线程的，我们之前。\n\n**提问？JAVA真的可以开启线程吗？ 开不了的！**\n\n```java\n    public synchronized void start() {\n        /**\n         * This method is not invoked for the main method thread or \"system\"\n         * group threads created/set up by the VM. Any new functionality added\n         * to this method in the future may have to also be added to the VM.\n         *\n         * A zero status value corresponds to state \"NEW\".\n         */\n        if (threadStatus != 0)\n            throw new IllegalThreadStateException();\n\n        /* Notify the group that this thread is about to be started\n         * so that it can be added to the group\'s list of threads\n         * and the group\'s unstarted count can be decremented. */\n        group.add(this);\n\n        boolean started = false;\n        try {\n            start0();\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);\n                }\n            } catch (Throwable ignore) {\n                /* do nothing. If start0 threw a Throwable then\n                  it will be passed up the call stack */\n            }\n        }\n    }\n	//这是一个C++底层，Java是没有权限操作底层硬件的\n    private native void start0();\n```\n\nJava是没有权限去开启线程、操作硬件的，这是一个native的一个本地方法，它调用的底层的C++代码。\n\n\n\n> 2、并发、并行\n\n**并发：** 多线程操作同一个资源。\n\n- CPU 只有一核，模拟出来多条线程，天下武功，唯快不破。那么我们就可以使用CPU快速交替，来模拟多线程。\n\n**并行：** 多个人一起行走\n\n- CPU多核，多个线程可以同时执行。 我们可以使用线程池！\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        //获取cpu的核数\n        System.out.println(Runtime.getRuntime().availableProcessors());\n    }\n}\n```\n\n并发编程的本质：**充分利用CPU的资源！**\n\n\n\n> 3、线程有几个状态？\n\n线程的状态：6个状态\n\n```java\npublic enum State {\n        /**\n         * Thread state for a thread which has not yet started.\n         */\n    	//运行\n        NEW,\n\n        /**\n         * Thread state for a runnable thread.  A thread in the runnable\n         * state is executing in the Java virtual machine but it may\n         * be waiting for other resources from the operating system\n         * such as processor.\n         */\n    	//运行\n        RUNNABLE,\n\n        /**\n         * Thread state for a thread blocked waiting for a monitor lock.\n         * A thread in the blocked state is waiting for a monitor lock\n         * to enter a synchronized block/method or\n         * reenter a synchronized block/method after calling\n         * {@link Object#wait() Object.wait}.\n         */\n    	//阻塞\n        BLOCKED,\n\n        /**\n         * Thread state for a waiting thread.\n         * A thread is in the waiting state due to calling one of the\n         * following methods:\n         * <ul>\n         *   <li>{@link Object#wait() Object.wait} with no timeout</li>\n         *   <li>{@link #join() Thread.join} with no timeout</li>\n         *   <li>{@link LockSupport#park() LockSupport.park}</li>\n         * </ul>\n         *\n         * <p>A thread in the waiting state is waiting for another thread to\n         * perform a particular action.\n         *\n         * For example, a thread that has called <tt>Object.wait()</tt>\n         * on an object is waiting for another thread to call\n         * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on\n         * that object. A thread that has called <tt>Thread.join()</tt>\n         * is waiting for a specified thread to terminate.\n         */\n    	//等待\n        WAITING,\n\n        /**\n         * Thread state for a waiting thread with a specified waiting time.\n         * A thread is in the timed waiting state due to calling one of\n         * the following methods with a specified positive waiting time:\n         * <ul>\n         *   <li>{@link #sleep Thread.sleep}</li>\n         *   <li>{@link Object#wait(long) Object.wait} with timeout</li>\n         *   <li>{@link #join(long) Thread.join} with timeout</li>\n         *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>\n         *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>\n         * </ul>\n         */\n    	//超时等待\n        TIMED_WAITING,\n\n        /**\n         * Thread state for a terminated thread.\n         * The thread has completed execution.\n         */\n    	//终止\n        TERMINATED;\n    }\n```\n\n\n\n> 4、wait/sleep的区别\n\n**1、来自不同的类**\n\nwait => Object\n\nsleep => Thread\n\n一般情况企业中使用休眠是：\n\n```java\nTimeUnit.DAYS.sleep(1); //休眠1天\nTimeUnit.SECONDS.sleep(1); //休眠1s\n```\n\n**2、关于锁的释放**\n\nwait 会释放锁；\n\nsleep睡觉了，不会释放锁；\n\n**3、使用的范围是不同的**\n\nwait 必须在同步代码块中；\n\nsleep 可以在任何地方睡；\n\n**4、是否需要捕获异常**\n\nwait是不需要捕获异常；\n\nsleep必须要捕获异常；\n\n\n\n## 3. Lock锁【重点】\n\n> 1、传统的Synchronized\n\n```java\n/**\n * 真正的多线程开发\n * 线程就是一个单独的资源类，没有任何的附属操作！\n */\npublic class SaleTicketDemo01 {\n    public static void main(String[] args) {\n        //多线程操作\n        //并发：多线程操作同一个资源类，把资源类丢入线程\n        Ticket ticket = new Ticket();\n\n        //@FunctionalInterface 函数式接口 jdk1.8之后 lambda表达式\n        new Thread(()->{\n            for(int i=0;i<40;i++){\n                ticket.sale();\n            }\n        },\"A\").start();\n        new Thread(()->{\n            for(int i=0;i<40;i++){\n                ticket.sale();\n            }\n        },\"B\").start();\n        new Thread(()->{\n            for(int i=0;i<40;i++){\n                ticket.sale();\n            }\n        },\"C\").start();\n    }\n}\n//资源类\n//属性+方法\n//oop\nclass Ticket{\n    private int number=50;\n\n\n    //卖票的方式\n    // synchronized 本质：队列，锁\n    public synchronized void sale(){\n        if(number>0){\n            System.out.println(Thread.currentThread().getName()+\" 卖出了第\"+number+\" 张票,剩余：\"+number+\" 张票\");\n            number--;\n        }\n    }\n}\n\n```\n\n\n\n> 2、Lock接口\n\n![20200727195732117](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195732117.png)\n\n![2020080112041218](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020080112041218.png)\n\n![20200727195818181](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727195818181.png)\n\n**公平锁：** 十分公平，必须先来后到~；\n\n**非公平锁：** 十分不公平，可以插队；**(默认为非公平锁)**\n\n```java\npublic class SaleTicketDemo02 {\n    public static void main(String[] args) {\n        //多线程操作\n        //并发：多线程操作同一个资源类，把资源类丢入线程\n        Ticket2 ticket = new Ticket2();\n        new Thread(()->{for(int i=0;i<40;i++) ticket.sale(); },\"A\").start();\n        new Thread(()->{for(int i=0;i<40;i++) ticket.sale(); },\"B\").start();\n        new Thread(()->{for(int i=0;i<40;i++) ticket.sale(); },\"C\").start();\n    }\n}\n\n//lock三部曲\n//1、    Lock lock=new ReentrantLock();\n//2、    lock.lock() 加锁\n//3、    finally=> 解锁：lock.unlock();\nclass Ticket2{\n    private int number=50;\n\n    Lock lock=new ReentrantLock();\n\n    //卖票的方式\n    // 使用Lock 锁\n    public void sale(){\n        //加锁\n        lock.lock();\n        try {\n            //业务代码\n            if(number>=0){\n                System.out.println(Thread.currentThread().getName()+\" 卖出了第\"+number+\" 张票,剩余：\"+number+\" 张票\");\n                number--;\n            }\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n            //解锁\n            lock.unlock();\n        }\n    }\n}\n```\n\n\n\n> 3、Synchronized 和 Lock区别\n\n- 1、Synchronized 内置的Java关键字，Lock是一个Java类\n\n- 2、Synchronized 无法判断获取锁的状态，Lock可以判断\n\n- 3、Synchronized 会自动释放锁，lock必须要手动加锁和手动释放锁！**可能会遇到死锁**\n\n- 4、Synchronized 线程1(获得锁->阻塞)、线程2(等待)；\n\n  lock就不一定会一直等待下去，**lock会有一个trylock去尝试获取锁**，不会造成长久的等待。\n\n- 5、Synchronized 是可重入锁，不可以中断的，非公平的；Lock，可重入的，可以判断锁，可以自己设置公平锁和非公平锁；\n\n- 6、Synchronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码；\n\n> 锁到底是什么？ 如何判断锁的是谁？\n\n\n\n## 4. 生产者和消费者问题！\n\n**Synchronized wait notify**可以实现，该方法是传统版本；\n\n我们这次使用lock版本\n\n> 1、Synchronized版本\n\n```java\npublic class A {\n    public static void main(String[] args) {\n        Data data = new Data();\n\n        new Thread(()->{for(int i=0;i<10;i++) {\n            try {\n                data.increment();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        },\"A\").start();\n        new Thread(()->{for(int i=0;i<10;i++) {\n            try {\n                data.decrement();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }},\"B\").start();\n    }\n}\nclass Data{\n    //数字  资源类\n    private int number = 0;\n\n    //+1\n    public synchronized void increment() throws InterruptedException {\n        if(number!=0){\n            //等待操作\n            this.wait();\n        }\n        number++;\n        System.out.println(Thread.currentThread().getName()+\"=>\"+number);\n        //通知其他线程 我+1完毕了\n        this.notifyAll();\n    }\n\n    //-1\n    public synchronized void decrement() throws InterruptedException {\n        if(number==0){\n            //等待操作\n            this.wait();\n        }\n        number--;\n        System.out.println(Thread.currentThread().getName()+\"=>\"+number);\n        //通知其他线程  我-1完毕了\n        this.notifyAll();\n    }\n\n}\n```\n\n> **问题存在，A线程B线程，现在如果我有四个线程A B C D！**\n\n![20200727200107238](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200107238.png)\n\n**解决方案**： **if 改为while即可，防止虚假唤醒**\n\n这样就不存在问题了：\n\n![20200727200208118](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200208118.png)\n\n\n\n> 2、**JUC版本的生产者和消费者问题**\n\n**await、signal 替换 wait、notify**\n\n![20200727200241338](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200241338.png)\n\n通过Lock找到Condition\n\n![20200727200309313](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200309313.png)\n\n```java\npublic class B {\n    public static void main(String[] args) {\n        Data2 data = new Data2();\n\n        new Thread(()->{for(int i=0;i<10;i++) {\n            data.increment();\n        }\n        },\"A\").start();\n        new Thread(()->{for(int i=0;i<10;i++) {\n            data.decrement();\n        }},\"B\").start();\n        new Thread(()->{for(int i=0;i<10;i++) {\n            data.increment();\n        }\n        },\"C\").start();\n        new Thread(()->{for(int i=0;i<10;i++) {\n            data.decrement();\n        }\n        },\"D\").start();\n    }\n}\nclass Data2{\n    //数字  资源类\n    private int number = 0;\n\n    //lock锁\n    Lock lock = new ReentrantLock();\n    Condition condition = lock.newCondition();\n\n    //+1\n    public void increment()  {\n        lock.lock();\n        try{\n\n            //业务\n            while (number!=0){\n                //等待操作\n                condition.await();\n            }\n            number++;\n            System.out.println(Thread.currentThread().getName()+\"=>\"+number);\n            //通知其他线程 我+1完毕了\n            condition.signalAll();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    //-1\n    public void decrement()  {\n        lock.lock();\n        try{\n            //业务\n            while (number==0){\n                //等待操作\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName()+\"=>\"+number);\n            //通知其他线程 我+1完毕了\n            condition.signalAll();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n\n\n> 3、**Condition的优势**：精准的通知和唤醒的线程！\n\n**如果我们要指定通知的下一个进行顺序怎么办呢？ 我们可以使用Condition来指定通知进程~**\n\n```java\n/**\n * A 执行完 调用B\n * B 执行完 调用C\n * C 执行完 调用A\n */\n\npublic class C {\n\n    public static void main(String[] args) {\n        Data3 data3 = new Data3();\n        new Thread(()->{\n            for(int i=0;i<10;i++){\n                data3.printA();\n            }\n        },\"A\").start();\n        new Thread(()->{\n            for(int i=0;i<10;i++){\n                data3.printB();\n            }\n        },\"B\").start();\n        new Thread(()->{\n            for(int i=0;i<10;i++){\n                data3.printC();\n            }\n        },\"C\").start();\n    }\n}\n\nclass Data3{\n    //资源类\n    private Lock lock=new ReentrantLock();\n    private Condition condition1 = lock.newCondition();\n    private Condition condition2 = lock.newCondition();\n    private Condition condition3 = lock.newCondition();\n    private int number = 1; //1A 2B 3C\n\n    public void printA(){\n        lock.lock();\n        try {\n            //业务 判断 -> 执行 -> 通知\n            while(number!=1){\n                //等待\n                condition1.await();\n            }\n            //操作\n            System.out.println(Thread.currentThread().getName()+\",AAAAA\");\n            //唤醒指定的线程\n            number=2;\n            condition2.signal(); // 唤醒2\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void printB(){\n        lock.lock();\n        try {\n            //业务 判断 -> 执行 -> 通知\n            while (number!=2){\n                condition2.await();\n            }\n            System.out.println(Thread.currentThread().getName()+\",BBBBB\");\n            //唤醒3\n            number=3;\n            condition3.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void printC(){\n        lock.lock();\n        try {\n            //业务 判断 -> 执行 -> 通知\n            while(number!=3){\n                condition3.await();\n            }\n            System.out.println(Thread.currentThread().getName()+\",CCCCC\");\n            //唤醒1\n            number=1;\n            condition1.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n![20200727200424210](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200424210.png)\n\n\n\n## 5. 8锁现象\n\n>1、**如何判断锁的是谁！锁到底锁的是谁？**\n\n锁会锁住：**对象、Class**\n\n**深刻理解我们的锁**\n\n- 问题1：\n\n![20200727200505228](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200505228.png)\n\n结果是：先发短信，如何再打电话！\n\n**为什么？ 如果你认为是顺序在前？ 这个答案是错误的！**\n\n- 问题2：\n\n**我们再来看：我们让发短信 延迟4s**\n\n![20200727200541706](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200541706.png)\n\n现在结果是什么呢？\n\n结果：**还是先发短信，然后再打电话！**\n\n**why？**\n\n原因：并不是顺序执行！是因为synchronized 锁的对象是方法的调用！对于两个方法用的是同一个锁，谁先拿到谁先执行！另外一个则等待！\n\n- 问题3：\n\n**如果我们添加一个普通方法，那么先执行哪一个呢？**\n\n![20200727200635437](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200635437.png)\n\n答案是：**先执行hello，然后再执行发短信！\\**原因是hello是一个\\**普通方法**，**不受synchronized锁的影响**，但是我发现，如果我把发短信里面的延迟4秒去掉，那么就会顺序执行，先执行发短信然后再执行hello，原因应该是顺序执行的原因吧,不是太理解。\n\n- 问题4：\n\n**如果我们使用的是两个对象，一个调用发短信，一个调用打电话，那么整个顺序是怎么样的呢？**\n\n![20200727200753229](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200753229.png)\n\n答案是：先打电话，后发短信。原因：**在发短信方法中延迟了4s，又因为synchronized锁的是对象，但是我们这使用的是两个对象，所以每个对象都有一把锁，所以不会造成锁的等待。正常执行**\n\n- 问题5，6：\n\n**如果我们把synchronized的方法加上static变成静态方法！那么顺序又是怎么样的呢？**\n\n（1）我们先来使用一个对象调用两个方法！\n\n答案是：**先发短信,后打电话**\n\n（2）如果我们使用两个对象调用两个方法！\n\n答案是：**还是先发短信，后打电话**\n\n原因是什么呢？ **为什么加了static就始终前面一个对象先执行呢！为什么后面会等待呢？**\n\n原因是：**对于static静态方法来说，对于整个类Class来说只有一份，对于不同的对象使用的是同一份方法，相当于这个方法是属于这个类的，如果静态static方法使用synchronized锁定，那么这个synchronized锁会锁住整个对象！不管多少个对象，对于静态的锁都只有一把锁，谁先拿到这个锁就先执行，其他的进程都需要等待！**\n\n- 问题7：\n\n**如果我们使用一个静态同步方法、一个同步方法、一个对象调用顺序是什么？**\n\n![20200727200947247](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727200947247.png)\n\n明显答案是：先打电话，后发短信了。\n\n**因为一个锁的是Class类模板，一个锁的是对象调用者。后面那个打电话不需要等待发短信，直接运行就可以了。**\n\n- 问题8：\n\n如果我们使用一个静态同步方法、一个同步方法、两个对象调用顺序是什么呢？\n\n![20200727201304983](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201304983.png)\n\n当然答案是：先打电话、后发短信！\n\n因为两个对象，一样的原因：**两把锁锁的不是同一个东西，所以后面的第二个对象不需要等待第一个对象的执行。**\n\n\n\n> 2、小结\n\n**new** 出来的 this 是具体的一个对象\n\n**static Class** 是唯一的一个模板\n\n\n\n## 6. 集合类不安全\n\n> 1、List不安全\n\n我们来看一下List这个集合类：\n\n```java\n//java.util.ConcurrentModificationException 并发修改异常！\npublic class ListTest {\n    public static void main(String[] args) {\n\n        List<Object> arrayList = new ArrayList<>();\n\n        for(int i=1;i<=10;i++){\n            new Thread(()->{\n                arrayList.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(arrayList);\n            },String.valueOf(i)).start();\n        }\n\n    }\n}\n```\n\n会造成：\n\n![20200727201349859](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201349859.png)\n\n**ArrayList 在并发情况下是不安全的！**\n\n解决方案：\n\n**1、切换成Vector就是线程安全的啦！**\n\n![20200727201419457](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201419457.png)\n\n**2、使用Collections.synchronizedList(new ArrayList<>());**\n\n```java\npublic class ListTest {\n    public static void main(String[] args) {\n\n        List<Object> arrayList = Collections.synchronizedList(new ArrayList<>());\n\n        for(int i=1;i<=10;i++){\n            new Thread(()->{\n                arrayList.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(arrayList);\n            },String.valueOf(i)).start();\n        }\n\n    }\n}\n```\n\n**3、使用JUC中的包：List arrayList = new CopyOnWriteArrayList<>();**\n\n```java\npublic class ListTest {\n    public static void main(String[] args) {\n\n        List<Object> arrayList = new CopyOnWriteArrayList<>();\n\n        for(int i=1;i<=10;i++){\n            new Thread(()->{\n                arrayList.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(arrayList);\n            },String.valueOf(i)).start();\n        }\n\n    }\n}\n```\n\n**CopyOnWriteArrayList**：写入时复制！ **COW 计算机程序设计领域的一种优化策略**\n\n多个线程调用的时候，list，读取的时候，固定的，写入（存在覆盖操作）；在写入的时候避免覆盖，造成数据错乱的问题；\n\n\n\n> 2、**CopyOnWriteArrayList**比**Vector**厉害在哪里？\n\n**Vector**底层是使用**synchronized**关键字来实现的：效率特别低下。\n\n![20200727201526105](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201526105.png)\n\n**CopyOnWriteArrayList**使用的是Lock锁，效率会更加高效！\n\n![20200727201546295](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201546295.png)\n\n\n\n> 3、Set不安全\n\n![20200727201604399](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201604399.png)\n\n和List、Set同级的还有一个BlockingQueue 阻塞队列；\n\n**Set和List同理可得:** 多线程情况下，普通的Set集合是线程不安全的；\n\n解决方案还是两种：\n\n- 使用Collections工具类的**synchronized**包装的Set类\n- 使用CopyOnWriteArraySet 写入复制的**JUC**解决方案\n\n```java\n//同理：java.util.ConcurrentModificationException\n// 解决方案：\npublic class SetTest {\n    public static void main(String[] args) {\n//        Set<String> hashSet = Collections.synchronizedSet(new HashSet<>()); //解决方案1\n        Set<String> hashSet = new CopyOnWriteArraySet<>();//解决方案2\n        for (int i = 1; i < 100; i++) {\n            new Thread(()->{\n                hashSet.add(UUID.randomUUID().toString().substring(0,5));\n                System.out.println(hashSet);\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n\n**HashSet底层是什么？**\n\nhashSet底层就是一个**HashMap**；\n\n```java\npublic HashSet() {\n        map = new HashMap<>();\n}\n\n//add 本质其实就是一个map的key，map的key是无法重复的，所以使用的就是map存储\n//hashSet就是使用了hashmap key不能重复的原理\npublic boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n}\n//PRESENT是什么？ 是一个常量  不会改变的常量  无用的占位\nprivate static final Object PRESENT = new Object();\n```\n\n\n\n> 4、Map不安全\n\n回顾map的基本操作：\n\n```\n//map 是这样用的吗？  不是，工作中不使用这个\n//默认等价什么？ new HashMap<>(16,0.75);\nMap<String, String> map = new HashMap<>();\n//加载因子、初始化容量\n```\n\n默认**加载因子是0.75**,默认的**初始容量是16**\n\n![20200727201710950](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201710950.png)\n\n同样的HashMap基础类也存在**并发修改异常**！\n\n```java\npublic static void main(String[] args) {\n        //map 是这样用的吗？  不是，工作中不使用这个\n        //默认等价什么？ new HashMap<>(16,0.75);\n        Map<String, String> map = new HashMap<>();\n        //加载因子、初始化容量\n        for (int i = 1; i < 100; i++) {\n            new Thread(()->{\n                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring(0,5));\n                System.out.println(map);\n            },String.valueOf(i)).start();\n        }\n    }\n```\n\n结果同样的出现了：**异常java.util.ConcurrentModificationException 并发修改异常**\n\n**解决方案：**\n\n- **使用Collections.synchronizedMap(new HashMap<>());处理**；\n- **使用ConcurrentHashMap进行并发处理**\n\nTODO:研究ConcurrentHashMap底层原理：\n\n这里我们可以直接去研究一下，这个也是相当重要的。\n\n\n\n## 7. Callable(简单)\n\n![20200727201823382](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201823382.png)\n\n**1、可以有返回值；**\n\n**2、可以抛出异常；**\n\n**3、方法不同，run()/call()**\n\n> 1、代码测试\n\n传统使用线程方式：\n\n```java\npublic class CallableTest {\n    public static void main(String[] args) {\n        for (int i = 1; i < 10; i++) {\n            new Thread(new MyThread()).start();\n        }\n    }\n}\n\nclass MyThread implements Runnable{\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n```\n\n使用**Callable**进行多线程操作：\n\n![20200727201858566](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201858566.png)\n\nCalleable 泛型T就是**call运行方法的返回值类型**；\n\n但是**如何使用**呢？\n\n**Callable怎么放入到Thread里面呢？**\n\n源码分析：\n\n![20200727201934861](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727201934861.png)\n\n对于Thread运行，只能传入Runnable类型的参数；\n\n我们这是Callable 怎么办呢？\n\n看JDK api文档：\n\n在Runnable里面有一个叫做FutureTask的实现类，我们进去看一下。\n\n![20200727202005417](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202005417.png)\n\nFutureTask中可以接受Callable参数；\n\n![20200727202022160](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202022160.png)\n\n这样我们就可以先把Callable 放入到FutureTask中， 如何再把FutureTask 放入到Thread就可以了。\n\n```java\npublic class CallableTest {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        for (int i = 1; i < 10; i++) {\n//            new Thread(new Runnable()).start();\n//            new Thread(new FutureTask<>( Callable)).start();\n            MyThread thread= new MyThread();\n            //适配类：FutureTask\n            FutureTask<String> futureTask = new FutureTask<>(thread);\n            //放入Thread使用\n            new Thread(futureTask,String.valueOf(i)).start();\n            //获取返回值\n            String s = futureTask.get();\n            System.out.println(\"返回值：\"+ s);\n        }\n    }\n}\n\nclass MyThread implements Callable<String> {\n\n    @Override\n    public String call() throws Exception {\n        System.out.println(\"Call:\"+Thread.currentThread().getName());\n        return \"String\"+Thread.currentThread().getName();\n    }\n}\n```\n\n这样我们就可以使用Callable来进行多线程编程了，并且我们发现可以有返回值，并且可以抛出异常。\n\n![20200727202113698](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202113698.png)\n\n注意两个重点：\n\n![20200727202135656](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202135656.png)\n\n\n\n## 8. 常用的辅助类【必回】\n\n### 8.1 CountDownLatch\n\n![20200727202247162](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202247162.png)\n\n**其实就是一个减法计数器，对于计数器归零之后再进行后面的操作，这是一个计数器！**\n\n```java\n//这是一个计数器  减法\npublic class CountDownLatchDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        //总数是6\n        CountDownLatch countDownLatch = new CountDownLatch(6);\n\n        for (int i = 1; i <= 6 ; i++) {\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+\" Go out\");\n                countDownLatch.countDown(); //每个线程都数量-1\n            },String.valueOf(i)).start();\n        }\n        countDownLatch.await();  //等待计数器归零  然后向下执行\n\n        System.out.println(\"close door\");\n\n    }\n\n}\n```\n\n主要方法：\n\n- countDown 减一操作；\n- await 等待计数器归零。\n\nawait等待计数器为0，就唤醒，再继续向下运行。\n\n\n\n### 8.2 CyclickBarrier\n\n![20200727202349295](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202349295.png)\n\n其实就是一个加法计数器；\n\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n\n        //主线程\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{\n            System.out.println(\"召唤神龙~\");\n        });\n\n        for (int i = 1; i <= 7; i++) {\n            //子线程\n            int finalI = i;\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+\" 收集了第 {\"+ finalI+\"} 颗龙珠\");\n                try {\n                    cyclicBarrier.await(); //加法计数 等待\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n\n    }\n}\n```\n\n\n\n### 8.3 Semaphore\n\nSemaphore：信号量\n\n抢车位：\n\n3个车位 6辆车：\n\n```java\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        //停车位为3个\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 1; i <= 6; i++) {\n            int finalI = i;\n            new Thread(()->{\n                try {\n                    semaphore.acquire(); //得到\n                    //抢到车位\n                    System.out.println(Thread.currentThread().getName()+\" 抢到了车位{\"+ finalI +\"}\");\n                    TimeUnit.SECONDS.sleep(2); //停车2s\n                    System.out.println(Thread.currentThread().getName()+\" 离开车位\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    semaphore.release();//释放\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n\n原理：\n\n**semaphore.acquire()获得资源，如果资源已经使用完了，就等待资源释放后再进行使用！**\n\n**semaphore.release()释放，会将当前的信号量释放+1，然后唤醒等待的线程！**\n\n作用： 多个共享资源互斥的使用！ 并发限流，控制最大的线程数！\n\n\n\n## 9. 读写锁\n\n先对于不加锁的情况：\n\n如果我们做一个我们自己的cache缓存。分别有写入操作、读取操作；\n\n我们采用五个线程去写入，使用十个线程去读取。\n\n我们来看一下这个的效果，如果我们不加锁的情况！\n\n```java\npackage com.ogj.rw;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class ReadWriteLockDemo {\n    public static void main(String[] args) {\n        MyCache_ReadWriteLock mycache = new MyCache_ReadWriteLock();\n        //开启5个线程 写入数据\n        for (int i = 1; i <=5 ; i++) {\n            int finalI = i;\n            new Thread(()->{\n                mycache.put(String.valueOf(finalI),String.valueOf(finalI));\n            }).start();\n        }\n        //开启10个线程去读取数据\n        for (int i = 1; i <=10 ; i++) {\n            int finalI = i;\n            new Thread(()->{\n                String o = mycache.get(String.valueOf(finalI));\n            }).start();\n        }\n    }\n}\n\nclass MyCache_ReadWriteLock{\n    private volatile Map<String,String> map=new HashMap<>();\n\n    //使用读写锁\n    private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();\n    //普通锁\n    private Lock lock=new ReentrantLock();\n\n    public void put(String key,String value){\n        //写入\n        System.out.println(Thread.currentThread().getName()+\" 线程 开始写入\");\n        map.put(key, value);\n        System.out.println(Thread.currentThread().getName()+\" 线程 写入OK\");\n    }\n\n    public String get(String key){\n        //得到\n        System.out.println(Thread.currentThread().getName()+\" 线程 开始读取\");\n        String o = map.get(key);\n        System.out.println(Thread.currentThread().getName()+\" 线程 读取OK\");\n        return o;\n    }\n}\n```\n\n运行效果如下：\n\n```bash\nThread-0 线程 开始写入\nThread-4 线程 开始写入  # 插入了其他的线程进行写入\nThread-4 线程 写入OK\nThread-3 线程 开始写入\nThread-1 线程 开始写入\nThread-2 线程 开始写入\nThread-1 线程 写入OK\nThread-3 线程 写入OK\nThread-0 线程 写入OK   # 对于这种情况会出现 数据不一致等情况\nThread-2 线程 写入OK\nThread-5 线程 开始读取\nThread-6 线程 开始读取\nThread-6 线程 读取OK\nThread-7 线程 开始读取\nThread-7 线程 读取OK\nThread-5 线程 读取OK\nThread-8 线程 开始读取\nThread-8 线程 读取OK\nThread-9 线程 开始读取\nThread-9 线程 读取OK\nThread-10 线程 开始读取\nThread-11 线程 开始读取\nThread-12 线程 开始读取\nThread-12 线程 读取OK\nThread-10 线程 读取OK\nThread-14 线程 开始读取\nThread-13 线程 开始读取\nThread-13 线程 读取OK\nThread-11 线程 读取OK\nThread-14 线程 读取OK\n\nProcess finished with exit code 0\n```\n\n所以如果我们不加锁的情况，多线程的读写会造成数据不可靠的问题。\n\n我们也可以采用**synchronized**这种重量锁和轻量锁 **lock**去保证数据的可靠。\n\n但是这次我们采用更细粒度的锁：**ReadWriteLock** 读写锁来保证\n\n![20200727202527553](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202527553.png)\n\n```java\npackage com.ogj.rw;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\npublic class ReadWriteLockDemo {\n    public static void main(String[] args) {\n        MyCache_ReadWriteLock mycache = new MyCache_ReadWriteLock();\n        //开启5个线程 写入数据\n        for (int i = 1; i <=5 ; i++) {\n            int finalI = i;\n            new Thread(()->{\n                mycache.put(String.valueOf(finalI),String.valueOf(finalI));\n            }).start();\n        }\n        //开启10个线程去读取数据\n        for (int i = 1; i <=10 ; i++) {\n            int finalI = i;\n            new Thread(()->{\n                String o = mycache.get(String.valueOf(finalI));\n            }).start();\n        }\n    }\n}\n\nclass MyCache_ReadWriteLock{\n    private volatile Map<String,String> map=new HashMap<>();\n\n    //使用读写锁\n    private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();\n    //普通锁\n    private Lock lock=new ReentrantLock();\n\n    public void put(String key,String value){\n        //加锁\n        readWriteLock.writeLock().lock();\n        try {\n            //写入\n            //业务流程\n            System.out.println(Thread.currentThread().getName()+\" 线程 开始写入\");\n            map.put(key, value);\n            System.out.println(Thread.currentThread().getName()+\" 线程 写入OK\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            readWriteLock.writeLock().unlock(); //解锁\n        }\n    }\n\n    public String get(String key){\n        //加锁\n        String o=\"\";\n        readWriteLock.readLock().lock();\n        try {\n            //得到\n            System.out.println(Thread.currentThread().getName()+\" 线程 开始读取\");\n            o = map.get(key);\n            System.out.println(Thread.currentThread().getName()+\" 线程 读取OK\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            readWriteLock.readLock().unlock();\n        }\n        return o;\n    }\n}\n```\n\n运行结果如下：\n\n```bash\nThread-0 线程 开始写入\nThread-0 线程 写入OK\nThread-1 线程 开始写入\nThread-1 线程 写入OK\nThread-2 线程 开始写入\nThread-2 线程 写入OK\nThread-3 线程 开始写入\nThread-3 线程 写入OK\nThread-4 线程 开始写入\nThread-4 线程 写入OK\n\n# 以上 整个过程没有再出现错乱的情况，对于读取，我们运行多个线程同时读取，\n# 因为这样不会造成数据不一致问题，也能在一定程度上提高效率\nThread-9 线程 开始读取\nThread-9 线程 读取OK\nThread-10 线程 开始读取\nThread-5 线程 开始读取\nThread-11 线程 开始读取\nThread-11 线程 读取OK\nThread-10 线程 读取OK\nThread-7 线程 开始读取\nThread-7 线程 读取OK\nThread-6 线程 开始读取\nThread-5 线程 读取OK\nThread-14 线程 开始读取\nThread-8 线程 开始读取\nThread-14 线程 读取OK\nThread-6 线程 读取OK\nThread-13 线程 开始读取\nThread-12 线程 开始读取\nThread-13 线程 读取OK\nThread-8 线程 读取OK\nThread-12 线程 读取OK\n```\n\n\n\n## 10. 阻塞队列\n\n* 阻塞队列 \n\n![20200727202624665](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202624665.png)\n\n阻塞队列jdk1.8文档解释：\n\n![20200727202645162](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202645162.png)\n\n\n\n### 10.1 BlockingQueue\n\nblockingQueue 是Collection的一个子类；\n\n什么情况我们会使用 阻塞队列呢？\n\n```\n多线程并发处理、线程池！\n```\n\n![20200727202709411](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202709411.png)\n\n整个阻塞队列的家族如下：Queue以下实现的有Deque、AbstaractQueue、BlockingQueue；\n\nBlockingQueue以下有Link链表实现的阻塞队列、也有Array数组实现的阻塞队列\n\n\n\n### 10.2 如何使用阻塞队列呢？\n\n------\n\n操作：添加、移除\n\n但是实际我们要学的有：\n\n**四组API**\n\n| 方式       | 抛出异常 | 不会抛出异常，有返回值 | 阻塞 等待 | 超时 等待                |\n| ---------- | -------- | ---------------------- | --------- | ------------------------ |\n| 添加       | add      | offer                  | put       | offer(timenum，timeUnit) |\n| 移除       | remove   | poll                   | take      | poll(timenum，timeUnit)  |\n| 判断队列首 | element  | peek                   | -         | -                        |\n\n```java\n/**\n     * 抛出异常\n     */\n    public static void test1(){\n        //需要初始化队列的大小\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n\n        System.out.println(blockingQueue.add(\"a\"));\n        System.out.println(blockingQueue.add(\"b\"));\n        System.out.println(blockingQueue.add(\"c\"));\n        //抛出异常：java.lang.IllegalStateException: Queue full\n//        System.out.println(blockingQueue.add(\"d\"));\n        System.out.println(blockingQueue.remove());\n        System.out.println(blockingQueue.remove());\n        System.out.println(blockingQueue.remove());\n        //如果多移除一个\n        //这也会造成 java.util.NoSuchElementException 抛出异常\n        System.out.println(blockingQueue.remove());\n    }\n=======================================================================================\n/**\n     * 不抛出异常，有返回值\n     */\n    public static void test2(){\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n        System.out.println(blockingQueue.offer(\"a\"));\n        System.out.println(blockingQueue.offer(\"b\"));\n        System.out.println(blockingQueue.offer(\"c\"));\n        //添加 一个不能添加的元素 使用offer只会返回false 不会抛出异常\n        System.out.println(blockingQueue.offer(\"d\"));\n\n        System.out.println(blockingQueue.poll());\n        System.out.println(blockingQueue.poll());\n        System.out.println(blockingQueue.poll());\n        //弹出 如果没有元素 只会返回null 不会抛出异常\n        System.out.println(blockingQueue.poll());\n    }\n=======================================================================================\n/**\n     * 等待 一直阻塞\n     */\n    public static void test3() throws InterruptedException {\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n\n        //一直阻塞 不会返回\n        blockingQueue.put(\"a\");\n        blockingQueue.put(\"b\");\n        blockingQueue.put(\"c\");\n\n        //如果队列已经满了， 再进去一个元素  这种情况会一直等待这个队列 什么时候有了位置再进去，程序不会停止\n//        blockingQueue.put(\"d\");\n\n        System.out.println(blockingQueue.take());\n        System.out.println(blockingQueue.take());\n        System.out.println(blockingQueue.take());\n        //如果我们再来一个  这种情况也会等待，程序会一直运行 阻塞\n        System.out.println(blockingQueue.take());\n    }\n=======================================================================================\n/**\n     * 等待 超时阻塞\n     *  这种情况也会等待队列有位置 或者有产品 但是会超时结束\n     */\n    public static void test4() throws InterruptedException {\n        ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);\n        blockingQueue.offer(\"a\");\n        blockingQueue.offer(\"b\");\n        blockingQueue.offer(\"c\");\n        System.out.println(\"开始等待\");\n        blockingQueue.offer(\"d\",2, TimeUnit.SECONDS);  //超时时间2s 等待如果超过2s就结束等待\n        System.out.println(\"结束等待\");\n        System.out.println(\"===========取值==================\");\n        System.out.println(blockingQueue.poll());\n        System.out.println(blockingQueue.poll());\n        System.out.println(blockingQueue.poll());\n        System.out.println(\"开始等待\");\n        blockingQueue.poll(2,TimeUnit.SECONDS); //超过两秒 我们就不要等待了\n        System.out.println(\"结束等待\");\n    }\n```\n\n\n\n### 10.3 同步队列SynchronousQueue\n\n同步队列 没有容量，也可以视为**容量为1的队列**；\n\n进去一个元素，必须等待取出来之后，才能再往里面放入一个元素；\n\n**put**方法 和 **take**方法；\n\n**Synchronized** 和 其他的**BlockingQueue** 不一样 它不存储元素；\n\nput了一个元素，就必须从里面先take出来，否则不能再put进去值！\n\n并且SynchronousQueue 的take是使用了**lock锁保证线程安全**的。\n\n```java\n/**\n * 同步队列\n */\npublic class SynchronousQueueDemo {\n    public static void main(String[] args) {\n        BlockingQueue<String> synchronousQueue = new SynchronousQueue<>();\n        //研究一下 如果判断这是一个同步队列\n\n        //使用两个进程\n        // 一个进程 放进去\n        // 一个进程 拿出来\n        new Thread(()->{\n            try {\n                System.out.println(Thread.currentThread().getName()+\" Put 1\");\n                synchronousQueue.put(\"1\");\n                System.out.println(Thread.currentThread().getName()+\" Put 2\");\n                synchronousQueue.put(\"2\");\n                System.out.println(Thread.currentThread().getName()+\" Put 3\");\n                synchronousQueue.put(\"3\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        },\"T1\").start();\n\n        new Thread(()->{\n            try {\n                System.out.println(Thread.currentThread().getName()+\" Take \"+synchronousQueue.take());\n//                TimeUnit.SECONDS.sleep(3);\n                System.out.println(Thread.currentThread().getName()+\" Take \"+synchronousQueue.take());\n//                TimeUnit.SECONDS.sleep(3);\n                System.out.println(Thread.currentThread().getName()+\" Take \"+synchronousQueue.take());\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        },\"T2\").start();\n    }\n}\n```\n\n![20200727202913340](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727202913340.png)\n\n\n\n## 11. 线程池【重点】\n\n线程池：**三大方法、7大参数、4种拒绝策略**\n\n> 1、池化技术\n\n程序的运行，本质：占用系统的资源！我们需要去优化资源的使用 ===> 池化技术\n\n线程池、JDBC的连接池、内存池、对象池 等等。。。。\n\n资源的创建、销毁十分消耗资源\n\n**池化技术**：事先准备好一些资源，如果有人要用，就来我这里拿，用完之后还给我，以此来提高效率。\n\n**线程池的好处：**\n\n1、降低资源的消耗；\n\n2、提高响应的速度；\n\n3、方便管理；\n\n**线程复用、可以控制最大并发数、管理线程；**\n\n\n\n> 2、线程池：三大方法\n\n- **ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程**\n- **ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小**\n- **ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的**\n\n```java\n//工具类 Executors 三大方法；\npublic class Demo01 {\n    public static void main(String[] args) {\n\n        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程\n        ExecutorService threadPool2 = Executors.newFixedThreadPool(5); //创建一个固定的线程池的大小\n        ExecutorService threadPool3 = Executors.newCachedThreadPool(); //可伸缩的\n\n        //线程池用完必须要关闭线程池\n        try {\n\n            for (int i = 1; i <=100 ; i++) {\n                //通过线程池创建线程\n                threadPool.execute(()->{\n                    System.out.println(Thread.currentThread().getName()+ \" ok\");\n                });\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            threadPool.shutdown();\n        }\n    }\n}\n```\n\n\n\n> 3、7大参数\n\n源码分析\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n123456\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n12345\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n本质：三种方法都是开启的**ThreadPoolExecutor**\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,  //核心线程池大小\n                          int maximumPoolSize, //最大的线程池大小\n                          long keepAliveTime,  //超时了没有人调用就会释放\n                          TimeUnit unit, //超时单位\n                          BlockingQueue<Runnable> workQueue, //阻塞队列\n                          ThreadFactory threadFactory, //线程工厂 创建线程的 一般不用动\n                          RejectedExecutionHandler handler //拒绝策略\n                         ) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n\n![20200727203110154](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203110154.png)\n\n阿里巴巴的Java操作手册中明确说明：对于Integer.MAX_VALUE初始值较大，所以一般情况我们要使用底层的**ThreadPoolExecutor**来创建线程池。\n\n\n\n> 4、业务图\n\n![20200727203248928](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203248928.png)\n\n> 手动创建线程池\n\n// todo\n\n\n\n> 5、拒绝策略4种\n\n![20200727203331940](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203331940.png)\n\n**（1）new ThreadPoolExecutor.AbortPolicy()：** //该拒绝策略为：银行满了，还有人进来，不处理这个人的，并抛出异常\n\n超出最大承载，就会抛出异常：队列容量大小+maxPoolSize\n\n![20200727203414339](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203414339.png)\n\n**（2）new ThreadPoolExecutor.CallerRunsPolicy()：** //该拒绝策略为：哪来的去哪里 main线程进行处理\n\n![20200727203500107](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203500107.png)\n\n**（3）new ThreadPoolExecutor.DiscardPolicy():** //该拒绝策略为：队列满了,丢掉异常，不会抛出异常。\n\n![20200727203537911](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203537911.png)\n\n**（4）new ThreadPoolExecutor.DiscardOldestPolicy()：** //该拒绝策略为：队列满了，尝试去和最早的进程竞争，不会抛出异常\n\n![20200727203600323](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203600323.png)\n\n\n\n> 6、小结和拓展\n\n------\n\n如何去设置线程池的最大大小如何去设置？\n\nCPU密集型和IO密集型！\n\n------\n\n**1、CPU密集型：电脑的核数是几核就选择几；选择maximunPoolSize的大小**\n\n![20200727203627960](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203627960.png)\n\n我们可以使用代码来来获取逻辑处理器数量。\n\n于是**cpu密集型**的写法如下：\n\n![20200727203653987](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203653987.png)\n\n**2、I/O密集型：**\n\n在程序中有15个大型任务，io十分占用资源；I/O密集型就是判断我们程序中十分耗I/O的线程数量，大约是最大I/O数的一倍到两倍之间。\n\n\n\n## 12. 四大函数式接口【必须掌握】\n\n新时代的程序员：**lambda表达式、链式编程、函数式接口、Stream流式计算**\n\n> 1、函数式接口：只有一个方法的接口\n\n```java\n@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}\n//超级多的@FunctionalInterface\n//简化编程模型，在新版本的框架底层大量应用\n//foreach()的参数也是一个函数式接口，消费者类的函数式接口\n```\n\n![20200727203732511](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203732511.png)\n\n函数型接口可以使用lambda表达式；\n\n**代码测试：**\n\n> 2、Function函数型接口\n\n![20200727203808177](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203808177.png)\n\n```java\n/**\n * Function函数型接口\n */\npublic class Demo01 {\n    public static void main(String[] args) {\n        Function<String,String> function = (str) ->{return str;};\n        System.out.println(function.apply(\"starasdas\"));\n    }\n}\n```\n\n> 3、Predicate断定型接口\n\n![20200727203829514](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203829514.png)\n\n```java\n/**\n * 断定型接口：有一个输入参数，返回值只能是 布尔值！\n */\npublic class Demo2 {\n    public static void main(String[] args) {\n        //判断字符串是否为空\n        Predicate<String> predicate = (str)->{return str.isEmpty();};\n        System.out.println(predicate.test(\"11\"));\n        System.out.println(predicate.test(\"\"));\n    }\n}\n```\n\n------\n\n> 4、Consummer 消费型接口\n\n![20200727203853168](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203853168.png)\n\n```java\n/**\n * 消费型接口 没有返回值！只有输入！\n */\npublic class Demo3 {\n    public static void main(String[] args) {\n        Consumer<String> consumer = (str)->{\n            System.out.println(str);\n        };\n        consumer.accept(\"abc\");\n    }\n}\n```\n\n> 5、Supplier供给型接口\n\n![20200727203909741](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203909741.png)\n\n```java\n/**\n * 供给型接口，只返回，不输入\n */\npublic class Demo4 {\n    public static void main(String[] args) {\n        Supplier<String> supplier = ()->{return \"1024\";};\n        System.out.println(supplier.get());\n    }\n}\n```\n\n\n\n## 13. Stream流式计算\n\n> 1、什么是Stream流式计算？\n\n**存储+计算**！\n\n**存储**：集合、MySQL\n\n**计算**：流式计算~\n\n**=== 链式编程 ===**\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        User user1 = new User(1,\"a\",21);\n        User user2 = new User(2,\"b\",22);\n        User user3 = new User(3,\"c\",23);\n        User user4 = new User(4,\"d\",24);\n        User user5 = new User(5,\"e\",25);\n        User user6 = new User(6,\"f\",26);\n        List<User> list = Arrays.asList(user1, user2, user3, user4, user5, user6);\n\n        //计算交给流\n        //链式编程！！！！\n        list.stream()\n                .filter((u)->{ return u.getId()%2==0; })\n                .filter((u)->{return u.getAge()>23;})\n                .map((u)->{return u.getName().toUpperCase();})\n                .sorted((uu1,uu2)->{\n                    return uu2.compareTo(uu1);\n                })\n                .limit(1)\n                .forEach(System.out::println);\n    }\n}\n```\n\n\n\n## 14. ForkJoin\n\n> 1、什么是ForkJoin？\n\nForkJoin 在JDK1.7，并行执行任务！提高效率~。在大数据量速率会更快！\n\n大数据中：**MapReduce 核心思想->把大任务拆分为小任务！**\n\n![20200727203936254](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203936254.png)\n\n\n\n> 2、**ForkJoin 特点： 工作窃取！**\n\n实现原理是：**双端队列**！从上面和下面都可以去拿到任务进行执行！\n\n![20200727203958799](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727203958799.png)\n\n\n\n> 3、如何使用ForkJoin?\n\n- 1、通过**ForkJoinPool**来执行\n- 2、计算任务 **execute(ForkJoinTask<?> task)**\n\n![20200727204016283](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204016283.png)\n\n- 3、计算类要去继承ForkJoinTask；\n\n**ForkJoin的计算类！**\n\n```java\npackage com.ogj.forkjoin;\n\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinDemo extends RecursiveTask<Long> {\n\n    private long star;\n    private long end;\n\n    //临界值\n    private long temp=1000000L;\n\n    public ForkJoinDemo(long star, long end) {\n        this.star = star;\n        this.end = end;\n    }\n\n    /**\n     * 计算方法\n     * @return Long\n     */\n    @Override\n    protected Long compute() {\n        if((end-star)<temp){\n            Long sum = 0L;\n            for (Long i = star; i < end; i++) {\n                sum+=i;\n            }\n//            System.out.println(sum);\n            return sum;\n        }else {\n            //使用forkJoin 分而治之 计算\n            //计算平均值\n            long middle = (star+ end)/2;\n            ForkJoinDemo forkJoinDemoTask1 = new ForkJoinDemo(star, middle);\n            forkJoinDemoTask1.fork();  //拆分任务，把线程任务压入线程队列\n            ForkJoinDemo forkJoinDemoTask2 = new ForkJoinDemo(middle, end);\n            forkJoinDemoTask2.fork();  //拆分任务，把线程任务压入线程队列\n            long taskSum = forkJoinDemoTask1.join() + forkJoinDemoTask2.join();\n            return taskSum;\n        }\n    }\n}\n```\n\n**测试类！**\n\n```java\npackage com.ogj.forkjoin;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.stream.LongStream;\n\npublic class Test {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        test1();\n        test2();\n        test3();\n    }\n\n    /**\n     * 普通计算\n     */\n    public static void test1(){\n        long star = System.currentTimeMillis();\n        long sum = 0L;\n        for (long i = 1; i < 20_0000_0000; i++) {\n            sum+=i;\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"sum=\"+\"时间：\"+(end-star));\n        System.out.println(sum);\n    }\n\n    /**\n     * 使用ForkJoin\n     */\n    public static void test2() throws ExecutionException, InterruptedException {\n        long star = System.currentTimeMillis();\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        ForkJoinTask<Long> task = new ForkJoinDemo(0L, 20_0000_0000L);\n        ForkJoinTask<Long> submit = forkJoinPool.submit(task);\n        Long aLong = submit.get();\n        System.out.println(aLong);\n        long end = System.currentTimeMillis();\n        System.out.println(\"sum=\"+\"时间：\"+(end-star));\n    }\n\n\n    /**\n     * 使用Stream 并行流\n     */\n    public static void test3(){\n        long star = System.currentTimeMillis();\n        //Stream并行流()\n        long sum = LongStream.range(0L, 20_0000_0000L).parallel().reduce(0, Long::sum);\n        System.out.println(sum);\n        long end = System.currentTimeMillis();\n        System.out.println(\"sum=\"+\"时间：\"+(end-star));\n    }\n}\n```\n\n![20200727204048674](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204048674.png)\n\n**.parallel().reduce(0, Long::sum)使用一个并行流去计算整个计算，提高效率。**\n\n![20200727204101914](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204101914.png)\n\n**reduce方法的优点：**\n\n![20200727204117372](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204117372.png)\n\n\n\n## 15. 异步回调\n\n> 1、Future 设计的初衷：对将来的某个事件结果进行建模！\n\n其实就是前端 --> 发送ajax异步请求给后端\n\n![20200727204140269](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204140269.png)\n\n但是我们平时都使用**CompletableFuture**\n\n\n\n> 2、没有返回值的runAsync异步回调\n\n```java\npublic static void main(String[] args) throws ExecutionException, InterruptedException \n{\n        // 发起 一个 请求\n\n        System.out.println(System.currentTimeMillis());\n        System.out.println(\"---------------------\");\n        CompletableFuture<Void> future = CompletableFuture.runAsync(()->{\n            //发起一个异步任务\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName()+\".....\");\n        });\n        System.out.println(System.currentTimeMillis());\n        System.out.println(\"------------------------------\");\n        //输出执行结果\n        System.out.println(future.get());  //获取执行结果\n }\n```\n\n\n\n> 3、有返回值的异步回调supplyAsync\n\n```java\n//有返回值的异步回调\nCompletableFuture<Integer> completableFuture=CompletableFuture.supplyAsync(()->{\n    System.out.println(Thread.currentThread().getName());\n    try {\n        TimeUnit.SECONDS.sleep(2);\n        int i=1/0;\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return 1024;\n});\nSystem.out.println(completableFuture.whenComplete((t, u) -> {\n    //success 回调\n    System.out.println(\"t=>\" + t); //正常的返回结果\n    System.out.println(\"u=>\" + u); //抛出异常的 错误信息\n}).exceptionally((e) -> {\n    //error回调\n    System.out.println(e.getMessage());\n    return 404;\n}).get());\n```\n\n**whenComplete**: 有两个参数，一个是t 一个是u\n\nT：是代表的 **正常返回的结果**；\n\nU：是代表的 **抛出异常的错误信息**；\n\n如果发生了异常，get可以获取到**exceptionally**返回的值；\n\n\n\n## 16. JMM\n\n> 1、请你谈谈你对Volatile 的理解\n\n**Volatile** 是 Java 虚拟机提供 **轻量级的同步机制**\n\n**1、保证可见性\n2、不保证原子性\n3、禁止指令重排**\n\n> 2、什么是JMM？\n\nJMM：JAVA内存模型，不存在的东西，是一个概念，也是一个约定！\n\n**关于JMM的一些同步的约定：**\n\n1、线程解锁前，必须把共享变量**立刻**刷回主存；\n\n2、线程加锁前，必须**读取主存**中的最新值到工作内存中；\n\n3、加锁和解锁是同一把锁；\n\n线程中分为 **工作内存、主内存**\n\n**8种操作**:\n\n- **Read（读取）**：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用；\n- **load（载入）**：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中；\n- **Use（使用）**：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令；\n- **assign（赋值）**：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中；\n- **store（存储）**：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用；\n- **write（写入）**：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中；\n- **lock（锁定）**：作用于主内存的变量，把一个变量标识为线程独占状态；\n- **unlock（解锁）**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；\n\n![20200727204419162](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204419162.png)\n\n![2020072720443785](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720445830.png)\n\n**JMM对这8种操作给了相应的规定**：\n\n- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write\n- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存\n- 不允许一个线程将没有assign的数据从工作内存同步回主内存\n- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过assign和load操作\n- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁\n- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值\n- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量\n- 对一个变量进行unlock操作之前，必须把此变量同步回主内存\n\n![2020072720445830](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720445830.png)\n\n遇到问题：**程序不知道主存中的值已经被修改过了！；**\n\n\n\n## 17. Volatile\n\n> 1、保证可见性\n\n```java\npublic class JMMDemo01 {\n\n    // 如果不加volatile 程序会死循环\n    // 加了volatile是可以保证可见性的\n    private volatile static Integer number = 0;\n\n    public static void main(String[] args) {\n        //main线程\n        //子线程1\n        new Thread(()->{\n            while (number==0){\n            }\n        }).start();\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //子线程2\n        new Thread(()->{\n            while (number==0){\n            }\n\n        }).start();\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        number=1;\n        System.out.println(number);\n    }\n}\n```\n\n> 2、不保证原子性\n\n原子性：不可分割；\n\n线程A在执行任务的时候，不能被打扰的，也不能被分割的，要么同时成功，要么同时失败。\n\n```java\n/**\n * 不保证原子性\n * number <=2w\n * \n */\npublic class VDemo02 {\n\n    private static volatile int number = 0;\n\n    public static void add(){\n        number++; \n        //++ 不是一个原子性操作，是两个~3个操作\n        //\n    }\n\n    public static void main(String[] args) {\n        //理论上number  === 20000\n\n        for (int i = 1; i <= 20; i++) {\n            new Thread(()->{\n                for (int j = 1; j <= 1000 ; j++) {\n                    add();\n                }\n            }).start();\n        }\n\n        while (Thread.activeCount()>2){\n            //main  gc\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName()+\",num=\"+number);\n    }\n}\n```\n\n**如果不加lock和synchronized ，怎么样保证原子性？**\n\n![20200727204535517](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204535517.png)\n\n解决方法：使用JUC下的原子包下的class；\n\n![20200727204554558](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204554558.png)\n\n代码如下：\n\n```java\npublic class VDemo02 {\n\n    private static volatile AtomicInteger number = new AtomicInteger();\n\n    public static void add(){\n//        number++;\n        number.incrementAndGet();  //底层是CAS保证的原子性\n    }\n\n    public static void main(String[] args) {\n        //理论上number  === 20000\n\n        for (int i = 1; i <= 20; i++) {\n            new Thread(()->{\n                for (int j = 1; j <= 1000 ; j++) {\n                    add();\n                }\n            }).start();\n        }\n\n        while (Thread.activeCount()>2){\n            //main  gc\n            Thread.yield();\n        }\n        System.out.println(Thread.currentThread().getName()+\",num=\"+number);\n    }\n}\n```\n\n这些类的底层都直接和操作系统挂钩！是在内存中修改值。\n\nUnsafe类是一个很特殊的存在；\n\n> 原子类为什么这么高级？\n\n> 3、禁止指令重排\n\n**什么是指令重排？**\n\n我们写的程序，计算机并不是按照我们自己写的那样去执行的\n\n源代码–>编译器优化重排–>指令并行也可能会重排–>内存系统也会重排–>执行\n\n**处理器在进行指令重排的时候，会考虑数据之间的依赖性！**\n\n```java\nint x=1; //1\nint y=2; //2\nx=x+5;   //3\ny=x*x;   //4\n\n//我们期望的执行顺序是 1_2_3_4  可能执行的顺序会变成2134 1324\n//可不可能是 4123？ 不可能的\n```\n\n可能造成的影响结果：前提：a b x y这四个值 默认都是0\n\n| 线程A | 线程B |\n| ----- | ----- |\n| x=a   | y=b   |\n| b=1   | a=2   |\n\n正常的结果： x = 0; y =0;\n\n| 线程A | 线程B |\n| ----- | ----- |\n| x=a   | y=b   |\n| b=1   | a=2   |\n\n可能在线程A中会出现，先执行b=1,然后再执行x=a；\n\n在B线程中可能会出现，先执行a=2，然后执行y=b；\n\n那么就有可能结果如下：x=2; y=1.\n\n**volatile可以避免指令重排：**\n\n**volatile中会加一道内存的屏障，这个内存屏障可以保证在这个屏障中的指令顺序。**\n\n内存屏障：CPU指令。作用：\n\n1、保证特定的操作的执行顺序；\n\n2、可以保证某些变量的内存可见性（利用这些特性，就可以保证volatile实现的可见性）\n\n![20200727204653125](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204653125.png)\n\n> 总结\n\n- **volatile可以保证可见性；**\n- **不能保证原子性**\n- **由于内存屏障，可以保证避免指令重排的现象产生**\n\n面试官：那么你知道在哪里用这个内存屏障用得最多呢？**单例模式**\n\n\n\n## 18. 玩转单例模式\n\n饿汉式、DCL懒汉式\n\n> 1、饿汉式\n\n```java\n/**\n * 饿汉式单例\n */\npublic class Hungry {\n\n    /**\n     * 可能会浪费空间\n     */\n    private byte[] data1=new byte[1024*1024];\n    private byte[] data2=new byte[1024*1024];\n    private byte[] data3=new byte[1024*1024];\n    private byte[] data4=new byte[1024*1024];\n\n\n\n    private Hungry(){\n\n    }\n    private final static Hungry hungry = new Hungry();\n\n    public static Hungry getInstance(){\n        return hungry;\n    }\n\n}\n```\n\n\n\n> 2、DCL懒汉式\n\n```java\n//懒汉式单例模式\npublic class LazyMan {\n\n    private static boolean key = false;\n\n    private LazyMan(){\n        synchronized (LazyMan.class){\n            if (key==false){\n                key=true;\n            }\n            else{\n                throw new RuntimeException(\"不要试图使用反射破坏异常\");\n            }\n        }\n        System.out.println(Thread.currentThread().getName()+\" ok\");\n    }\n    private volatile static LazyMan lazyMan;\n\n    //双重检测锁模式 简称DCL懒汉式\n    public static LazyMan getInstance(){\n        //需要加锁\n        if(lazyMan==null){\n            synchronized (LazyMan.class){\n                if(lazyMan==null){\n                    lazyMan=new LazyMan();\n                    /**\n                     * 1、分配内存空间\n                     * 2、执行构造方法，初始化对象\n                     * 3、把这个对象指向这个空间\n                     *\n                     *  就有可能出现指令重排问题\n                     *  比如执行的顺序是1 3 2 等\n                     *  我们就可以添加volatile保证指令重排问题\n                     */\n                }\n            }\n        }\n        return lazyMan;\n    }\n    //单线程下 是ok的\n    //但是如果是并发的\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {\n        //Java中有反射\n//        LazyMan instance = LazyMan.getInstance();\n        Field key = LazyMan.class.getDeclaredField(\"key\");\n        key.setAccessible(true);\n        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);\n        declaredConstructor.setAccessible(true); //无视了私有的构造器\n        LazyMan lazyMan1 = declaredConstructor.newInstance();\n        key.set(lazyMan1,false);\n        LazyMan instance = declaredConstructor.newInstance();\n\n        System.out.println(instance);\n        System.out.println(lazyMan1);\n        System.out.println(instance == lazyMan1);\n    }\n}\n```\n\n\n\n> 3、静态内部类\n\n```java\n//静态内部类\npublic class Holder {\n    private Holder(){\n\n    }\n    public static Holder getInstance(){\n        return InnerClass.holder;\n    }\n    public static class InnerClass{\n        private static final Holder holder = new Holder();\n    }\n}\n```\n\n* 单例不安全, 因为反射\n\n> 4、枚举\n\n```java\n//enum 是什么？ enum本身就是一个Class 类\npublic enum EnumSingle {\n    INSTANCE;\n    public EnumSingle getInstance(){\n        return INSTANCE;\n    }\n}\n\nclass Test{\n    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        EnumSingle instance1 = EnumSingle.INSTANCE;\n        Constructor<EnumSingle> declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class);\n        declaredConstructor.setAccessible(true);\n        //java.lang.NoSuchMethodException: com.ogj.single.EnumSingle.<init>()\n\n        EnumSingle instance2 = declaredConstructor.newInstance();\n        System.out.println(instance1);\n        System.out.println(instance2);\n    }\n}\n```\n\n使用枚举，我们就可以防止反射破坏了。\n\n![20200727204727492](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204727492.png)\n\n枚举类型使用JAD最终反编译后源码：\n\n如果我们看idea 的文件：会发现idea骗了我们，居然告诉我们是有有参构造的，我们使用jad进行反编译。\n\n![20200727204751957](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727204751957.png)\n\n![2020072720480950](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072720480950.png)\n\n```java\npublic final class EnumSingle extends Enum\n{\n\n    public static EnumSingle[] values()\n    {\n        return (EnumSingle[])$VALUES.clone();\n    }\n\n    public static EnumSingle valueOf(String name)\n    {\n        return (EnumSingle)Enum.valueOf(com/ogj/single/EnumSingle, name);\n    }\n\n    private EnumSingle(String s, int i)\n    {\n        super(s, i);\n    }\n\n    public EnumSingle getInstance()\n    {\n        return INSTANCE;\n    }\n\n    public static final EnumSingle INSTANCE;\n    private static final EnumSingle $VALUES[];\n\n    static \n    {\n        INSTANCE = new EnumSingle(\"INSTANCE\", 0);\n        $VALUES = (new EnumSingle[] {\n            INSTANCE\n        });\n    }\n}\n```\n\n\n\n## 19. 深入理解CAS\n\n> 1、什么是CAS？\n\n大厂必须深入研究底层！！！！**修内功！操作系统、计算机网络原理、组成原理、数据结构**\n\n```java\npublic class casDemo {\n    //CAS : compareAndSet 比较并交换\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(2020);\n\n        //boolean compareAndSet(int expect, int update)\n        //期望值、更新值\n        //如果实际值 和 我的期望值相同，那么就更新\n        //如果实际值 和 我的期望值不同，那么就不更新\n        System.out.println(atomicInteger.compareAndSet(2020, 2021));\n        System.out.println(atomicInteger.get());\n\n        //因为期望值是2020  实际值却变成了2021  所以会修改失败\n        //CAS 是CPU的并发原语\n        atomicInteger.getAndIncrement(); //++操作\n        System.out.println(atomicInteger.compareAndSet(2020, 2021));\n        System.out.println(atomicInteger.get());\n    }\n}\n```\n\n![20200727214229852](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214229852.png)\n\n\n\n> 2、Unsafe类\n\n![20200727214247117](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214247117.png)\n\n![20200727214300255](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214300255.png)\n\n**总结：**\n\nCAS：比较当前工作内存中的值 和 主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环，使用的是自旋锁。\n\n**缺点：**\n\n- 循环会耗时；\n- 一次性只能保证一个共享变量的原子性；\n- 它会存在ABA问题\n\n> 3、CAS：ABA问题？(狸猫换太子)\n\n![20200727214320203](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214320203.png)\n\n线程1：期望值是1，要变成2；\n\n线程2：两个操作：\n\n- 1、期望值是1，变成3\n- 2、期望是3，变成1\n\n所以对于线程1来说，A的值还是1，所以就出现了问题，骗过了线程1；\n\n```java\npublic class casDemo {\n    //CAS : compareAndSet 比较并交换\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(2020);\n\n        System.out.println(atomicInteger.compareAndSet(2020, 2021));\n        System.out.println(atomicInteger.get());\n\n        //boolean compareAndSet(int expect, int update)\n        //期望值、更新值\n        //如果实际值 和 我的期望值相同，那么就更新\n        //如果实际值 和 我的期望值不同，那么就不更新\n        System.out.println(atomicInteger.compareAndSet(2021, 2020));\n        System.out.println(atomicInteger.get());\n\n        //因为期望值是2020  实际值却变成了2021  所以会修改失败\n        //CAS 是CPU的并发原语\n//        atomicInteger.getAndIncrement(); //++操作\n        System.out.println(atomicInteger.compareAndSet(2020, 2021));\n        System.out.println(atomicInteger.get());\n    }\n}\n```\n\n\n\n## 20. 原子引用\n\n> 1、解决ABA问题，对应的思想：就是使用了**乐观锁~**\n\n带版本号的 原子操作！\n\n**Integer 使用了对象缓存机制，默认范围是-128~127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间。**\n\n![20200727214340236](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214340236.png)\n\n所以如果遇到，使用大于128的时候，**使用原子引用的时候，如果超过了这个值，那么就不会进行版本上升！**\n\n![20200727214355541](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214355541.png)\n\n那么如果我们使用小于128的时候：\n\n![2020072721441445](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2020072721441445.png)\n\n正常业务操作中，我们一般使用的是一个个对象，一般情况不会遇到这种情况。\n\n\n\n## 21. 各种锁的理解\n\n------\n\n#### 21.1 公平锁、非公平锁\n\n**公平锁**：非常公平；不能插队的，必须先来后到；\n\n```java\n/**\n * Creates an instance of {@code ReentrantLock}.\n * This is equivalent to using {@code ReentrantLock(false)}.\n */\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n```\n\n**非公平锁**：非常不公平，允许插队的，可以改变顺序。\n\n```java\n/**\n * Creates an instance of {@code ReentrantLock} with the\n * given fairness policy.\n *\n * @param fair {@code true} if this lock should use a fair ordering policy\n */\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\n\n\n#### 21.2 可重入锁\n\n可重入锁(递归锁)\n\n![20200727214440726](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214440726.png)\n\n> 1、Synchronized锁\n\n```java\npublic class Demo01 {\n    public static void main(String[] args) {\n        Phone phone = new Phone();\n        new Thread(()->{\n            phone.sms();\n        },\"A\").start();\n        new Thread(()->{\n            phone.sms();\n        },\"B\").start();\n    }\n\n}\n\nclass Phone{\n    public synchronized void sms(){\n        System.out.println(Thread.currentThread().getName()+\"=> sms\");\n        call();//这里也有一把锁\n    }\n    public synchronized void call(){\n        System.out.println(Thread.currentThread().getName()+\"=> call\");\n    }\n}\n```\n\n> 2、lock锁\n\n```java\n//lock\npublic class Demo02 {\n\n    public static void main(String[] args) {\n        Phone2 phone = new Phone2();\n        new Thread(()->{\n            phone.sms();\n        },\"A\").start();\n        new Thread(()->{\n            phone.sms();\n        },\"B\").start();\n    }\n\n}\nclass Phone2{\n\n    Lock lock=new ReentrantLock();\n\n    public void sms(){\n        lock.lock(); //细节：这个是两把锁，两个钥匙\n        //lock锁必须配对，否则就会死锁在里面\n        try {\n            System.out.println(Thread.currentThread().getName()+\"=> sms\");\n            call();//这里也有一把锁\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n    public void call(){\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \"=> call\");\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n- lock锁必须配对，相当于lock和 unlock 必须数量相同；\n- 在外面加的锁，也可以在里面解锁；在里面加的锁，在外面也可以解锁；\n\n\n\n#### 21.3 自旋锁\n\n* spinlock\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n```\n\n**自我设计自旋锁：**\n\n```java\npublic class SpinlockDemo {\n\n    //int 0\n    //thread null\n    AtomicReference<Thread> atomicReference=new AtomicReference<>();\n\n    //加锁\n    public void myLock(){\n        Thread thread = Thread.currentThread();\n        System.out.println(thread.getName()+\"===> mylock\");\n\n        //自旋锁\n        while (!atomicReference.compareAndSet(null,thread)){\n            System.out.println(Thread.currentThread().getName()+\" ==> 自旋中~\");\n        }\n    }\n\n\n    //解锁\n    public void myunlock(){\n        Thread thread=Thread.currentThread();\n        System.out.println(thread.getName()+\"===> myUnlock\");\n        atomicReference.compareAndSet(thread,null);\n    }\n\n}\n\npublic class TestSpinLock {\n    public static void main(String[] args) throws InterruptedException {\n        ReentrantLock reentrantLock = new ReentrantLock();\n        reentrantLock.lock();\n        reentrantLock.unlock();\n\n\n        //使用CAS实现自旋锁\n        SpinlockDemo spinlockDemo=new SpinlockDemo();\n        new Thread(()->{\n            spinlockDemo.myLock();\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                spinlockDemo.myunlock();\n            }\n        },\"t1\").start();\n\n        TimeUnit.SECONDS.sleep(1);\n\n\n        new Thread(()->{\n            spinlockDemo.myLock();\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                spinlockDemo.myunlock();\n            }\n        },\"t2\").start();\n    }\n}\n```\n\n运行结果：\n\n**t2进程必须等待t1进程Unlock后，才能Unlock，在这之前进行自旋等待。。。。**\n\n![20200727214506875](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214506875.png)\n\n\n\n#### 21.4 死锁\n\n> 1、死锁是什么？\n\n![20200727214526330](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214526330.png)\n\n死锁测试，怎么排除死锁：\n\n```java\npackage com.ogj.lock;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class DeadLock {\n    public static void main(String[] args) {\n        String lockA= \"lockA\";\n        String lockB= \"lockB\";\n\n        new Thread(new MyThread(lockA,lockB),\"t1\").start();\n        new Thread(new MyThread(lockB,lockA),\"t2\").start();\n    }\n}\n\nclass MyThread implements Runnable{\n\n    private String lockA;\n    private String lockB;\n\n    public MyThread(String lockA, String lockB) {\n        this.lockA = lockA;\n        this.lockB = lockB;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockA){\n            System.out.println(Thread.currentThread().getName()+\" lock\"+lockA+\"===>get\"+lockB);\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lockB){\n                System.out.println(Thread.currentThread().getName()+\" lock\"+lockB+\"===>get\"+lockA);\n            }\n        }\n    }\n}\n```\n\n> 2、解决问题\n\n**1、使用jps定位进程号，jdk的bin目录下： 有一个jps**\n\n命令：`jps -l`\n\n![20200727214547987](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214547987.png)\n\n**2、使用`jstack` 进程进程号 找到死锁信息**\n\n![20200727214602212](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214602212.png)\n\n**一般情况信息在最后：**\n\n![20200727214617429](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20200727214617429.png)\n\n', '关于JUC的完整笔记', 5, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/6bb9a115-fb78-4896-894b-b79792cdcc27.jpg', '1', '0', 244, '0', 1, '2023-02-21 22:27:50', 1, '2023-02-21 22:27:50', 0);
INSERT INTO `sg_article` VALUES (11, 'JVM完整笔记', '# JVM\n\n## 1.JVM概述\n\n### 1.1 JVM 常问面试题\n\n- 请你谈谈你对JVM的理解？Java8虚拟机和之前的变化更新？\n\n  java—>class---->jvm\n\n- 什么是OOM 内存溢出？什么是栈溢出StackOverFlowError？ 怎么分析？\n\n- JVM 的常用调优参数有哪些？\n\n- 内存快照如何抓取，怎么分析Dump文件？\n\n- 谈谈JVM中，类加载器你的认识？\n\n\n\n### 1.2 JVM概念\n\nJVM是**Java Virtual Machine**（Java虚拟机）的缩写。\n\n虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。\n简单来说JVM是用来解析和运行Java程序的。\nJava语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。\n\n\n\n### 1.3 JVM的位置\n\n![2021051914191961](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2021051914191961.png)\n\n**三种JVM:**\n\n- Sun公司：HotSpot 用的最多(HostSpot Java HotSpot™ 64-Bit Server VM (build 25.101-b13, mixed mode))\n- BEA：JRockit\n- IBM：J9VM\n\n我们学习都是：**HotSpot**\n\n\n\n## 2. JVM体系结构\n\n* JVM体系结构（重要）\n\n![](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519142056501.png)\n\n**Jvm调优：99%都是在方法区和堆，大部分时间调堆。** JNI（java native interface）本地方法接口\n\n![20210519142216593](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519142216593.png)\n\n作用：加载Class文件~ 如果new Student();（具体实例在堆里，引用变量名放栈里）\n\n![20210519142253192](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519142253192.png)\n\n![755316a0d0de458bade1e2dfbf18f909](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/755316a0d0de458bade1e2dfbf18f909.png)\n\n![4c7e9452e4ec4c63b68ad65e143032a5](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/4c7e9452e4ec4c63b68ad65e143032a5.png)\n\n![48efbae4c45d42e9a264a51c0205c8d0](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/48efbae4c45d42e9a264a51c0205c8d0.png)\n\n1. 虚拟机自带的加载器\n2. 启动类（根）加载器\n3. 扩展类加载器\n4. 应用程序加载器\n\n![2021051914263155](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2021051914263155.png)\n\n\n\n\n\n## 3.双亲委派机制\n\n第一步：类加载器收到类加载的请求\n  第二步：将这个请求向上委托给父类加载器去完成 ，一直向上委托，直到启动类加载器（Boot）\n  第三步：启动类加载器检查是否能够加载当前和这个类 ，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载。\n  第四步：重复 第三步 步骤。\n\nnull ： java调用不到 ~C 、C++\n    Java = C++ ： 去掉繁琐的东西，指针，内存管理。\n    Java = C+±-\n\n参考：https://www.jianshu.com/p/1e4011617650\n\n==概念：==当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。\n\n==例子：==当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。\n\n![20210519142753949](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519142753949.png)\n\n**作用：**\n\n1、防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。\n2、保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。\n\n比如：如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。\n\n**总结：**\n\n![8edf401857a64b469744678b7476918b](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/8edf401857a64b469744678b7476918b.png)\n\n\n\n## 4. 沙箱安全机制\n\n> 1、概述\n\n![2021051914324762](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2021051914324762.png)\n\n![20210519143253724](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143253724.png)\n\n![20210519143259343](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143259343.png)\n\n![20210519143308674](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143308674.png)\n\n\n\n> 2、组成沙箱的基本组件：\n\n- **字节码校验器**（bytecode verifier）：确保Java类文件`.Class`遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。\n\n- 类装载器\n\n  （class loader）：其中类装载器在3个方面对Java沙箱起作用\n\n  - 它防止恶意代码去干涉善意的代码；\n  - 它守护了被信任的类库边界；\n  - 它将代码归入保护域，确定了代码可以进行哪些操作。\n\n虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。\n\n类装载器采用的机制是**双亲委派模式**。\n\n1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；\n2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。\n\n- **存取控制器**（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。\n- **安全管理器**（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。\n- **安全软件包**（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：\n\n  1. 安全提供者\n\n 2. 消息摘要\n\n 3. 数字签名 keytools https(需要证书)\n\n 4. 加密\n\n  5. 鉴别\n\n\n\n## 5. Native【*】\n\nNative是核心，能把面试官唬住的东西。\n\n![3bf57f0117804262b905d9c9b603fd7c](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/3bf57f0117804262b905d9c9b603fd7c.png)\n\n凡是带了native 关键字的，说明java的作用范围达不到了，得回去调用底层C语言的库！\n\n凡是带了native 关键字的方法会进入**本地方法栈**，其它的是java栈\n\n**JNI：Java Native Interface（本地方法接口）**\n\n调用本地方法接口（JNI）作用：\n\n扩展java的使用，融合不同的编程语言为java所用\njava诞生的初衷是**融合C/C++程序**，C、C++横行，想要立足，必须要有调用C、C++的程序~\n它在内存区城中专门开辟了块标记区城: **Native Method Stack**\n\n**Native Method Stack（本地方法栈）**：\n\n登 记native 方法，在执行引擎（Execution Engine）执行的时候。通过JNI 加载**本地方法库(Native Libraies)**中的方法。\n\n在企业级应用中少见，与硬件有关应用：java程序驱动打印机，系统管理生产设备等，掌握即可\n\n\n\n## 6. PC寄存器\n\n**程序计数器: Program Counter Register**：\n\n每个线程都有一个程序计数器，是线程私有的，就是一个指针， 指向方法区中的方法字节码 ( 用来存储指向下一条指令的地址， 也即将要执行的指令代码 )， 在执行引擎读取下一条指令,是一个非常小的内存空间，几乎可以忽略不计。\n\n\n\n## 7. 方法区\n\n**Method Area方法区：**\n\n方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间；\n\n==**静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关**。==\n\n如：static，final，Class（类模板）, 常量池\n\n面试题：一张白纸，画出对象实例化过程的内存图。（主要是考你对JVM的理解）\n![image-20230206162209291](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230206162209291.png)\n\n类模板，常量池，引用的话进入左边，去引入真实的对象\n\n\n\n## 8. 栈\n\n1. 栈：数据结构\n   程序=数据结构+算法：持续学习~\n   程序=框架+业务逻辑：吃饭~\n2. 栈：**先进后出、后进先出**：桶\n   队列：先进先出 ( FIFO )：管\n   喝多了吐就是栈，吃多了拉就是队列\n   为什么main() 先执行，最后结束? （因为一开始**mian()先压入栈**）\n3. 栈：栈内存，主管程序的运行，生命周期和线程同步;\n   线程结束，栈内存也就是释放，**对于栈来说，不存在垃圾回收问题**\n   一旦线程结束，栈就Over!\n4. 栈存放：8大基本类型+对象引用+实例的方法\n   栈运行原理：栈帧（局部变量表+操作数栈）**每调用一个方法都有一个栈帧**\n   栈满了 main()无法结束，会抛出错误：**栈溢出 StackOverflowError**\n\n![20210519143555371](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143555371.png)\n\n**栈帧图：**\n\n![20210519143605615](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143605615.png)\n\n栈 + 堆 + 方法区：交互关系\n\n![20210519143615800](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143615800.png)\n\n\n\n## 9. 堆【*】\n\nHeap：一个JVM只有一个堆内存，堆的大小是可以调节的。\n\n类加载器读取了类文件后，一般会把什么东西放到堆中？\n\n类，方法，常量，变量~，保存所有引用类型的真实对象\n\n堆内存细分3个区域：\n\n- 新生区（伊甸园区） Young/new\n- 养老区 old\n- 永久区 Perm\n\n![20210519143715995](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143715995.png)\n\n**GC垃圾回收，主要是在伊甸园区和养老区~**\n\n**假设内存满了，报错OOM，堆内存不够！**OutOfMemoryError:Java heap space\n\n**在JDK8以后，永久存储区改了个名字(元空间)**\n\n![20210519143734310](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143734310.png)\n\n\n\n### 9.1 新生区、老年区、永久区\n\n> **新生区**（伊甸园+幸存者区*2）\n\n- 类诞生和成长甚至死亡的地方；\n- 伊甸园，所有对象都是在伊甸园区new出来的！\n- 幸存者区（0, 1），**轻GC**定期清理伊甸园，活下来的放入幸 存者区，幸存者区满了之后**重GC**清理 伊甸园+幸存者区，活下来的放入养老区。都满了就报OOM。\n\n真理：经过研究，99%的对象都是临时对象！直接被清理了\n\n> **老年区：** 新生区剩下来的，轻GC杀不死了。\n\n> **永久区：**\n\n这个区域常驻内存，用来存放JDK自身携带的Class对象，Interface元数据，存储的是==java运行时的一些环境或类信息==，**该区域不存在垃圾回收GC**。**关闭虚拟机就会释放这个内存。**\n\n- jdk1.6之前：永久代，常量池在方法区\n- jdk1.7：永久代，但是慢慢退化了（去永久代）常量池在堆中\n- jdk1.8之后：无永久代，常量池在元空间\n\n一个启动类,加载了大量的第三方jar包。Tomcat部署了太多的应用，大量动态生成的反射类。不断的被加载。直到内存满，就会出现OOM。\n\n![20210519143915826](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519143915826.png)\n\n方法区又称非堆(non-heap)，本质还是堆，只是为了区分概念。\n\n**元空间逻辑上存在，物理上并不存在。**\n\n* 测试JVM分配的堆内存\n\n![0a262b2f4d6c4355bc3a37ef18e1cec6](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/0a262b2f4d6c4355bc3a37ef18e1cec6.png)\n\n* 堆内存分配结论：\n\n![cac0d6f830c047cbb205fa16bf9aab98](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/cac0d6f830c047cbb205fa16bf9aab98.png)\n\n* 参数调优\n\n```java\n-Xms1024m -Xmx1024m -XX:+printGCDetails\n```\n\n![image-20230206173649289](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230206173649289.png)\n\n* 参数调优结果\n\n![f4b1569f4eee4270ba525e20f70d56f2](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/f4b1569f4eee4270ba525e20f70d56f2.png)\n\n\n\n**扩展：**\n\n![2021051914394522](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/2021051914394522.png)\n\n一句话：常量池一直在方法区，其中的字符串池 JDK1.7之后保存到了堆中。\n\n\n\n### 9.2 堆内存调优\n\n```java\npublic static void main(String[] args) {\n    //返回虚拟机试图使用的最大内存\n    long max = Runtime.getRuntime().maxMemory(); //字节 1024*1024\n    //返回jvm初始化的总内存\n    long total = Runtime.getRuntime().totalMemory();\n\n    System.out.println(\"max=\"+max+\"字节\\t\"+(max/(double)1024/1024+\"MB\"));\n    System.out.println(\"total=\"+total+\"字节\\t\"+(total/(double)1024/1024+\"MB\"));\n    /* 运行后：\n    max=1866465280字节   1780.0MB\n    total=126877696字节  121.0MB\n     */\n    //默认情况下，分配的总内存占电脑内存1/4 初始化1/64\n}\n```\n\n//面试题：报OOM怎么办？\n\n```java\n/*\n1.尝试扩大堆内存，如果还报错，说明有死循环代码 或垃圾代码\n2.分析内存，看一下哪个地方有问题（专业工具）\n*/\n```\n\n扩大内存方法：\n\nEdit Configration>add VM option>输入：-Xms1024m -Xmx1024m -XX:+PrintGCDetails\n\n再次运行：\n\n![20210519144017383](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144017383.png)\n\n**新生区+养老区**：305664K+699392K=1005056K = **981.5M**\n\n说明元空间物理并不存在。\n\n例子2：死循环 OOM\n\n```java\n//-Xms8m -Xmx8m -XX:+PrintGCDetails\npublic static void main(String[] args) {\n    String str = \"kuangshensayjava\";\n\n    while (true){\n        str += str + new Random().nextInt(888888888)+ new Random().nextInt(21_0000_0000);\n    }\n}\n```\n\n![20210519144052116](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144052116.png)\n\n\n\n### 9.3 Jprofiler\n\n在一个项目中，突然出现了OOM故障，该如何排除，研究为什么出错~\n\n- 能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler\n- Debug，一行行分析代码！\n\nMAT，Jprofiler作用：\n\n- 分析Dump内存文件，快速定位内存泄漏；\n- 获得堆中的数据\n- 获得大的对象（大厂面试）\n- …\n\n```java\n//-Xms 设置初始化内存分配大小 默认1/64\n//-Xmx 设置最大分配内存，默认1/4\n//-XX:+PrintGCDetails 打印GC垃圾回收信息\n//-XX:+HeapDumpOnOutOfMemoryError oom DUMP\n\n//-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError\npublic class Demo03 {\n\n    byte[] array = new byte[1*1024*1024]; //1m\n\n    public static void main(String[] args) {\n        ArrayList<Demo03> list = new ArrayList<>();\n        int count = 0;\n\n        try {\n            while (true){\n                list.add(new Demo03()); //不停地把创建对象放进列表\n                count = count + 1;\n            }\n        } catch (Exception e) {\n            System.out.println(\"count: \"+count);\n            e.printStackTrace();\n        }\n\n    }\n}\n```\n\n![20210519144136644](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144136644.png)\n\n![20210519144145433](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144145433.png)\n\n\n\n## 10. GC：垃圾回收【*】\n\n![20210519144158119](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144158119.png)\n\nJVM在进行GC时，并不是对这三个区域统一回收。大部分时候回收的是新生代\n\n- 新生代\n- 幸存区\n- 老年区\n\nGC两种：轻GC，重GC (Full GC，全局GC)\n\n关于GC面试题：\n\n- JVM的内存模型和分区~详细到每个分区放什么？\n- 堆里面的分区有哪些？Eden, from, to, 老年区，说说它们的特点！\n- GC算法有哪些？怎么用的？\n  - **标记清除法**，标记整理，**复制算法**，分代收集法。\n  - 引用计数法。\n- 轻GC与重GC分别在什么时候发生？\n\n**引用计数法**：一般JVM不用，大型项目对象太多了\n\n![20210519144213255](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144213255.png)\n\n\n\n### 10.1 复制算法\n\n- -XX:MaxTenuringThreshold=15 设置进入老年代的存活次数条件\n\n![20210519144226563](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144226563.png)\n\n![20210519144340576](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144340576.png)\n\n- 好处：没有内存的碎片，内存效率高\n- 坏处：浪费了内存空间（一个幸存区永远是空的）；假设对象100%存活，复制成本很高。\n\n复制算法最佳使用场景：对象存活度较低 的时候，**新生区**~。\n\n\n\n### 10.2 标记清除算法\n\n* 标记清除\n\n![20210519144349111](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144349111.png)\n\n- 优点：不需要额外空间，优化了复制算法。\n- 缺点：两次扫描，严重浪费时间，会产生内存碎片。\n\n标记压缩（标记整理）**：再优化**\n\n- 三部曲：标记–清除–压缩\n\n![20210519144401194](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20210519144401194.png)\n\n标记清除压缩：再优化\n\n- 每标记清除几次就压缩一次，或者内存碎片积累到一定程度就压缩。\n\n\n\n### 10.3 总结\n\n内存效率：复制算法>标记清除算法>标记压缩算法（时间复杂度）\n\n内存整齐度：复制算法=标记压缩算法>标记清除算法\n\n内存利用率：标记压缩算法=标记清除算法>复制算法\n\n难道没有最优算法吗？\n\n答案：无，没有最好的算法，只有合适的算法（GC也被称为**分代收集算法**）。\n\n- 年轻代：存活率低，用**复制算法**。\n- 老年代：存活率高，区域大，用**标记-清除-压缩**。\n\n参考和研究：《深入理解Java虚拟机》\n\n\n\n## 11. JMM\n\n1. 什么是JMM? ：百度\n\n   java内存模型 Java Memory Model\n\n2. 它干嘛的？ 学习途径：官方，其他人的博客，教学视频\n\n   https://www.sohu.com/a/420276955_612370\n\n   作用：缓存一致性协议，用于定义数据读写的规则。\n\n   JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的私有变量存储在主内存中， 每个线程都有一个私有的本地变量。\n\n   ![image-20230206203049140](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230206203049140.png)\n\n   解决共享对象可见性这个问题:volilate\n\n3. 如何学会它？\n\n- lock(锁定)，作用于**主内存**中的变量，把变量标识为线程独占的状态。\n- read(读取)，作用于**主内存**的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。\n- load(加载)，作用于**工作内存**的变量，把read操作主存的变量放入到工作内存的变量副本中。\n- use(使用)，作用于**工作内存**的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。\n- assign(赋值)，作用于**工作内存**的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。\n- store(存储)，作用于**工作内存**的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。\n- write(写入)：作用于**主内存**中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。\n- unlock(解锁)：作用于**主内存**的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n\n\n\n> 我再补充一下JMM对8种内存交互操作制定的规则吧：\n\n- 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。\n- 不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。\n- 不允许线程将没有assign的数据从工作内存同步到主内存。\n- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。\n- 一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。\n- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。\n- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。\n- 一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。\n  再补充一下JMM对8种内存交互操作制定的规则吧：\n- 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。\n- 不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。\n- 不允许线程将没有assign的数据从工作内存同步到主内存。\n- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。\n- 一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。\n- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。\n- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。\n- 一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。', '关于JVM的完整笔记', 5, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/b3fbf5fa-54dd-45c0-8d35-56b9bc5fdbaa.jpg', '1', '0', 126, '0', 1, '2023-02-21 22:33:48', 1, '2023-02-21 22:33:48', 0);
INSERT INTO `sg_article` VALUES (12, '数据结构与算法完整笔记', '# 数据结构与算法\n\n# 1. 算法初体验\n\n在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。总体上，一个优秀的算 法追求以下两个目标：\n\n1. 花最少的时间完成需求；\n\n2. 占用最少的内存空间完成需求；\n\n下面我们用一些实际案例体验一些算法：\n\n\n\n> 1、计算1到100的和\n\n* 第一种解法\n\n```java\npublic static void main(String[] args) {\n	int sum = 0;\n	int n=100;\n	for (int i = 1; i <= n; i++) {\n		sum += i;\n	}\n	System.out.println(\"sum=\" + sum);\n}\n```\n\n* 第二种解法\n\n```java\npublic static void main(String[] args) {\n    int sum = 0;\n    int n=100;\n    sum = (n+1)*n/2;\n    System.out.println(\"sum=\"+sum);\n}\n```\n\n第一种解法要完成需求，要完成以下几个动作：\n\n1. 定义两个整型变量；\n\n2. 执行100次加法运算；\n\n3. 打印结果到控制台；\n\n第二种解法要完成需求，要完成以下几个动作：\n\n1. 定义两个整型变量；\n\n2. 执行1次加法运算，1次乘法运算，一次除法运算，总共3次运算；\n\n3. 打印结果到控制台；\n\n很明显，第二种算法完成需求，花费的时间更少一些。\n\n\n\n> 2、计算10的阶乘\n\n* 第一种解法\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        //测试，计算10的阶乘\n        long result = fun1(10);\n        System.out.println(result);\n    }\n    //计算n的阶乘\n    public static long fun1(long n){\n        if (n==1){\n            return 1;\n        }\n        return n*fun1(n-1);\n    }\n}\n```\n\n* 第二种解法\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        //测试，计算10的阶乘\n        long result = fun2(10);\n        System.out.println(result);\n    }\n    //计算n的阶乘\n    public static long fun2(long n){\n        int result=1;\n        for (long i = 1; i <= n; i++) {\n            result*=i;\n        }   \n        return result;\n    }\n}\n```\n\n第一种解法，使用递归完成需求，fun1方法会执行10次，并且第一次执行未完毕，调用第二次执行，第二次执行未完毕，调用第三次执行...最终，最多的时候，需要在栈内存同时开辟10块内存分别执行10个fun1方法。\n\n第二种解法，使用for循环完成需求，fun2方法只会执行一次，最终，只需要在栈内存开辟一块内存执行fun2方法即可。\n\n很明显，第二种算法完成需求，占用的内存空间更小。\n\n\n\n# 2. 算法分析\n\n## 2.1 时间复杂度分析\n\n> 1、事后分析估算方法：\n\n* 测试开销大\n* 在不同的测试环境的结果差异大\n\n```java\npublic static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    \n    int sum = 0;\n    int n=100;\n    for (int i = 1; i <= n; i++) {\n   		sum += i;\n    }\n    System.out.println(\"sum=\" + sum);\n   \n    long end = System.currentTimeMillis();\n    System.out.println(end-start);\n}\n```\n\n\n\n> 2、事前分析估算方法：\n\n* 一个程序的运行时间依赖于算法的好坏和问题的输入规模！！\n\n因此，在我们比较算法随着输入规模的增长量时，可以有以下规则：\n\n1. 算法函数中的常数可以忽略；\n\n2. 算法函数中最高次幂的常数因子可以忽略；\n\n3. 算法函数中最高次幂越小，算法效率越高。\n\n\n\n> 3、大O记法\n\n| **描述**     | **增长的数量级** | **说明** | **举例**       |\n| ------------ | ---------------- | -------- | -------------- |\n| 常数级别     | 1                | 普通语句 | 将两个数相加   |\n| 对数级别     | logn             | 二分策略 | 二分查找       |\n| 线性级别     | n                | 循环     | 找出最大元素   |\n| 线型对数级别 | nlogn            | 分治思想 | 归并排序       |\n| 平方级别     | n^2              | 双层循环 | 检查所有元素对 |\n| 立方级别     | n^3              | 三层循环 | 检查所有三元组 |\n| 指数级别     | 2^n              | 穷举查找 | 检查所有子集   |\n\n他们的复杂程度从低到高依次为：\n\nO(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)\n\n从平方阶开始，随着输入规模的增大，时间成本会急剧增大，所以，我们的 算法，尽可能的追求的是**O(1),O(logn),O(n),O(nlogn)**这几种时间复杂度，而如果发现算法的时间复杂度为**平方阶、 立方阶或者更复杂的**，那我们可以分为这种算法是不可取的，需要优化。\n\n\n\n> 4、时间复杂度计算（举例）\n\n1. 对数阶\n\n```java\nint i=1,n=100;\n\nwhile(i<n){\n    i = i*2;\n}\n```\n\n2. 函数调用\n\n```java\npublic static void main(String[] args) {\n    int n=100;\n    for (int i = 0; i < n; i++) {\n   	 show(i);\n    }\n}\nprivate static void show(int i) {\n    for (int j = 0; j < i; i++) {\n   	 System.out.println(i);\n    }\n}\n```\n\n在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环，所以show方法   的时间复杂度为O(n),那main方法的时间复杂度为O(n^2)\n\n3. 最坏情况\n\n```java\npublic int search(int num){\n    int[] arr={11,10,8,9,7,22,23,0};\n    for (int i = 0; i < arr.length; i++) {\n        if (num==arr[i]){\n       		return i;\n        }\n    }\n    return -1;\n}\n```\n\n* **最好情况：**\n\n查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1)\n\n* **最坏情况：**\n\n查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)\n\n* **平均情况：**\n\n任何数字查找的平均成本是O(n/2)\n\n最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。\n\n\n\n## 2.2 空间复杂度分析\n\n> 1、基本数据类型内存占用情况\n\n| **数据类型** | **内存占用字节数** |\n| ------------ | ------------------ |\n| byte         | 1                  |\n| short        | 2                  |\n| int          | 4                  |\n| long         | 8                  |\n| ﬂoat         | 4                  |\n| double       | 8                  |\n| boolean      | 1                  |\n| char         | 2                  |\n\n1. 计算机访问内存的方式都是一次一个字节\n\n2. 一个引用（机器地址）需要8个字节表示：\n\n例如： Date date = new Date(),则date这个变量需要占用8个字节来表示\n\n3. 创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。\n\n4. 一般内存的使用，如果不够8个字节，都会被自动填充为8字节：\n\n![image-20220713220056909](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220713220056909.png)\n\n\n\n> 2、算法的空间复杂度\n\n对指定的数组元素进行反转，并返回反转的内容。\n\n* 解法一：\n\n```java\npublic static int[] reverse1(int[] arr){\n    int n=arr.length;//申请4个字节\n    int temp;//申请4个字节\n    for(int start=0,end=n-1;start<=end;start++,end--){\n        temp=arr[start];\n        arr[start]=arr[end];\n        arr[end]=temp;\n    }\n    return arr;\n}\n```\n\n* 解法二：\n\n```java\npublic static int[] reverse2(int[] arr){\n    int n=arr.length;//申请4个字节\n    int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节\n    for (int i = n-1; i >=0; i--) {\n    temp[n-1-i]=arr[i];\n    }\n    return temp;\n}\n```\n\n忽略判断条件占用的内存，我们得出的内存占用情况如下：\n\n 算法一：不管传入的数组大小为多少，始终额外申请4+4=8个字节；\n\n 算法二：4+4n+24=4n+28;\n\n由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，**默认为算法的时间复杂度**。\n\n但是，如果你做的程序是**嵌入式开发**，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几kb，这个时候**对算法的空间复杂度就有要求**了，但是一般**做java开发**的，基本上都是服务器开发，**一般不存在这样的问题**。\n\n\n\n# 3. 排序算法\n\n> 1、编写算法的方法\n\n在java的开发工具包jdk中，已经给我们提供了很多数据结构与算法的实现，比如List，Set，Map，Math等等，都  是以API的方式提供，这种方式的好处在于一次编写，多处使用。我们借鉴jdk的方式，也把算法封装到某个类中，那如果是这样，在我们写java代码之前，就需要先进行API的设计，设计好之后，再对这些API进行实现。\n\n* 设计一套API：（开发的方法）\n\n| **类名** | **ArrayList**                                |\n| -------- | -------------------------------------------- |\n| 构造方法 | ArrayList()：创建ArrayList对象               |\n| 成员方法 | 1.boolean add(E  e)：向集合中添加元素        |\n|          | 2.E remove(int index):从集合中删除指定的元素 |\n\n\n\n> 2、Comparable接口介绍\n\n由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序规则的。\n\n\n\n## 3.1 冒泡排序\n\n冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法\n\n> 1、需求\n\n排序前：{4,5,6,3,2,1}\n\n排序后：{1,2,3,4,5,6}\n\n> 2、排序原理：\n\n1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。\n\n2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值\n\n\n![image-20220713221344533](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220713221344533.png)\n\n> 3、冒泡排序API设计：\n\n| **类名** | **Bubble**                                                   |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Bubble()：创建Bubble对象                                     |\n| 成员方法 | 1. public static  void sort(Comparable[] a)：对数组内的元素进行排序 |\n|          | 2. private static boolean greater(Comparable v,Comparable w):判断v是否大于w |\n|          | 3. private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |\n\n> 4、代码实现\n\n```java\n//冒泡排序\npublic class Bubble {\n    //对数组a中的元素进行排序\n    public static void sort(Comparable[] a){\n        for(int i=a.length-1;i>0;i--){\n            for(int j=0;j<i;j++){\n                if(greater(a[j],a[j+1])){\n                    exch(a,j,j+1);\n                }\n            }\n        }\n    }\n\n    //比较v元素是否大于w元素\n    private static boolean greater(Comparable v,Comparable w){\n        return v.compareTo(w)>0;\n    }\n\n    //数组元素i和j交换位置\n    private static void exch(Comparable[] a,int i,int j){\n        Comparable t=a[i];\n        a[i]=a[j];\n        a[j]=t;\n    }\n}\n\n//测试代码\nclass Test01 {\n    public static void main(String[] args) {\n        Integer[] a = {4, 5, 6, 3, 2, 1};\n        Bubble.sort(a);\n        System.out.println(Arrays.toString(a));\n    }\n}\n```\n\n总执行次数为： (N^2/2-N/2)+(N^2/2-N/2)=N^2-N; 按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2).\n\n\n\n## 3.2 选择排序\n\n选择排序是一种更加简单直观的排序方法。\n\n> 1、需求：\n\n排序前：{4,6,8,7,9,2,10,1}\n\n排序后：{1,2,4,5,7,8,9,10}\n\n> 2、排序原理：\n\n1. 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引\n\n2. 交换第一个索引处和最小值所在的索引处的值\n\n![image-20220713222023877](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220713222023877.png)\n\n> 3、选择排序API设计：\n\n| **类名** | **Selection**                                                |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Selection()：创建Selection对象                               |\n| 成员方法 | 1. public static  void sort(Comparable[] a)：对数组内的元素进行排序 |\n|          | 2. private static  boolean greater(Comparable v,Comparable w):判断v是否大于w |\n|          | 3. private static  void exch(Comparable[] a,int  i,int j)：交换a数组中，索引i和索引j处的值 |\n\n> 4、选择排序的代码实现\n\n```java\n//选择排序\npublic class Selection {\n    //对数组a中的元素进行排序\n    public static void sort(Comparable[] a){\n        for(int i=0;i<a.length-1;i++){\n            //假定本次遍历，最小值所在的索引是i\n            int minIndex=i;\n            for(int j=i+1;j<a.length;j++){\n                if(greater(a[minIndex],a[j])){\n                    //跟换最小值所在的索引\n                    minIndex=j;\n                }\n            }\n            //交换i索引处和minIndex索引处的值\n            exch(a,i,minIndex);\n        }\n    }\n\n    //比较v元素是否大于w元素\n    private static boolean greater(Comparable v,Comparable w){\n        return v.compareTo(w)>0;\n    }\n\n    //数组元素i和j交换位置\n    private static void exch(Comparable[] a,int i,int j){\n        Comparable t = a[i];\n        a[i]=a[j];\n        a[j]=t;\n    }\n}\n\n//测试代码\nclass Test02{\n    public static void main(String[] args) {\n        Integer[] a = {4,6,8,7,9,2,10,1};\n        Selection.sort(a);\n        System.out.println(Arrays.toString(a));\n    }\n}\n```\n\n时间复杂度：N^2/2-N/2+（N-1）=N^2/2+N/2-1;\n\n根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);\n\n\n\n## 3.3 插入排序\n\n插入排序（Insertion sort）是一种简单直观且稳定的排序算法。\n\n> 1、需求：\n\n排序前：{4,3,2,10,12,1,5,6}\n\n排序后：{1,2,3,4,5,6,10,12}\n\n> 2、排序原理：\n\n1. 把所有的元素分为两组，已经排序的和未排序的；\n\n2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入；\n\n3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待 插入元素放到这个位置，其他的元素向后移动一位；\n\n![image-20220713222924807](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220713222924807.png)\n\n> 3、插入排序API设计\n\n| **类名** | **Insertion**                                                |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Insertion()：创建Insertion对象                               |\n| 成员方法 | 1.  public static  void sort(Comparable[] a)：对数组内的元素进行排序 |\n|          | 2.  private static  boolean greater(Comparable v,Comparable w):判断v是否大于w |\n|          | 3.  private static  void exch(Comparable[] a,int  i,int j)：交换a数组中，索引i和索引j处的值 |\n\n> 4、插入排序代码实现\n\n```java\npublic class Insertion {\n\n	//对数组a中的元素进行排序\n    public static void sort(Comparable[] a){\n        for (int i=1;i<a.length;i++){\n            //当前元素为a[i],依次和i前面的元素比较，找到一个小于等于a[i]的元素\n            for (int j=i;j>0;j--){\n                if (greater(a[j-1],a[j])){\n                    //交换元素\n                    exch(a,j-1,j);\n                }else {\n                    //找到了该元素，结束\n                    break;\n                }\n            }\n        }\n    }\n\n	//比较v元素是否大于w元素\n    private static boolean greater(Comparable v,Comparable w){\n    return v.compareTo(w)>0;\n    }\n\n	//数组元素i和j交换位置\n    private static void exch(Comparable[] a,int i,int j){\n        Comparable t = a[i];\n        a[i]=a[j];\n        a[j]=t;\n    }\n}\n```\n\n总执行次数为：(N^2/2-N/2)+(N^2/2-N/2)=N^2-N;\n\n按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(N^2).\n\n\n\n## 3.4 希尔排序\n\n希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本。\n\n> 1、需求：\n\n排序前：{9,1,2,5,7,4,8,6,3,5}\n\n排序后：{1,2,3,4,5,5,6,7,8,9}\n\n> 2、排序原理：\n\n1. 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；\n\n2. 对分好组的每一组数据完成插入排序；\n\n3. 减小增长量，最小减为1，重复第二步操作\n\n![image-20220713223346825](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220713223346825.png)\n\n增长量h的确定：增长量h的值每一固定的规则，我们这里采用以下规则：\n\n```java\nint h=1\nwhile(h<5){\n	h=2h+1；//3,7\n}\n\n//循环结束后我们就可以确定h的最大值；\nh的减小规则为：h=h/2\n```\n\n> 3、希尔排序的API设计：\n\n| **类名** | **Shell**                                                    |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Shell()：创建Shell对象                                       |\n| 成员方法 | 1.  public static  void sort(Comparable[] a)：对数组内的元素进行排序 |\n|          | 2.  private static  boolean greater(Comparable v,Comparable w):判断v是否大于w |\n|          | 3.  private static  void exch(Comparable[] a,int  i,int j)：交换a数组中，索引i和索引j处的值 |\n\n> 4、希尔排序的代码实现\n\n```java\n//排序代码\npublic class Shell {\n\n    //对数组a中的元素进行排序\n    public static void sort(Comparable[] a){\n        int N = a.length;\n        //确定增长量h的最大值\n        int h=1;\n        while(h<N/2){\n            h=h*2+1;\n        }\n        //当增长量h小于1，排序结束\n        while(h>=1){\n            //找到待插入的元素\n            for (int i=h;i<N;i++){\n                //a[i]就是待插入的元素\n                //把a[i]插入到a[i-h],a[i-2h],a[i-3h]...序列中\n                for (int j=i;j>=h;j-=h){\n                //a[j]就是待插入元素，依次和a[j-h],a[j-2h],a[j-3h]进行比较，如果a[j]小，那么交换位置，如果不小于，a[j]大，则插入完成。\n                    if (greater(a[j-h],a[j])){\n                    	exch(a,j,j-h);\n                    }else{\n                   		break;\n                    }\n            }\n        }\n		h/=2;\n	}\n}\n\n    //比较v元素是否大于w元素\n    private static boolean greater(Comparable v,Comparable w){\n    return v.compareTo(w)>0;\n    }\n\n	//数组元素i和j交换位置\n    private static void exch(Comparable[] a,int i,int j){\n        Comparable t = a[i];\n        a[i]=a[j];\n        a[j]=t;\n    }\n}\n\n//测试代码\npublic class Test {\n    public static void main(String[] args) {\n        Integer[] a = {9,1,2,5,7,4,8,6,3,5} ;\n        Shell.sort(a);\n        System.out.println(Arrays.toString(a));\n    }\n}    \n```\n\n> 5、拓展：希尔排序和插入排序性能比较测试代码\n\n```java\npublic class SortCompare {\n    public static void main(String[] args) throws Exception{\n        ArrayList<Integer> list = new ArrayList<>();\n        //读取reverse_arr.txt文件\n        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"reverse_shell_insertion.txt\")));\n        String line=null;\n        while((line=reader.readLine())!=null){\n        //把每一个数字存入到集合中\n            list.add(Integer.valueOf(line));\n        }\n        reader.close();\n\n        //把集合转换成数组\n        Integer[] arr = new Integer[list.size()];\n        list.toArray(arr);\n        testInsertion(arr);//使用插入排序耗时：20859\n        // testShell(arr);//使用希尔排序耗时：31\n    }\n\n    public static void testInsertion(Integer[] arr){\n        //使用插入排序完成测试\n        long start = System.currentTimeMillis();\n        Insertion.sort(arr);\n        long end= System.currentTimeMillis();\n        System.out.println(\"使用插入排序耗时：\"+(end-start));\n    }\n    \n    public static void testShell(Integer[] arr){\n        //使用希尔排序完成测试\n        long start = System.currentTimeMillis();\n        Shell.sort(arr);\n        long end = System.currentTimeMillis();\n        System.out.println(\"使用希尔排序耗时：\"+(end-start));\n    }\n}\n```\n\n通过测试发现，在处理大批量数据时，希尔排序的性能确实高于插入排序。\n\n\n\n## 3.5 归并排序\n\n> 1、递归排序\n\n它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。\n\n> 2、需求：\n\n请定义一个方法，使用递归完成求N的阶乘；\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        int result = factorial(5);\n        System.out.println(result);\n        }\n    \n    public static int factorial(int n){\n        if (n==1){\n            return 1;\n        }\n        return n*factorial(n-1);\n    }\n}\n```\n\n> 3、归并排序\n\n归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n> 4、需求：\n\n排序前：{8,4,5,7,1,3,6,2}\n\n排序后：{1,2,3,4,5,6,7,8}\n\n> 5、排序原理：\n\n1. 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。\n\n2. 将相邻的两个子组进行合并成一个有序的大组；\n\n3. 不断的重复步骤2，直到最终只有一个组为止\n\n![image-20220713224519420](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220713224519420.png)\n\n> 6、归并排序API设计：\n\n| **类名** | **Merge**                                                    |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Merge()：创建Merge对象                                       |\n| 成员方法 | 1.  public static  void sort(Comparable[] a)：对数组内的元素进行排序 |\n|          | 2.  private static  void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序 |\n|          | 3.  private static  void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到所以mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从 索引lo到索引hi） |\n|          | 4.  private static boolean less(Comparable v,Comparable w):判断v是否小于w |\n|          | 5.  private static  void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |\n| 成员变量 | 1.private static Comparable[] assist：完成归并操作需要的辅助数组 |\n\n> 7、归并排序代码实现：\n\n```java\n//排序代码\npublic class Merge {\n    private static Comparable[] assist;//归并所需要的辅助数组\n    /*\n        对数组a中的元素进行排序\n        */\n    public static void sort(Comparable[] a) {\n        assist = new Comparable[a.length];\n        int lo = 0;\n        int hi = a.length-1;\n        sort(a, lo, hi);\n    }\n    /*\n        对数组a中从lo到hi的元素进行排序\n        */\n    private static void sort(Comparable[] a, int lo, int hi) {\n        if (hi <= lo) {\n            return;\n        }\n        int mid = lo + (hi - lo) / 2;\n        //对lo到mid之间的元素进行排序；\n        sort(a, lo, mid);\n        //对mid+1到hi之间的元素进行排序；\n        sort(a, mid+1, hi);\n        //对lo到mid这组数据和mid到hi这组数据进行归并\n        merge(a, lo, mid, hi);\n    }\n    /*\n        对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并\n        */\n    private static void merge(Comparable[] a, int lo, int mid, int hi) {\n        //lo到mid这组数据和mid+1到hi这组数据归并到辅助数组assist对应的索引处\n        int i = lo;//定义一个指针，指向assist数组中开始填充数据的索引\n        int p1 = lo;//定义一个指针，指向第一组数据的第一个元素\n        int p2 = mid + 1;//定义一个指针，指向第二组数据的第一个元素\n        //比较左边小组和右边小组中的元素大小，哪个小，就把哪个数据填充到assist数组中\n        while (p1 <= mid && p2 <= hi) {\n            if (less(a[p1], a[p2])) {\n                assist[i++] = a[p1++];\n            } else {\n                assist[i++] = a[p2++];\n            }\n        }\n        //上面的循环结束后，如果退出循环的条件是p1<=mid，则证明左边小组中的数据已经归并完毕，如果退出循环的条件是p2<=hi,则证明右边小组的数据已经填充完毕；\n            //所以需要把未填充完毕的数据继续填充到assist中,//下面两个循环，只会执行其中的一个\n            while(p1<=mid){\n                assist[i++]=a[p1++];\n            }\n        while(p2<=hi){\n            assist[i++]=a[p2++];\n        }\n        //到现在为止，assist数组中，从lo到hi的元素是有序的，再把数据拷贝到a数组中对应的索引处\n        for (int index=lo;index<=hi;index++){\n            a[index]=assist[index];\n        }\n    }\n    /*\n        比较v元素是否小于w元素\n        */\n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n    /*\n        数组元素i和j交换位置\n        */\n    private static void exch(Comparable[] a, int i, int j) {\n        Comparable t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Integer[] arr = {8, 4, 5, 7, 1, 3, 6, 2};\n        Merge.sort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n> 8、归并排序时间复杂度分析：\n\n归并排序是分治思想的最典型的例子，上面的算法中，对a[lo...hi]进行排序，先将它分为a[lo...mid]和a[mid+1...hi]  两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果 一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。\n\n![image-20220713233607929](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220713233607929.png)\n\n假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面32^3中 的3这个层数，最终得出的归并排序的时间复杂度为：log2(n)   2^(log2(n))=log2(n)n,\n\n根据大O推导法则，忽略底数，最终归并排序的时间复杂度为O(nlogn);\n\n> 9、归并排序的缺点：\n\n需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。\n\n> 10、希尔排序和插入排序性能比较测试代码：\n\n```java\npublic class SortCompare {\n    public static void main(String[] args) throws Exception{\n        ArrayList<Integer> list = new ArrayList<>();\n//读取a.txt文件\n        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"reverse_merge_shell.txt\")));\n        String line=null;\n        while((line=reader.readLine())!=null){\n//把每一个数字存入到集合中\n            list.add(Integer.valueOf(line));\n        }\n        reader.close();\n//把集合转换成数组\n        Integer[] arr = new Integer[list.size()];\n        list.toArray(arr);\n// testMerge(arr);//使用归并排序耗时：1200\n        testShell(arr);//使用希尔排序耗时：1277\n    }\n    public static void testMerge(Integer[] arr){\n//使用插入排序完成测试\n        long start = System.currentTimeMillis();\n        Merge.sort(arr);\n        long end= System.currentTimeMillis();\n        System.out.println(\"使用归并排序耗时：\"+(end-start));\n    }\n    public static void testShell(Integer[] arr){\n//使用希尔排序完成测试\n        long start = System.currentTimeMillis();\n        Shell.sort(arr);\n        long end = System.currentTimeMillis();\n        System.out.println(\"使用希尔排序耗时：\"+(end-start));\n    }\n}\n```\n\n通过测试，发现希尔排序和归并排序在处理大批量数据时差别不是很大。\n\n\n\n## 3.6 快速排序\n\n快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一 部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序 过程可以递归进行，以此达到整个数据变成有序序列。\n\n> 1、需求\n\n排序前:{6, 1, 2, 7, 9, 3, 4, 5, 8}\n\n排序后:{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n> 2、排序原理：\n\n1. 首先设定一个分界值，通过该分界值将数组分成左右两部分；\n\n2. 将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于 或等于分界值，而右边部分中各元素都大于或等于分界值；\n\n3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两 部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。\n\n4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当 左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。\n\n![image-20220714095644513](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714095644513.png)\n\n> 3、快速排序API设计\n\n| **类名** | **Quick**                                                    |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Quick()：创建Quick对象                                       |\n| 成员方法 | 1.  public static  void sort(Comparable[] a)：对数组内的元素进行排序 |\n|          | 2.  private static  void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序 |\n|          | 3.  public static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引 |\n|          | 4.  private static boolean less(Comparable v,Comparable w):判断v是否小于w |\n|          | 5.  private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |\n\n> 4、快速排序代码实现：\n\n```java\n//排序代码\npublic class Quick {\n    public static void sort(Comparable[] a) {\n        int lo = 0;\n        int hi = a.length - 1;\n        sort(a, lo, hi);\n    }\n\n    private static void sort(Comparable[] a, int lo, int hi) {\n        if (hi <= lo) {\n            return;\n        }\n        //对a数组中，从lo到hi的元素进行切分\n        int partition = partition(a, lo, hi);\n        //对左边分组中的元素进行排序\n        //对右边分组中的元素进行排序\n        sort(a, lo, partition - 1);\n        sort(a, partition + 1, hi);\n    }\n\n    public static int partition(Comparable[] a, int lo, int hi) {\n        Comparable key = a[lo];//把最左边的元素当做基准值\n        int left = lo;//定义一个左侧指针，初始指向最左边的元素\n        int right = hi + 1;//定义一个右侧指针，初始指向左右侧的元素下一个位置\n        //进行切分\n        while (true) {\n            //先从右往左扫描，找到一个比基准值小的元素\n            while (less(key, a[--right])) {//循环停止，证明找到了一个比基准值小的元素\n                if (right == lo) {\n                    break;//已经扫描到最左边了，无需继续扫描\n                }\n            }\n            //再从左往右扫描，找一个比基准值大的元素\n            while (less(a[++left], key)) {//循环停止，证明找到了一个比基准值大的元素\n                if (left == hi) {\n                    break;//已经扫描到了最右边了，无需继续扫描\n                }\n            }\n            if (left >= right) {\n                //扫描完了所有元素，结束循环\n                break;\n            } else {\n                //交换left和right索引处的元素\n                exch(a, left, right);\n            }\n        }\n        //交换最后rigth索引处和基准值所在的索引处的值\n        exch(a, lo, right);\n        return right;//right就是切分的界限\n    }\n\n    //数组元素i和j交换位置\n    private static void exch(Comparable[] a, int i, int j) {\n        Comparable t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n    }\n\n    //比较v元素是否小于w元素\n    private static boolean less(Comparable v, Comparable w) {\n        return v.compareTo(w) < 0;\n    }\n}\n\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Integer[] arr = {6, 1, 2, 7, 9, 3, 4, 5, 8};\n        Quick.sort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n> 5、快速排序和归并排序的区别：\n\n快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的 方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在 处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。\n\n> 6、快速排序时间复杂度分析：\n\n* 最优情况下：如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了logn次，所以，时间复杂度为O(nlogn);\n\n![image-20220714100905339](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714100905339.png)\n\n* 最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总 共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2);\n\n![image-20220714101010632](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714101010632.png)\n\n平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证明，快速排序的时间复杂度为O(nlogn),由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对，平均情况的时间复杂度做证明了。\n\n\n\n## 3.7 排序的稳定性\n\n> 1、稳定性的定义：\n\n数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。\n\n![image-20220714114504743](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714114504743.png)\n\n> 2、稳定性的意义：\n\n如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例 如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需 要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。\n\n> 3、常见排序算法的稳定性： \n\n1. 冒泡排序：\n\n只有当arr[i]>arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种**稳定排序算法**。\n\n2. 选择排序:\n\n选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2， 所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种**不稳定的排序算法**。\n\n3. 插入排序：\n\n比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其 后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等 元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以**插入排序是稳定的**。\n\n4. 希尔排序：\n\n希尔排序是按照不同步长对元素进行插入排序  ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以**希尔排序是不稳定的**。\n\n5. 归并排序：\n\n归并排序在归并的过程中，只有arr[i]<arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是**稳定的**。\n\n6. 快速排序：\n\n快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素， 然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种**不稳定的算法**。\n\n\n\n# 4. 线性表\n\n## 4.1 顺序表\n\n> 1、概述\n\n顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。\n\n![image-20220714131657578](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714131657578.png)\n\n> 2、顺序表API设计：\n\n| **类名** | **SequenceList**                                             |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | SequenceList(int  capacity)：创建容量为capacity的SequenceList对象 |\n| 成员方法 | 1.  public void  clear()：空置线性表                         |\n|          | 2.  publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false |\n|          | 3. public int length():获取线性表中元素的个数                |\n|          | 4. public T get(int i):读取并返回线性表中的第i个元素的值     |\n|          | 5.  public void  insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 |\n|          | 6.  public void insert(T t):向线性表中添加一个元素t          |\n|          | 7.  public T remove(int i):删除并返回线性表中第i个数据元素。 |\n|          | 8.  public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。 |\n| 成员变量 | 1.  private T[] eles：存储元素的数组                         |\n|          | 2.  private int N:当前线性表的长度                           |\n\n> 3、顺序表的代码实现\n\n```java\n//顺序表代码\npublic class SequenceList<T> {\n    //存储元素的数组\n    private T[] eles;\n    //记录当前顺序表中的元素个数\n    private int N;\n    //构造方法\n    public SequenceList(int capacity){\n        eles = (T[])new Object[capacity];\n        N=0;\n    }\n    //将一个线性表置为空表\n    public void clear(){\n        N=0;\n    }\n    //判断当前线性表是否为空表\n    public boolean isEmpty(){\n        return N==0;\n    }\n    //获取线性表的长度\n    public int length(){\n        return N;\n    }\n    //获取指定位置的元素\n    public T get(int i){\n        if (i<0 || i>=N){\n            throw new RuntimeException(\"当前元素不存在！\");\n        }\n        return eles[i];\n    }\n    //向线型表中添加元素t\n    public void insert(T t){\n        if (N==eles.length){\n            throw new RuntimeException(\"当前表已满\");\n        }\n        eles[N++] = t;\n    }\n    //在i元素处插入元素t\n    public void insert(int i,T t){\n        if (i==eles.length){\n            throw new RuntimeException(\"当前表已满\");\n        }\n        if (i<0 || i>N){\n            throw new RuntimeException(\"插入的位置不合法\");\n        }\n        //把i位置空出来，i位置及其后面的元素依次向后移动一位\n        for (int index=N;index>i;index--){\n            eles[index]=eles[index-1];\n        }\n        //把t放到i位置处\n        eles[i]=t;\n        //元素数量+1\n        N++;\n    }\n    //删除指定位置i处的元素，并返回该元素\n    public T remove(int i){\n        if (i<0 || i>N-1){\n            throw new RuntimeException(\"当前要删除的元素不存在\");\n        }\n        //记录i位置处的元素\n        T result = eles[i];\n        //把i位置后面的元素都向前移动一位\n        //一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。\n        for (int index=i;index<N-1;index++){\n            eles[index]=eles[index+1];\n        }\n        //当前元素数量-1\n        N--;\n        return result;\n    }\n    //查找t元素第一次出现的位置\n    public int indexOf(T t){\n        if(t==null){\n            throw new RuntimeException(\"查找的元素不合法\");\n        }\n        for (int i = 0; i < N; i++) {\n            if (eles[i].equals(t)){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n//测试代码\npublic class SequenceListTest {\n    public static void main(String[] args) {\n        //创建顺序表对象\n        SequenceList<String> sl = new SequenceList<>(10);\n        //测试插入\n        sl.insert(\"姚明\");\n        sl.insert(\"科比\");\n        sl.insert(\"麦迪\");\n        sl.insert(1,\"詹姆斯\");\n        //测试获取\n        String getResult = sl.get(1);\n        System.out.println(\"获取索引1处的结果为：\"+getResult);\n        //测试删除\n        String removeResult = sl.remove(0);\n        System.out.println(\"删除的元素是：\"+removeResult);\n        //测试清空\n        sl.clear();\n        System.out.println(\"清空后的线性表中的元素个数为:\"+sl.length());\n    }\n}\n```\n\n\n\n### 4.1.1 顺序表的遍历\n\n一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。\n\n在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则 需要做如下操作：\n\n1. 让SequenceList实现Iterable接口，重写iterator方法；\n\n2. 在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法； 代码：\n\n```java\n//顺序表代码\nimport java.util.Iterator;\npublic class SequenceList<T> implements Iterable<T>{\n    //存储元素的数组\n    private T[] eles;\n    //记录当前顺序表中的元素个数\n    private int N;\n    //构造方法\n    public SequenceList(int capacity){\n        eles = (T[])new Object[capacity];\n        N=0;\n    }\n    //将一个线性表置为空表\n    public void clear(){\n        N=0;\n    }\n    //判断当前线性表是否为空表\n    public boolean isEmpty(){\n        return N==0;\n    }\n    //获取线性表的长度\n    public int length(){\n        return N;\n    }\n    //获取指定位置的元素\n    public T get(int i){\n        if (i<0 || i>=N){\n            throw new RuntimeException(\"当前元素不存在！\");\n        }\n        return eles[i];\n    }\n    //向线型表中添加元素t\n    public void insert(T t){\n        if (N==eles.length){\n            throw new RuntimeException(\"当前表已满\");\n        }\n        eles[N++] = t;\n    }\n\n    //在i元素处插入元素t\n    public void insert(int i,T t){\n        if (i==eles.length){\n            throw new RuntimeException(\"当前表已满\");\n        }\n        if (i<0 || i>N){\n            throw new RuntimeException(\"插入的位置不合法\");\n        }\n        //把i位置空出来，i位置及其后面的元素依次向后移动一位\n        for (int index=N;index>i;index--){\n            eles[index]=eles[index-1];\n        }\n        //把t放到i位置处\n        eles[i]=t;\n        //元素数量+1\n        N++;\n    }\n    //删除指定位置i处的元素，并返回该元素\n    public T remove(int i){\n        if (i<0 || i>N-1){\n            throw new RuntimeException(\"当前要删除的元素不存在\");\n        }\n        //记录i位置处的元素\n        T result = eles[i];\n        //把i位置后面的元素都向前移动一位\n        for (int index=i;index<N-1;index++){\n            eles[index]=eles[index+1];\n        }\n        //当前元素数量-1\n        N--;\n        return result;\n    }\n    //查找t元素第一次出现的位置\n    public int indexOf(T t){\n        if(t==null){\n            throw new RuntimeException(\"查找的元素不合法\");\n        }\n        for (int i = 0; i < N; i++) {\n            if (eles[i].equals(t)){\n                return i;\n            }\n        }\n        return -1;\n    }\n    //打印当前线性表的元素\n    public void showEles(){\n        for (int i = 0; i < N; i++) {\n            System.out.print(eles[i]+\" \");\n        }\n        System.out.println();\n    }\n    @Override\n    public Iterator iterator() {\n        return new SIterator();\n    }\n    private class SIterator implements Iterator{\n        private int cur;\n        public SIterator(){\n            this.cur=0;\n        }\n        @Override\n        public boolean hasNext() {\n            return cur<N;\n        }\n        @Override\n        public T next() {\n            return eles[cur++];\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        SequenceList<String> squence = new SequenceList<>(5);\n//测试遍历\n        squence.insert(0, \"姚明\");\n        squence.insert(1, \"科比\");\n        squence.insert(2, \"麦迪\");\n        squence.insert(3, \"艾佛森\");\n        squence.insert(4, \"卡特\");\n        for (String s : squence) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n\n\n### 4.1.2  顺序表的容量可变\n\n在之前的实现中，当我们使用SequenceList时，先new  SequenceList(5)创建一个对象，创建对象时就需要指定容器的大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了5个元素，还要继续插入数\n\n据，则会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该考虑它的容量的伸缩性。\n\n考虑容器的容量伸缩性，其实就是改变存储数据元素的数组的大小，那我们需要考虑什么时候需要改变数组的大小？\n\n> 1、分析\n\n1. 添加元素时：\n\n添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我 们这里创建一个是原数组两倍容量的新数组存储元素。\n\n![image-20220714160351268](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714160351268.png)\n\n2. 移除元素时：\n\n移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存 空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建一个是原数组容量的1/2的新数组存储元素。\n\n![image-20220714160418558](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714160418558.png)\n\n> 2、顺序表的容量可变代码：\n\n```java\n//顺序表代码\npublic class SequenceList<T> implements Iterable<T>{\n    //存储元素的数组\n    private T[] eles;\n    //记录当前顺序表中的元素个数\n    private int N;\n    //构造方法\n    public SequenceList(int capacity){\n        eles = (T[])new Object[capacity];\n        N=0;\n    }\n    //将一个线性表置为空表\n    public void clear(){\n        N=0;\n    }\n    //判断当前线性表是否为空表\n    public boolean isEmpty(){\n        return N==0;\n    }\n    //获取线性表的长度\n    public int length(){\n        return N;\n    }\n    //获取指定位置的元素\n    public T get(int i){\n        if (i<0 || i>=N){\n            throw new RuntimeException(\"当前元素不存在！\");\n        }\n        return eles[i];\n    }\n    //向线型表中添加元素t\n    public void insert(T t){\n        if (N==eles.length){\n            resize(eles.length*2);\n        }\n        eles[N++] = t;\n    }\n    //在i元素处插入元素t\n    public void insert(int i,T t){\n        if (i<0 || i>N){\n            throw new RuntimeException(\"插入的位置不合法\");\n        }\n        //元素已经放满了数组，需要扩容\n        if (N==eles.length){\n            resize(eles.length*2);\n        }\n        //把i位置空出来，i位置及其后面的元素依次向后移动一位\n        for (int index=N-1;index>i;index--){\n            eles[index]=eles[index-1];\n        }\n        //把t放到i位置处\n        eles[i]=t;\n        //元素数量+1\n        N++;\n    }\n    //删除指定位置i处的元素，并返回该元素\n    public T remove(int i){\n        if (i<0 || i>N-1){\n            throw new RuntimeException(\"当前要删除的元素不存在\");\n        }\n        //记录i位置处的元素\n        T result = eles[i];\n        //把i位置后面的元素都向前移动一位\n        for (int index=i;index<N-1;index++){\n            eles[index]=eles[index+1];\n        }\n        //当前元素数量-1\n        N--;\n        //当元素已经不足数组大小的1/4,则重置数组的大小\n        if (N>0 && N<eles.length/4){\n            resize(eles.length/2);\n        }\n        return result;\n    }\n    //查找t元素第一次出现的位置\n    public int indexOf(T t){\n        if(t==null){\n            throw new RuntimeException(\"查找的元素不合法\");\n        }\n        for (int i = 0; i < N; i++) {\n            if (eles[i].equals(t)){\n                return i;\n            }\n        }\n        return -1;\n    }\n    //打印当前线性表的元素\n    public void showEles(){\n        for (int i = 0; i < N; i++) {\n            System.out.print(eles[i]+\" \");\n        }\n        System.out.println();\n    }\n    @Override\n    public Iterator iterator() {\n        return new SIterator();\n    }\n    private class SIterator implements Iterator{\n        private int cur;\n        public SIterator(){\n            this.cur=0;\n        }\n        @Override\n        public boolean hasNext() {\n            return cur<N;\n        }\n        @Override\n        public T next() {\n            return eles[cur++];\n        }\n    }\n    //改变容量\n    private void resize(int newSize){\n        //记录旧数组\n        T[] temp = eles;\n        //创建新数组\n        eles = (T[]) new Object[newSize];\n        //把旧数组中的元素拷贝到新数组\n        for (int i = 0; i < N; i++) {\n            eles[i] = temp[i];\n        }\n    }\n    public int capacity(){\n        return eles.length;\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        SequenceList<String> squence = new SequenceList<>(5);\n        //测试遍历\n        squence.insert(0, \"姚明\");\n        squence.insert(1, \"科比\");\n        squence.insert(2, \"麦迪\");\n        squence.insert(3, \"艾佛森\");\n        squence.insert(4, \"卡特\");\n        System.out.println(squence.capacity());\n        squence.insert(5,\"aa\");\n        System.out.println(squence.capacity());\n        squence.insert(5,\"aa\");\n        squence.insert(5,\"aa\");\n        squence.insert(5,\"aa\");\n        squence.insert(5,\"aa\");\n        squence.insert(5,\"aa\");\n        System.out.println(squence.capacity());\n        squence.remove(1);\n        squence.remove(1);\n        squence.remove(1);\n        squence.remove(1);\n        squence.remove(1);\n        squence.remove(1);\n        squence.remove(1);\n        System.out.println(squence.capacity());\n    }\n}\n```\n\n> 3、java中ArrayList实现\n\njava中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。 \n\n1. 是否用数组实现；\n\n2. 有没有扩容操作；\n\n3. 有没有提供遍历方式；\n\n\n\n## 4.2 链表\n\n链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元 素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成， 结点可以在运行时动态生成。\n\n![image-20220714160838858](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714160838858.png)\n\n> 1、结点API设计\n\n| **类名** | **Node**                          |\n| -------- | --------------------------------- |\n| 构造方法 | Node(T t,Node next)：创建Node对象 |\n| 成员变量 | T item:存储数据                   |\n|          | Node next：指向下一个结点         |\n\n> 2、结点类实现：\n\n```java\npublic class Node<T> {\n    //存储元素\n    public T item;\n    //指向下一个结点\n    public Node next;\n    public Node(T item, Node next) {\n        this.item = item;\n        this.next = next;\n    }\n}\n```\n\n> 3、生成链表：\n\n```java\npublic static void main(String[] args) throws Exception {\n	//构建结点\n    Node<Integer> first = new Node<Integer>(11, null);\n    Node<Integer> second = new Node<Integer>(13, null);\n    Node<Integer> third = new Node<Integer>(12, null);\n    Node<Integer> fourth = new Node<Integer>(8, null);\n    Node<Integer> fifth = new Node<Integer>(9, null);\n    //生成链表\n    first.next = second;\n    second.next = third;\n    third.next = fourth;\n    fourth.next = fifth;\n}\n```\n\n\n\n### 4.2.1 单向链表\n\n单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据， 指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。\n\n![image-20220714161152146](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714161152146.png)\n\n> 1、单向链表API设计\n\n| **类名**   | **LinkList**                                                 |\n| ---------- | ------------------------------------------------------------ |\n| 构造方法   | LinkList()：创建LinkList对象                                 |\n| 成员方法   | 1.  public void  clear()：空置线性表                         |\n|            | 2.  publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false |\n|            | 3.  public int length():获取线性表中元素的个数               |\n|            | 4.  public T get(int i):读取并返回线性表中的第i个元素的值    |\n|            | 5.  public void insert(T t)：往线性表中添加一个元素；        |\n|            | 6.  public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 |\n|            | 7.  public T remove(int i):删除并返回线性表中第i个数据元素。 |\n|            | 8.  public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。 |\n| 成员内部类 | private class Node:结点类                                    |\n| 成员变量   | 1.  private Node head:记录首结点                             |\n|            | 2.  private int N:记录链表的长度                             |\n\n> 2、单向链表代码实现\n\n```java\n//单向列表代码\nimport java.util.Iterator;\npublic class LinkList<T> implements Iterable<T> {\n    //记录头结点\n    private Node head;\n    //记录链表的长度\n    private int N;\n    public LinkList(){\n        //初始化头结点\n        head = new Node(null,null);\n        N=0;\n    }\n    //清空链表\n    public void clear(){\n        head.next=null;\n        head.item=null;\n        N=0;\n    }\n    //获取链表的长度\n    public int length(){\n        return N;\n    }\n    //判断链表是否为空\n    public boolean isEmpty(){\n        return N==0;\n    }\n    //获取指定位置i出的元素\n    public T get(int i){\n        if (i<0||i>=N){\n            throw new RuntimeException(\"位置不合法！\");\n        }\n        Node n = head.next;\n        for (int index = 0; index < i; index++) {\n            n = n.next;\n        }\n        return n.item;\n    }\n    //向链表中添加元素t\n    public void insert(T t){\n        //找到最后一个节点\n        Node n = head;\n        while(n.next!=null){\n            n = n.next;\n        }\n        Node newNode = new Node(t, null);\n        n.next = newNode;\n        //链表长度+1\n        N++;\n    }\n    //向指定位置i处，添加元素t\n    public void insert(int i,T t){\n        if (i<0||i>=N){\n            throw new RuntimeException(\"位置不合法！\");\n        }\n        //寻找位置i之前的结点\n        Node pre = head;\n        for (int index = 0; index <=i-1; index++) {\n            pre = pre.next;\n        }\n        //位置i的结点\n        Node curr = pre.next;\n        //构建新的结点，让新结点指向位置i的结点\n        Node newNode = new Node(t, curr);\n        //让之前的结点指向新结点\n        pre.next = newNode;\n        //长度+1\n        N++;\n    }\n    //删除指定位置i处的元素，并返回被删除的元素\n    public T remove(int i){\n        if (i<0 || i>=N){\n            throw new RuntimeException(\"位置不合法\");\n        }\n        //寻找i之前的元素\n        Node pre = head;\n        for (int index = 0; index <=i-1; index++) {\n            pre = pre.next;\n        }\n        //当前i位置的结点\n        Node curr = pre.next;\n        //前一个结点指向下一个结点，删除当前结点\n        pre.next = curr.next;\n        //长度-1\n        N--;\n        return curr.item;\n    }\n    //查找元素t在链表中第一次出现的位置\n    public int indexOf(T t){\n        Node n = head;\n        for (int i = 0;n.next!=null;i++){\n            n = n.next;\n            if (n.item.equals(t)){\n                return i;\n            }\n        }\n        return -1;\n    }\n    //结点类\n    private class Node{\n        //存储数据\n        T item;\n        //下一个结点\n        Node next;\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n    @Override\n    public Iterator iterator() {\n        return new LIterator();\n    }\n    private class LIterator implements Iterator<T>{\n        private Node n;\n        public LIterator() {\n            this.n = head;\n        }\n        @Override\n        public boolean hasNext() {\n            return n.next!=null;\n        }\n        @Override\n        public T next() {\n            n = n.next;\n            return n.item;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        LinkList<String> list = new LinkList<>();\n        list.insert(0, \"张三\");\n        list.insert(1, \"李四\");\n        list.insert(2, \"王五\");\n        list.insert(3, \"赵六\");\n        //测试length方法\n        for (String s : list) {\n            System.out.println(s);\n        }\n        System.out.println(list.length());\n        System.out.println(\"-------------------\");\n        //测试get方法\n        System.out.println(list.get(2));\n        System.out.println(\"------------------------\");\n        //测试remove方法\n        String remove = list.remove(1);\n        System.out.println(remove);\n        System.out.println(list.length());\n        System.out.println(\"----------------\");\n        for (String s : list) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n\n\n### 4.2.2 双向链表\n\n双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。\n\n![image-20220714161744187](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714161744187.png)\n\n> 1、结点API设计\n\n| **类名** | **Node**                                         |\n| -------- | ------------------------------------------------ |\n| 构造方法 | Node(T t,Node  pre,Node next)：创建Node对象      |\n| 成员变量 | T item:存储数据                                  |\n|          | Node next：指向下一个结点Node pre:指向上一个结点 |\n\n> 2、双向链表API设计\n\n| **类名**   | **TowWayLinkList**                                           |\n| ---------- | ------------------------------------------------------------ |\n| 构造方法   | TowWayLinkList()：创建TowWayLinkList对象                     |\n| 成员方法   | 1.  public void  clear()：空置线性表                         |\n|            | 2.  publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false |\n|            | 3.  public int length():获取线性表中元素的个数               |\n|            | 4.  public T get(int i):读取并返回线性表中的第i个元素的值    |\n|            | 5.  public void insert(T t)：往线性表中添加一个元素；        |\n|            | 6.  public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。 |\n|            | 7.  public T remove(int i):删除并返回线性表中第i个数据元素。 |\n|            | 8.  public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。 |\n|            | 9.  public T getFirst():获取第一个元素                       |\n|            | 10.  public T getLast():获取最后一个元素                     |\n| 成员内部类 | private class Node:结点类                                    |\n| 成员变量   | 1.private Node ﬁrst:记录首结点                               |\n|            | 2.private Node last:记录尾结点                               |\n|            | 3.private int N:记录链表的长度                               |\n\n> 3、双向链表代码实现\n\n```java\n//双向链表代码\nimport java.util.Iterator;\npublic class TowWayLinkList<T> implements Iterable<T>{\n    //首结点\n    private Node head;\n    //最后一个结点\n    private Node last;\n    //链表的长度\n    private int N;\n    public TowWayLinkList() {\n        last = null;\n        head = new Node(null,null,null);\n        N=0;\n    }\n    //清空链表\n    public void clear(){\n        last=null;\n        head.next=last;\n        head.pre=null;\n        head.item=null;\n        \n        N=0;\n    }\n    //获取链表长度\n    public int length(){\n        return N;\n    }\n    //判断链表是否为空\n    public boolean isEmpty(){\n        return N==0;\n    }\n    //插入元素t\n    public void insert(T t){\n        if (last==null){\n            last = new Node(t,head,null);\n            head.next = last;\n        }else{\n            Node oldLast = last;\n            Node node = new Node(t, oldLast, null);\n            oldLast.next = node;\n            last = node;\n        }\n        //长度+1\n        N++;\n    }\n    //向指定位置i处插入元素t\n    public void insert(int i,T t){\n        if (i<0 || i>=N){\n            throw new RuntimeException(\"位置不合法\");\n        }\n        //找到位置i的前一个结点\n        Node pre = head;\n        for (int index = 0; index < i; index++) {\n            pre = pre.next;\n        }\n        //当前结点\n        Node curr = pre.next;\n        //构建新结点\n        Node newNode = new Node(t, pre, curr);\n        curr.pre= newNode;\n        pre.next = newNode;\n        //长度+1\n        N++;\n    }\n    //获取指定位置i处的元素\n    public T get(int i){\n        if (i<0||i>=N){\n            \n            throw new RuntimeException(\"位置不合法\");\n        }\n        //寻找当前结点\n        Node curr = head.next;\n        for (int index = 0; index <i; index++) {\n            curr = curr.next;\n        }\n        return curr.item;\n    }\n    //找到元素t在链表中第一次出现的位置\n    public int indexOf(T t){\n        Node n= head;\n        for (int i=0;n.next!=null;i++){\n            n = n.next;\n            if (n.next.equals(t)){\n                return i;\n            }\n        }\n        return -1;\n    }\n    //删除位置i处的元素，并返回该元素\n    public T remove(int i){\n        if (i<0 || i>=N){\n            throw new RuntimeException(\"位置不合法\");\n        }\n        //寻找i位置的前一个元素\n        Node pre = head;\n        for (int index = 0; index <i ; index++) {\n            pre = pre.next;\n        }\n        //i位置的元素\n        Node curr = pre.next;\n        //i位置的下一个元素\n        Node curr_next = curr.next;\n        pre.next = curr_next;\n        curr_next.pre = pre;\n        //长度-1；\n        N--;\n        return curr.item;\n    }\n    //获取第一个元素\n    public T getFirst(){\n        if (isEmpty()){\n            return null;\n        }\n        return head.next.item;\n    }\n    //获取最后一个元素\n    public T getLast(){\n        if (isEmpty()){\n            return null;\n        }\n        return last.item;\n    }\n    @Override\n    public Iterator<T> iterator() {\n        return new TIterator();\n    }\n    private class TIterator implements Iterator{\n        private Node n = head;\n        @Override\n        public boolean hasNext() {\n            return n.next!=null;\n        }\n        @Override\n        public Object next() {\n            n = n.next;\n            return n.item;\n        }\n    }\n    //结点类\n    private class Node{\n        public Node(T item, Node pre, Node next) {\n            this.item = item;\n            this.pre = pre;\n            this.next = next;\n        }\n        //存储数据\n        public T item;\n        //指向上一个结点\n        public Node pre;\n        //指向下一个结点\n        public Node next;\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        TowWayLinkList<String> list = new TowWayLinkList<>();\n        list.insert(\"乔峰\");\n        list.insert(\"虚竹\");\n        list.insert(\"段誉\");\n        list.insert(1,\"鸠摩智\");\n        list.insert(3,\"叶二娘\");\n        for (String str : list) {\n            System.out.println(str);\n        }\n        System.out.println(\"----------------------\");\n        String tow = list.get(2);\n        System.out.println(tow);\n        System.out.println(\"-------------------------\");\n        String remove = list.remove(3);\n        System.out.println(remove);\n        System.out.println(list.length());\n        System.out.println(\"--------------------\");\n        System.out.println(list.getFirst());\n        System.out.println(list.getLast());\n    }\n}\n```\n\n> 3、java中LinkedList实现\n\njava中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法 \n\n1. 底层是否用双向链表实现；\n\n2. 结点类是否有三个域\n\n\n\n### 4.2.3 链表反转\n\n单链表的反转，是面试中的一个高频题目。\n\n> 1、需求：\n\n原链表中数据为：1->2->3>4\n\n反转后链表中数据为：4->3->2->1\n\n> 2、反转API：\n\n `public void reverse()：对整个链表反转`\n\n`public Node reverse(Node curr)：反转链表中的某个结点curr,并把反转后的curr结点返回`\n\n使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点， 直到把最后一个结点反转完毕，整个链表就反转完毕。\n\n![image-20220714162545130](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714162545130.png)\n\n> 3、实现代码：\n\n```java\npublic void reverse(){\n    if (N==0){\n    //当前是空链表，不需要反转\n    return;\n    }\n    reverse(head.next);\n}\n\n/**\n *\n * @param curr 当前遍历的结点\n * @return 反转后当前结点上一个结点\n */\npublic Node reverse(Node curr){\n    //已经到了最后一个元素\n    if (curr.next==null){\n    //反转后，头结点应该指向原链表中的最后一个元素\n    head.next=curr;\n    return curr;\n    }\n    //当前结点的上一个结点\n    Node pre = reverse(curr.next);\n    pre.next = curr;\n    //当前结点的下一个结点设为null\n    curr.next=null;\n    //返回当前结点\n    return curr;\n}\n\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        LinkList<Integer> list = new LinkList<>();\n        list.insert(1);\n        list.insert(2);\n        list.insert(3);\n        list.insert(4);\n        for (Integer i : list) {\n            System.out.print(i+\" \");\n        }\n        System.out.println();\n        System.out.println(\"--------------------\");\n        list.reverse();\n        for (Integer i : list) {\n            System.out.print(i+\" \");\n        }\n    }\n}\n```\n\n\n\n### 4.2.4 快慢指针\n\n快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然 我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍。\n\n> 1、中间值问题\n\n我们先来看下面一段代码，然后完成需求。\n\n```java\n//测试类\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Node<String> first = new Node<String>(\"aa\", null);\n        Node<String> second = new Node<String>(\"bb\", null);\n        Node<String> third = new Node<String>(\"cc\", null);\n        Node<String> fourth = new Node<String>(\"dd\", null);\n        Node<String> fifth = new Node<String>(\"ee\", null);\n        Node<String> six = new Node<String>(\"ff\", null);\n        Node<String> seven = new Node<String>(\"gg\", null);\n        //完成结点之间的指向\n        first.next = second;\n        second.next = third;\n        third.next = fourth;\n        fourth.next = fifth;\n        fifth.next = six;\n        six.next = seven;\n//查找中间值\n        String mid = getMid(first);\n        System.out.println(\"中间值为：\"+mid);\n    }\n    \n    /**\n     * @param first 链表的首结点\n     * @return 链表的中间结点的值\n     */\n    public static String getMid(Node<String> first) {\n        return null;\n    }\n    //结点类\n    private static class Node<T> {\n        //存储数据\n        T item;\n        //下一个结点\n        Node next;\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n}\n```\n\n> 需求：\n\n请完善测试类Test中的getMid方法，可以找出链表的中间元素值并返回。\n\n利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以 此来达到找到中间节点的目的。\n\n如下图，最开始，slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。\n\n![image-20220714162948525](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714162948525.png)\n\n> 实现代码：\n\n```java\n/**\n * @param first 链表的首结点\n * @return 链表的中间结点的值\n */\npublic static String getMid(Node<String> first) {\n    Node<String> slow = first;\n    Node<String> fast = first;\n    while(fast!=null && fast.next!=null){\n        fast=fast.next.next;\n        slow=slow.next;\n    }\n    return slow.item;\n}\n```\n\n\n\n> 2、单向链表是否有环问题\n\n![image-20220714163216350](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714163216350.png)\n\n> 看下面代码，完成需求：\n\n```java\n//测试类\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Node<String> first = new Node<String>(\"aa\", null);\n        Node<String> second = new Node<String>(\"bb\", null);\n        Node<String> third = new Node<String>(\"cc\", null);\n        Node<String> fourth = new Node<String>(\"dd\", null);\n        Node<String> fifth = new Node<String>(\"ee\", null);\n        Node<String> six = new Node<String>(\"ff\", null);\n        Node<String> seven = new Node<String>(\"gg\", null);\n        //完成结点之间的指向\n        first.next = second;\n        second.next = third;\n        third.next = fourth;\n        fourth.next = fifth;\n        fifth.next = six;\n        six.next = seven;\n        //产生环\n        seven.next = third;\n        //判断链表是否有环\n        boolean circle = isCircle(first);\n        System.out.println(\"first链表中是否有环：\"+circle);\n    }\n    /**\n     * 判断链表中是否有环\n     * @param first 链表首结点\n     * @return ture为有环，false为无环\n     */\n    public static boolean isCircle(Node<String> first) {\n        return false;\n    }\n    //结点类\n    private static class Node<T> {\n        //存储数据\n        T item;\n        //下一个结点\n        Node next;\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n}\n```\n\n> 需求：\n\n请完善测试类Test中的isCircle方法，返回链表中是否有环。\n\n使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道 中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。\n\n![image-20220714163419654](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714163419654.png)\n\n![image-20220714163503922](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714163503922.png)\n\n>实现代码：\n\n```java\n/**\n * 判断链表中是否有环\n * @param first 链表首结点\n * @return ture为有环，false为无环\n */\npublic static boolean isCircle(Node<String> first) {\n    Node<String> slow = first;\n    Node<String> fast = first;\n    while(fast!=null && fast.next!=null){\n    fast = fast.next.next;\n    slow = slow.next;\n        if (fast.equals(slow)){\n        return true;\n        }\n    }\n    return false;\n}\n```\n\n\n\n> 3、有环链表入口问题\n\n同样看下面这段代码，完成需求：\n\n```java\n//测试类\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Node<String> first = new Node<String>(\"aa\", null);\n        Node<String> second = new Node<String>(\"bb\", null);\n        Node<String> third = new Node<String>(\"cc\", null);\n        Node<String> fourth = new Node<String>(\"dd\", null);\n        Node<String> fifth = new Node<String>(\"ee\", null);\n        Node<String> six = new Node<String>(\"ff\", null);\n        Node<String> seven = new Node<String>(\"gg\", null);\n        //完成结点之间的指向\n        first.next = second;\n        second.next = third;\n        third.next = fourth;\n        fourth.next = fifth;\n        fifth.next = six;\n        six.next = seven;\n        //产生环\n        seven.next = third;\n        //查找环的入口结点\n        Node<String> entrance = getEntrance(first);\n        System.out.println(\"first链表中环的入口结点元素为：\"+entrance.item);\n    }\n    /**\n     * 查找有环链表中环的入口结点\n     * @param first 链表首结点\n     * @return 环的入口结点\n     */\n    public static Node getEntrance(Node<String> first) {\n        return null;\n    }\n    //结点类\n    private static class Node<T> {\n        //存储数据\n        T item;\n        //下一个结点\n        Node next;\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n}\n```\n\n> 需求：\n\n请完善Test类中的getEntrance方法，查找有环链表中环的入口结点。\n\n当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样 为1，则慢指针与“新”指针相遇的地方就是环的入口。证明这一结论牵涉到数论的知识，这里略，只讲实现。\n\n![image-20220714163828235](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714163828235.png)\n\n> 代码：\n\n```java\n/**\n * 查找有环链表中环的入口结点\n * @param first 链表首结点\n * @return 环的入口结点\n */\npublic static Node getEntrance(Node<String> first) {\n        Node<String> slow = first;\n        Node<String> fast = first;\n        Node<String> temp = null;\n        while(fast!=null && fast.next!=null){\n            fast = fast.next.next;\n            slow=slow.next;\n            if (fast.equals(slow)){\n                temp = first;\n                continue;\n            }\n            if (temp!=null){\n                temp=temp.next;\n                if (temp.equals(slow)){\n                    return temp;\n                }\n            }\n        }\n        return null;\n}\n```\n\n\n\n### 4.2.5 循环链表\n\n循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。\n\n![image-20220714164028004](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714164028004.png)\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        //构建结点\n        Node<Integer> first = new Node<Integer>(1, null);\n        Node<Integer> second = new Node<Integer>(2, null);\n        Node<Integer> third = new Node<Integer>(3, null);\n        Node<Integer> fourth = new Node<Integer>(4, null);\n        Node<Integer> fifth = new Node<Integer>(5, null);\n        Node<Integer> six = new Node<Integer>(6, null);\n        Node<Integer> seven = new Node<Integer>(7, null);\n        //构建单链表\n        first.next = second;\n        second.next = third;\n        third.next = fourth;\n        fourth.next = fifth;\n        fifth.next = six;\n        six.next = seven;\n        //构建循环链表,让最后一个结点指向第一个结点\n        seven.next = first;\n    }\n}\n```\n\n\n\n### 4.2.6 约瑟夫问题\n\n> 1、问题描述：\n\n传说有这样一个故事，在罗马人占领乔塔帕特后，39  个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡 为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与 第31个位置，从而逃过了这场死亡游戏 。\n\n> 2、问题转换：\n\n41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。\n\n1. 编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；\n\n2. 自退出那个人开始的下一个人再次从1开始报数，以此类推；\n\n3. 求出最后退出的那个人的编号。\n\n![image-20220714164155190](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714164155190.png)\n\n> 3、解题思路：\n\n1. 构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；\n\n2. 使用计数器count，记录当前报数的值；\n\n3. 遍历链表，每循环一次，count++；\n\n4. 判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；\n\n> 4、代码\n\n```java\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        //1.构建循环链表\n        Node<Integer> first = null;\n        //记录前一个结点\n        Node<Integer> pre = null;\n        for (int i = 1; i <= 41; i++) {\n            //第一个元素\n            if (i==1){\n                first = new Node(i,null);\n                pre = first;\n                continue;\n            }\n            Node<Integer> node = new Node<>(i,null);\n            pre.next = node;\n            pre = node;\n            if (i==41){\n                //构建循环链表，让最后一个结点指向第一个结点\n                pre.next=first;\n            }\n        }\n        //2.使用count，记录当前的报数值\n        int count=0;\n        //3.遍历链表，每循环一次，count++\n        Node<Integer> n = first;\n        Node<Integer> before = null;\n        while(n!=n.next){\n            //4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；\n            count++;\n            if (count==3){\n                //删除当前结点\n                before.next = n.next;\n                System.out.print(n.item+\",\");\n                count=0;\n                n = n.next;\n            }else{\n                before=n;\n                n = n.next;\n            }\n        }\n        /*打印剩余的最后那个人*/\n        System.out.println(n.item);\n    }\n}\n```\n\n\n\n## 4.3 栈\n\n栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出 的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一 个数据被第一个读出来）。\n\n![image-20220714164408381](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714164408381.png)\n\n> 1、栈API设计\n\n| **类名** | **Stack**                                                    |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Stack)：创建Stack对象                                        |\n| 成员方法 | 1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false |\n|          | 2.public int  size():获取栈中元素的个数                      |\n|          | 3. public T pop():弹出栈顶元素                               |\n|          | 4. public void push(T t)：向栈中压入元素t                    |\n| 成员变量 | 1.private Node head:记录首结点                               |\n|          | 2.private int N:当前栈的元素个数                             |\n\n> 2、栈代码实现\n\n```java\n//栈代码\nimport java.util.Iterator;\npublic class Stack<T> implements Iterable<T>{\n    //记录首结点\n    private Node head;\n    //栈中元素的个数\n    private int N;\n    public Stack() {\n        head = new Node(null,null);\n        N=0;\n    }\n    //判断当前栈中元素个数是否为0\n    public boolean isEmpty(){\n        return N==0;\n    }\n    //把t元素压入栈\n    public void push(T t){\n        Node oldNext = head.next;\n        Node node = new Node(t, oldNext);\n        head.next = node;\n        //个数+1\n        N++;\n    }\n    //弹出栈顶元素\n    public T pop(){\n        Node oldNext = head.next;\n        if (oldNext==null){\n            return null;\n        }\n        //删除首个元素\n        head.next = head.next.next;\n        //个数-1\n        N--;\n        return oldNext.item;\n    }\n    //获取栈中元素的个数\n    public int size(){\n        return N;\n    }\n    @Override\n    public Iterator<T> iterator() {\n        return new SIterator();\n    }\n    private class SIterator implements Iterator<T>{\n        private Node n = head;\n        @Override\n        public boolean hasNext() {\n            return n.next!=null;\n        }\n        @Override\n        public T next() {\n            Node node = n.next;\n            n = n.next;\n            return node.item;\n        }\n    }\n    private class Node{\n        public T item;\n        public Node next;\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Stack<String> stack = new Stack<>();\n        stack.push(\"a\");\n        stack.push(\"b\");\n        stack.push(\"c\");\n        stack.push(\"d\");\n        for (String str : stack) {\n            System.out.print(str+\" \");\n        }\n        System.out.println(\"-----------------------------\");\n        String result = stack.pop();\n        System.out.println(\"弹出了元素：\"+result);\n        System.out.println(stack.size());\n    }\n}\n```\n\n\n\n### 4.3.1 括号匹配问题\n\n> 1、问题描述：\n\n给定一个字符串，里边可能包含\"()\"小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。\n\n例如：\n\n| 条件                         | 结果     |\n| ---------------------------- | -------- |\n| \"(上海)(长安)\"               | 正确匹配 |\n| \"上海((长安))\"               | 正确匹配 |\n| \"上海(长安(北京)(深圳)南京)\" | 正确匹配 |\n| \"上海(长安))\"                | 错误匹配 |\n| \"((上海)长安\"                | 错误匹配 |\n\n> 2、示例代码：\n\n```java\npublic class BracketsMatch {\n    public static void main(String[] args) {\n        String str = \"(上海(长安)())\";\n        boolean match = isMatch(str);\n        System.out.println(str+\"中的括号是否匹配：\"+match);\n    }\n    /**\n     * 判断str中的括号是否匹配\n     * @param str 括号组成的字符串\n     * @return 如果匹配，返回true，如果不匹配，返回false\n     */\n    public static boolean isMatch(String str){\n        return false;\n    }\n}\n```\n\n> 3、分析：请完善 isMath方法。\n\n1. 创建一个栈用来存储左括号\n\n2. 从左往右遍历字符串，拿到每一个字符\n\n3. 判断该字符是不是左括号，如果是，放入栈中存储\n\n4. 判断该字符是不是右括号，如果不是，继续下一次循环\n\n5. 如果该字符是右括号，则从栈中弹出一个元素t；\n\n6. 判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\n\n7. 循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714165145607.png\" alt=\"image-20220714165145607\" style=\"zoom: 67%;\" />\n\n> 4、代码实现：\n\n```java\npublic class BracketsMatch {\n    public static void main(String[] args) {\n        String str = \"(fdafds(fafds)())\";\n        boolean match = isMatch(str);\n        System.out.println(str + \"中的括号是否匹配：\" + match);\n    }\n    /**\n     * 判断str中的括号是否匹配\n     *\n     * @param str 括号组成的字符串\n     * @return 如果匹配，返回true，如果不匹配，返回false\n     */\n    public static boolean isMatch(String str) {\n        //1.创建一个栈用来存储左括号\n        Stack<String> chars = new Stack<>();\n        //2.从左往右遍历字符串，拿到每一个字符\n        for (int i = 0; i < str.length(); i++) {\n            String currChar = str.charAt(i) + \"\";\n            //3.判断该字符是不是左括号，如果是，放入栈中存储\n            if (currChar.equals(\"(\")) {\n                chars.push(currChar);\n            } else if (currChar.equals(\")\")) {\n                //4.判断该字符是不是右括号，如果不是，继续下一次循环\n                //5.如果该字符是右括号，则从栈中弹出一个元素t；\n                String t = chars.pop();\n                //6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号\n                if (t == null) {\n                    return false;\n                }\n            }\n        }\n        //7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配\n        if (chars.size() == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n```\n\n\n\n### 4.3.2 逆波兰表达式求值问题\n\n逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式？要搞清楚逆波兰表达式，我们得从中缀表达式说起。\n\n> 1、中缀表达式：\n\n中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总是置于两个操作数中间。\n\n中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的 运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做 大量的优先级相关操作。\n\n> 2、逆波兰表达式(后缀表达式)\n\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹( J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。\n\n| **中缀表达式** | **逆波兰表达式** |\n| -------------- | ---------------- |\n| a+b            | ab+              |\n| a+(b-c)        | abc-+            |\n| a+(b-c)*d      | abc-d*+          |\n| a*(b-c)+d      | abc-*d+          |\n\n> 3、需求：\n\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\n\n```java\npublic class ReversePolishNotation {\n    public static void main(String[] args) {\n        //中缀表达式3*（17-15）+18/6的逆波兰表达式如下\n        String[] notation = {\"3\", \"17\", \"15\", \"-\", \"*\",\"18\", \"6\",\"/\",\"+\"};\n        int result = caculate(notation);\n        System.out.println(\"逆波兰表达式的结果为：\"+result);\n    }\n    /**\n     * @param notaion 逆波兰表达式的数组表示方式\n     * @return 逆波兰表达式的计算结果\n     */\n    public static int caculate(String[] notaion){\n        return -1;\n    }\n}\n```\n\n完善caculate方法，计算出逆波兰表达式的结果。\n\n> 4、分析：\n\n1. 创建一个栈对象oprands存储操作数\n\n2. 从左往右遍历逆波兰表达式，得到每一个字符串\n\n3. 判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\n\n4. 如果是运算符，则从oprands栈中弹出两个操作数o1,o2\n\n5. 使用该运算符计算o1和o2，得到结果result\n\n6. 把该结果压入oprands栈中\n\n7. 遍历结束后，拿出栈中最终的结果返回\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714165553301.png\" alt=\"image-20220714165553301\" style=\"zoom:67%;\" />\n\n> 5、代码实现\n\n```java\npublic class ReversePolishNotation {\n    public static void main(String[] args) {\n        //中缀表达式3*（17-15）+18/6的逆波兰表达式如下\n        String[] notation = {\"3\", \"17\", \"15\", \"-\", \"*\", \"18\", \"6\", \"/\", \"+\"};\n        int result = caculate(notation);\n        System.out.println(\"逆波兰表达式的结果为：\" + result);\n    }\n    /**\n     * @param notaion 逆波兰表达式的数组表示方式\n     * @return 逆波兰表达式的计算结果\n     */\n    public static int caculate(String[] notaion) {\n        //1.创建一个栈对象oprands存储操作数\n        Stack<Integer> oprands = new Stack<>();\n        //2.从左往右遍历逆波兰表达式，得到每一个字符串\n        for (int i = 0; i < notaion.length; i++) {\n            String curr = notaion[i];\n            //3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中\n            Integer o1;\n            Integer o2;\n            Integer result;\n            switch (curr) {\n                case \"+\":\n                    //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\n                    o1 = oprands.pop();\n                    o2 = oprands.pop();\n                    //5.使用该运算符计算o1和o2，得到结果result\n                    result = o2 + o1;\n                    //6.把该结果压入oprands栈中\n                    oprands.push(result);\n                    break;\n                case \"-\":\n                    //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\n                    o1 = oprands.pop();\n                    o2 = oprands.pop();\n                    //5.使用该运算符计算o1和o2，得到结果result\n                    result = o2 - o1;\n                    //6.把该结果压入oprands栈中\n                    oprands.push(result);\n                    break;\n                case \"*\":\n                    //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\n                    o1 = oprands.pop();\n                    o2 = oprands.pop();\n                    //5.使用该运算符计算o1和o2，得到结果result\n                    result = o2 * o1;\n                    //6.把该结果压入oprands栈中\n                    oprands.push(result);\n                    break;\n                case \"/\":\n                    //4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2\n                    o1 = oprands.pop();\n                    o2 = oprands.pop();\n                    //5.使用该运算符计算o1和o2，得到结果result\n                    result = o2 / o1;\n                    //6.把该结果压入oprands栈中\n                    oprands.push(result);\n                    break;\n                default:\n                    oprands.push(Integer.parseInt(curr));\n                    break;\n            }\n        }\n        //7.遍历结束后，拿出栈中最终的结果返回\n        Integer result = oprands.pop();\n        return result;\n    }\n}\n```\n\n\n\n## 4.4 队列\n\n队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它 按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。\n\n![image-20220714170254054](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714170254054.png)\n\n> 1、队列的API设计\n\n| **类名** | **Queue**                                                    |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Queue()：创建Queue对象                                       |\n| 成员方法 | 1.public boolean isEmpty()：判断队列是否为空，是返回true，否返回false |\n|          | 2.public int  size():获取队列中元素的个数                    |\n|          | 3.public T dequeue():从队列中拿出一个元素                    |\n|          | 4.public void enqueue(T t)：往队列中插入一个元素             |\n| 成员变量 | 1.private Node head:记录首结点                               |\n|          | 2.private int N:当前栈的元素个数                             |\n|          | 3.private Node last:记录最后一个结点                         |\n\n> 2、队列的实现\n\n```java\n//队列代码\nimport java.util.Iterator;\npublic class Queue<T> implements Iterable<T>{\n    //记录首结点\n    private Node head;\n    //记录最后一个结点\n    private Node last;\n    //记录队列中元素的个数\n    private int N;\n    public Queue() {\n        head = new Node(null,null);\n        last=null;\n        N=0;\n    }\n    //判断队列是否为空\n    public boolean isEmpty(){\n        return N==0;\n    }\n    //返回队列中元素的个数\n    public int size(){\n        return N;\n    }\n    //向队列中插入元素t\n    public void enqueue(T t){\n        if (last==null){\n            last = new Node(t,null);\n            head.next=last;\n        }else{\n            Node oldLast = last;\n            last = new Node(t,null);\n            oldLast.next=last;\n        }\n        //个数+1\n        N++;\n    }\n    //从队列中拿出一个元素\n    public T dequeue(){\n        if (isEmpty()){\n            return null;\n        }\n        Node oldFirst = head.next;\n        head.next = oldFirst.next;\n        N--;\n        if (isEmpty()){\n            last=null;\n        }\n        return oldFirst.item;\n    }\n    @Override\n    public Iterator<T> iterator() {\n        return new QIterator();\n    }\n    private class QIterator implements Iterator<T>{\n        private Node n = head;\n        @Override\n        public boolean hasNext() {\n            return n.next!=null;\n        }\n        @Override\n        public T next() {\n            Node node = n.next;\n            n = n.next;\n            return node.item;\n        }\n    }\n    private class Node{\n        public T item;\n        public Node next;\n        public Node(T item, Node next) {\n            this.item = item;\n            this.next = next;\n        }\n    }\n}\n\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Queue<String> queue = new Queue<>();\n        queue.enqueue(\"a\");\n        queue.enqueue(\"b\");\n        queue.enqueue(\"c\");\n        queue.enqueue(\"d\");\n        for (String str : queue) {\n            System.out.print(str+\" \");\n        }\n        System.out.println(\"-----------------------------\");\n        String result = queue.dequeue();\n        System.out.println(\"出列了元素：\"+result);\n        System.out.println(queue.size());\n    }\n}\n```\n\n\n\n# 5. 符号表\n\n符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的键值对数据，我们可以根据键来查找对应的值。\n\n![image-20220714170626250](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714170626250.png)\n\n符号表中，键具有唯一性。\n\n符号表在实际生活中的使用场景是非常广泛的，见下表：\n\n| **应用** | **查找目的**             | **键** | **值**   |\n| -------- | ------------------------ | ------ | -------- |\n| 字典     | 找出单词的释义           | 单词   | 释义     |\n| 图书索引 | 找出某个术语相关的页码   | 术语   | 一串页码 |\n| 网络搜索 | 找出某个关键字对应的网页 | 关键字 | 网页名称 |\n\n\n\n## 5.1 符号表实现\n\n> 1、符号表API设计\n\n**结点类：**\n\n| **类名** | **Node<Key,Value>**                               |\n| -------- | ------------------------------------------------- |\n| 构造方法 | Node(Key key,Value value,Node next)：创建Node对象 |\n| 成员变量 | 1.public Key key:存储键                           |\n|          | 2.public Value value:存储值                       |\n|          | 3.public Node next:存储下一个结点                 |\n\n**符号表：**\n\n| **类名** | **SymbolTable<Key,Value>**                                   |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | SymbolTable()：创建SymbolTable对象                           |\n| 成员方法 | 1.  public Value get(Key key)：根据键key，找对应的值         |\n|          | 2.  public void put(Key key,Value val):向符号表中插入一个键值对 |\n|          | 3.  public void delete(Key key):删除键为key的键值对          |\n|          | 4.  public int size()：获取符号表的大小                      |\n| 成员变量 | 1.  private Node head:记录首结点                             |\n|          | 2.  private int N:记录符号表中键值对的个数                   |\n\n> 2、符号表实现\n\n```java\n//符号表\npublic class SymbolTable<Key,Value> {\n    //记录首结点\n    private Node head;\n    //记录符号表中元素的个数\n    private int N;\n    public SymbolTable() {\n        head = new Node(null,null,null);\n        N=0;\n    }\n    //获取符号表中键值对的个数\n    public int size(){\n        return N;\n    }\n    //往符号表中插入键值对\n    public void put(Key key,Value value){\n        //先从符号表中查找键为key的键值对\n        Node n = head;\n        while(n.next!=null){\n            n = n.next;\n            if (n.key.equals(key)){\n                n.value=value;\n                return;\n            }\n        }\n        //符号表中没有键为key的键值对\n        Node oldFirst = head.next;\n        Node newFirst = new Node(key,value,oldFirst);\n        head.next = newFirst;\n        //个数+1\n        N++;\n    }\n    //删除符号表中键为key的键值对\n    public void delete(Key key){\n        Node n = head;\n        while(n.next!=null){\n            if (n.next.key.equals(key)){\n                n.next = n.next.next;\n                N--;\n                return;\n            }\n            n = n.next;\n        }\n    }\n    //从符号表中获取key对应的值\n    public Value get(Key key){\n        Node n = head;\n        while(n.next!=null){\n            n = n.next;\n            if (n.key.equals(key)){\n                return n.value;\n            }\n        }\n        return null;\n    }\n    private class Node{\n        //键\n        public Key key;\n        //值\n        public Value value;\n        //下一个结点\n        public Node next;\n        public Node(Key key, Value value, Node next) {\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n    }\n}\n//测试类\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        SymbolTable<Integer, String> st = new SymbolTable<>();\n        st.put(1, \"张三\");\n        st.put(3, \"李四\");\n        st.put(5, \"王五\");\n        System.out.println(st.size());\n        st.put(1,\"老三\");\n        System.out.println(st.get(1));\n        System.out.println(st.size());\n        st.delete(1);\n        System.out.println(st.size());\n    }\n}\n```\n\n\n\n## 5.2 有序符号表\n\n刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，那么接下来我们就实现一下有序符号表。\n\n> 1、代码实现\n\n```java\n//有序符号表\npublic class OrderSymbolTable<Key extends Comparable<Key>,Value> {\n    //记录首结点\n    private Node head;\n    //记录符号表中元素的个数\n    private int N;\n    public OrderSymbolTable() {\n        head = new Node(null,null,null);\n        N=0;\n    }\n    //获取符号表中键值对的个数\n    public int size(){\n        return N;\n    }\n    //往符号表中插入键值对\n    public void put(Key key,Value value){\n        //记录当前结点\n        Node curr = head.next;\n        //记录上一个结点\n        Node pre = head;\n        //1.如果key大于当前结点的key，则一直寻找下一个结点\n        while(curr!=null && key.compareTo(curr.key)>0){\n            pre = curr;\n            curr = curr.next;\n        }\n        //2.如果当前结点curr的key和将要插入的key一样，则替换\n        if (curr!=null && curr.key.compareTo(key)==0){\n            curr.value=value;\n            return;\n        }\n        //3.没有找到相同的key，把新结点插入到curr之前\n        Node newNode = new Node(key, value, curr);\n        pre.next = newNode;\n    }\n    //删除符号表中键为key的键值对\n    public void delete(Key key){\n        Node n = head;\n        while(n.next!=null){\n            if (n.next.key.equals(key)){\n                n.next = n.next.next;\n                N--;\n                return;\n            }\n            n = n.next;\n        }\n    }\n    //从符号表中获取key对应的值\n    public Value get(Key key){\n        Node n = head;\n        while(n.next!=null){\n            n = n.next;\n            if (n.key.equals(key)){\n                return n.value;\n            }\n        }\n        return null;\n    }\n    private class Node{\n        //键\n        public Key key;\n        //值\n        public Value value;\n        //下一个结点\n        public Node next;\n        public Node(Key key, Value value, Node next) {\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        OrderSymbolTable<Integer, String> bt = new OrderSymbolTable<>();\n        bt.put(4, \"二哈\");\n        bt.put(3, \"张三\");\n        bt.put(1, \"李四\");\n        bt.put(1, \"aa\");\n        bt.put(5, \"王五\");\n    }\n}\n```\n\n\n\n# 6. 树的入门\n\n树是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\n\n![image-20220714172929388](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714172929388.png)\n\n> 1、树具有以下特点：\n\n1. 每个结点有零个或多个子结点；\n\n2. 没有父结点的结点为根结点；\n\n3. 每一个非根结点只有一个父结点；\n\n4. 每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；\n\n> 2、树的相关术语\n\n**结点的度：**一个结点含有的子树的个数称为该结点的度； \n\n**叶结点：**度为0的结点称为叶结点，也可以叫做终端结点\n\n**分支结点：**度不为0的结点称为分支结点，也可以叫做非终端结点\n\n**结点的层次：**从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推\n\n**结点的序编号：**将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。\n\n**树的度：**树中所有结点的度的最大值\n\n**树的高度(深度)：**树中结点的最大层次\n\n**森林：**m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根结点，森林就变成一棵树\n\n**孩子结点：**一个结点的直接后继结点称为该结点的孩子结点\n\n**双亲结点(父结点)：**一个结点的直接前驱称为该结点的双亲结点\n\n**兄弟结点：**同一双亲结点的孩子结点间互称兄弟结点\n\n> 3、二叉树的基本概念\n\n**二叉树：**就是度不超过2的树（每个结点最多有两个子结点）\n\n![image-20220714173943757](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714173943757.png)\n\n**满二叉树：**如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。\n\n![image-20220714174007814](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714174007814.png)\n\n**完全二叉树：**叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树\n\n![image-20220714174155042](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220714174155042.png)\n\n\n\n## 6.1 二叉查找树\n\n> 1、结点类API设计：\n\n| **类名** | **Node<Key,Value>**                                          |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Node(Key  key, Value value, Node left, Node right)：创建Node对象 |\n| 成员变量 | 1.public Node left:记录左子结点                              |\n|          | 2.public Node right:记录右子结点                             |\n|          | 3.public Key key:存储键                                      |\n|          | 4.public Value value:存储值                                  |\n\n> 2、代码实现\n\n```java\nprivate class Node<Key,Value>{\n    //存储键\n    public Key key;\n    //存储值\n    private Value value;\n    //记录左子结点\n    public Node left;\n    //记录右子结点\n    public Node right;\n    public Node(Key key, Value value, Node left, Node right) {\n        this.key = key;\n        this.value = value;\n        this.left = left;\n        this.right = right;\n    }\n}\n```\n\n> 3、二叉查找树API设计\n\n| **类名** | **BinaryTree,Value value>**                                  |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | BinaryTree()：创建BinaryTree对象                             |\n| 成员变量 | 1.private Node root:记录根结点2.private int N:记录树中元素的个数 |\n| 成员方法 | 1. public void  put(Key key,Value value):向树中插入一个键值对 |\n|          | 2.private Node put(Node x, Key key,  Value val)：给指定树x上，添加键一个键值对，并返回添加后的新树 |\n|          | 3.public Value get(Key key):根据key，从树中找出对应的值      |\n|          | 4.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 |\n|          | 5.public void delete(Key key):根据key，删除树中对应的键值对  |\n|          | 6.  private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树 |\n|          | 7.  public int size():获取树中元素的个数                     |\n\n> 4、二叉查找树实现\n\n* 插入方法put实现思想：\n\n1. 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用\n\n2. 如果当前树不为空，则从根结点开始：\n   1. 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；\n   2. 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；\n   3. 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。\n\n* 查询方法get实现思想：\n\n从根节点开始：\n\n1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；\n\n2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；\n\n如果要查询的key等于当前结点的key，则树中返回当前结点的value。\n\n* 删除方法delete实现思想：\n\n1. 找到被删除结点；\n\n2. 找到被删除结点右子树中的最小结点minNode\n\n3. 删除右子树中的最小结点\n\n4. 让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子 树\n\n5. 让被删除结点的父节点指向最小结点minNode\n\n> 5、代码实现\n\n```java\n//二叉树代码\npublic class BinaryTree<Key extends Comparable<Key>, Value> {\n    //记录根结点\n    private Node root;\n    //记录树中元素的个数\n    private int N;\n    //获取树中元素的个数\n    public int size() {\n        return N;\n    }\n    //向树中添加元素key-value\n    public void put(Key key, Value value) {\n        root = put(root, key, value);\n    }\n    //向指定的树x中添加key-value,并返回添加元素后新的树\n    private Node put(Node x, Key key, Value value) {\n        if (x == null) {\n            //个数+1\n            N++;\n            return new Node(key, value, null, null);\n        }\n        int cmp = key.compareTo(x.key);\n        if (cmp > 0) {\n            //新结点的key大于当前结点的key，继续找当前结点的右子结点\n            x.right = put(x.right, key, value);\n        } else if (cmp < 0) {\n            //新结点的key小于当前结点的key，继续找当前结点的左子结点\n            x.left = put(x.left, key, value);\n        } else {\n            //新结点的key等于当前结点的key，把当前结点的value进行替换\n            x.value = value;\n        }\n        return x;\n    }\n    //查询树中指定key对应的value\n    public Value get(Key key) {\n        return get(root, key);\n    }\n//从指定的树x中，查找key对应的值\npublic Value get(Node x, Key key) {\n    if (x == null) {\n        return null;\n    }\n    int cmp = key.compareTo(x.key);\n    if (cmp > 0) {\n        //如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；\n        return get(x.right, key);\n    } else if (cmp < 0) {\n        //如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；\n        return get(x.left, key);\n    } else {\n        //如果要查询的key等于当前结点的key，则树中返回当前结点的value。\n        return x.value;\n    }\n}\n    //删除树中key对应的value\n    public void delete(Key key) {\n        root = delete(root, key);\n    }\n    //删除指定树x中的key对应的value，并返回删除后的新树\n    public Node delete(Node x, Key key) {\n        if (x == null) {\n            return null;\n        }\n        int cmp = key.compareTo(x.key);\n        if (cmp > 0) {\n            //新结点的key大于当前结点的key，继续找当前结点的右子结点\n            x.right = delete(x.right, key);\n        } else if (cmp < 0) {\n            //新结点的key小于当前结点的key，继续找当前结点的左子结点\n            x.left = delete(x.left, key);\n        } else {\n            //新结点的key等于当前结点的key,当前x就是要删除的结点\n            //1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点\n            if (x.right == null) {\n                return x.left;\n            }\n            //2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点\n            if (x.left == null) {\n                return x.right;\n            }\n            //3.当前结点的左右子树都存在\n            //3.1找到右子树中最小的结点\n            Node minNode = x.right;\n            while (minNode.left != null) {\n                minNode = minNode.left;\n            }\n            //3.2删除右子树中最小的结点\n            Node n = x.right;\n            while (n.left != null) {\n                if (n.left.left == null) {\n                    n.left = null;\n                } else {\n                    n = n.left;\n                }\n            }\n            //3.3让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点\n            //minNode的右子树\n            minNode.left = x.left;\n            minNode.right = x.right;\n            //3.4让被删除结点的父节点指向最小结点minNode\n            x = minNode;\n            //个数-1\n            N--;\n        }\n        return x;\n    }\n    private class Node {\n        //存储键\n        public Key key;\n        //存储值\n        private Value value;\n        //记录左子结点\n        public Node left;\n        //记录右子结点\n        public Node right;\n        public Node(Key key, Value value, Node left, Node right) {\n            this.key = key;\n            this.value = value;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BinaryTree<Integer, String> bt = new BinaryTree<>();\n        bt.put(4, \"二哈\");\n        bt.put(1, \"张三\");\n        bt.put(3, \"李四\");\n        bt.put(5, \"王五\");\n        System.out.println(bt.size());\n        bt.put(1,\"老三\");\n        System.out.println(bt.get(1));\n        System.out.println(bt.size());\n        bt.delete(1);\n        System.out.println(bt.size());\n    }\n}\n```\n\n\n\n> 6、 二叉查找树其他便捷方法\n\n* 查找二叉树中最小的键\n\n在某些情况下，我们需要查找出树中存储所有元素的键的最小值，比如我们的树中存储的是学生的排名和姓名数 据，那么需要查找出排名最低是多少名？这里我们设计如下两个方法来完成：\n\n| **public Key min()**     | **找出树中最小的键**            |\n| ------------------------ | ------------------------------- |\n| private Node min(Node x) | 找出指定树x中，最小键所在的结点 |\n\n```java\n//找出整个树中最小的键\npublic Key min(){\n    return min(root).key;\n}\n//找出指定树x中最小的键所在的结点\nprivate Node min(Node x){\n    if (x.left!=null){\n        return min(x.left);\n    }else{\n        return x;\n    }\n}\n```\n\n* 查找二叉树中最大的键\n\n在某些情况下，我们需要查找出树中存储所有元素的键的最大值，比如比如我们的树中存储的是学生的成绩和学生的姓名，那么需要查找出最高的分数是多少？这里我们同样设计两个方法来完成：\n\n| **public Key max()**     | **找出树中最大的键**            |\n| ------------------------ | ------------------------------- |\n| public Node max(Node  x) | 找出指定树x中，最大键所在的结点 |\n\n```java\n//找出整个树中最大的键\npublic Key max(){\n    return max(root).key;\n}\n//找出指定树x中最大键所在的结点\npublic Node max(Node x){\n    if (x.right!=null){\n        return max(x.right);\n    }else{\n        return x;\n    }\n}\n```\n\n\n\n## 6.2 二叉树的基本遍历\n\n很多情况下，我们可能需要像遍历数组数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的**搜索路径**进行遍历的问题。\n\n![image-20220715091328926](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715091328926.png)\n\n我们可以把二叉树的遍历分为以下三种方式：\n\n1. 前序遍历；\n\n先访问根结点，然后再访问左子树，最后访问右子树\n\n2. 中序遍历；\n\n先访问左子树，中间访问根节点，最后访问右子树\n\n3. 后序遍历；\n\n先访问左子树，再访问右子树，最后访问根节点\n\n如果我们分别对下面的树使用三种遍历方式进行遍历，得到的结果如下：\n\n![image-20220715091404362](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715091404362.png)\n\n\n\n### 6.2.1 前序遍历\n\n> 1、添加前序遍历的API：\n\n`public Queue<Key> preErgodic()：使用前序遍历，获取整个树中的所有键`\n\n`private void preErgodic(Node x,Queue<Key> keys)：使用前序遍历，把指定树x中的所有键放入到keys队列中`\n\n> 2、实现步骤：\n\n1. 把当前结点的key放入到队列中;\n\n2. 找到当前结点的左子树，如果不为空，递归遍历左子树\n\n3. 找到当前结点的右子树，如果不为空，递归遍历右子树\n\n```java\n//使用前序遍历，获取整个树中的所有键\npublic Queue<Key> preErgodic(){\n    Queue<Key> keys = new Queue<>();\n    preErgodic(root,keys);\n    return keys;\n}\n//使用前序遍历，把指定树x中的所有键放入到keys队列中\nprivate void preErgodic(Node x,Queue<Key> keys){\n    if (x==null){\n        return;\n    }\n    //1.把当前结点的key放入到队列中;\n    keys.enqueue(x.key);\n    //2.找到当前结点的左子树，如果不为空，递归遍历左子树\n    if (x.left!=null){\n        preErgodic(x.left,keys);\n    }\n    //3.找到当前结点的右子树，如果不为空，递归遍历右子树\n    if (x.right!=null){\n        preErgodic(x.right,keys);\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BinaryTree<String, String> bt = new BinaryTree<>();\n        bt.put(\"E\", \"5\");\n        bt.put(\"B\", \"2\");\n        bt.put(\"G\", \"7\");\n        bt.put(\"A\", \"1\");\n        bt.put(\"D\", \"4\");\n        bt.put(\"F\", \"6\");\n        bt.put(\"H\", \"8\");\n        bt.put(\"C\", \"3\");\n        Queue<String> queue = bt.preErgodic();\n        for (String key : queue) {\n            System.out.println(key+\"=\"+bt.get(key));\n        }\n    }\n}\n```\n\n\n\n### 6.2.2 中序遍历\n\n> 1、添加前序遍历的API：\n\n`public Queue<Key> midErgodic()：使用中序遍历，获取整个树中的所有键`\n\n`private void midErgodic(Node x,Queue<Key> keys)：使用中序遍历，把指定树x中的所有键放入到keys队列中`\n\n> 2、实现步骤：\n\n1. 找到当前结点的左子树，如果不为空，递归遍历左子树\n\n2. 把当前结点的key放入到队列中;\n\n3. 找到当前结点的右子树，如果不为空，递归遍历右子树\n\n```java\n//使用中序遍历，获取整个树中的所有键\npublic Queue<Key> midErgodic(){\n    Queue<Key> keys = new Queue<>();\n    midErgodic(root,keys);\n    return keys;\n}\n//使用中序遍历，把指定树x中的所有键放入到keys队列中\nprivate void midErgodic(Node x,Queue<Key> keys){\n    if (x==null){\n        return;\n    }\n    //1.找到当前结点的左子树，如果不为空，递归遍历左子树\n    if (x.left!=null){\n        midErgodic(x.left,keys);\n    }\n    //2.把当前结点的key放入到队列中;\n    keys.enqueue(x.key);\n    //3.找到当前结点的右子树，如果不为空，递归遍历右子树\n    if (x.right!=null){\n        midErgodic(x.right,keys);\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BinaryTree<String, String> bt = new BinaryTree<>();\n        bt.put(\"E\", \"5\");\n        bt.put(\"B\", \"2\");\n        bt.put(\"G\", \"7\");\n        bt.put(\"A\", \"1\");\n        bt.put(\"D\", \"4\");\n        bt.put(\"F\", \"6\");\n        bt.put(\"H\", \"8\");\n        bt.put(\"C\", \"3\");\n        Queue<String> queue = bt.midErgodic();\n        for (String key : queue) {\n            System.out.println(key+\"=\"+bt.get(key));\n        }\n    }\n}\n```\n\n\n\n### 6.2.3 后序遍历\n\n> 1、添加前序遍历的API：\n\n`public Queue<Key> afterErgodic()：使用后序遍历，获取整个树中的所有键`\n\n`private void afterErgodic(Node x,Queue<Key> keys)：使用后序遍历，把指定树x中的所有键放入到keys队列中`\n\n> 2、实现步骤：\n\n1. 找到当前结点的左子树，如果不为空，递归遍历左子树\n\n2. 找到当前结点的右子树，如果不为空，递归遍历右子树\n\n3. 把当前结点的key放入到队列中;\n\n```java\n//使用后序遍历，获取整个树中的所有键\npublic Queue<Key> afterErgodic(){\n    Queue<Key> keys = new Queue<>();\n    afterErgodic(root,keys);\n    return keys;\n}\n//使用后序遍历，把指定树x中的所有键放入到keys队列中\nprivate void afterErgodic(Node x,Queue<Key> keys){\n    if (x==null){\n        return;\n    }\n    //1.找到当前结点的左子树，如果不为空，递归遍历左子树\n    if (x.left!=null){\n        afterErgodic(x.left,keys);\n    }\n    //2.找到当前结点的右子树，如果不为空，递归遍历右子树\n    if (x.right!=null){\n       afterErgodic(x.right,keys);\n    }\n    //3.把当前结点的key放入到队列中;\n   keys.enqueue(x.key);\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BinaryTree<String, String> bt = new BinaryTree<>();\n        bt.put(\"E\", \"5\");\n        bt.put(\"B\", \"2\");\n        bt.put(\"G\", \"7\");\n        bt.put(\"A\", \"1\");\n        bt.put(\"D\", \"4\");\n        bt.put(\"F\", \"6\");\n        bt.put(\"H\", \"8\");\n        bt.put(\"C\", \"3\");\n        Queue<String> queue = bt.afterErgodic();\n        for (String key : queue) {\n            System.out.println(key+\"=\"+bt.get(key));\n        }\n    }\n}\n```\n\n\n\n## 6.3 二叉树的层序遍历\n\n所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值，有二叉树如下：\n\n![image-20220715094635056](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715094635056.png)\n\n那么层序遍历的结果是：EBGADFHC\n\n> 1、添加层序遍历的API：\n\n`public Queue<Key> layerErgodic()：使用层序遍历，获取整个树中的所有键`\n\n> 2、实现步骤：\n\n1. 创建队列，存储每一层的结点；\n\n2. 使用循环从队列中弹出一个结点：\n   1. 获取当前结点的key；\n   2. 如果当前结点的左子结点不为空，则把左子结点放入到队列中\n   3. 如果当前结点的右子结点不为空，则把右子结点放入到队列中\n\n![image-20220715112219392](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715112219392.png)\n\n```java\n//使用层序遍历得到树中所有的键\npublic Queue<Key> layerErgodic(){\n    Queue<Key> keys = new Queue<>();\n    Queue<Node> nodes = new Queue<>();\n    nodes.enqueue(root);\n    while(!nodes.isEmpty()){\n        Node x = nodes.dequeue();\n        keys.enqueue(x.key);\n        if (x.left!=null){\n            nodes.enqueue(x.left);\n        }\n        if (x.right!=null){\n            nodes.enqueue(x.right);\n        }\n    }\n    return keys;\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BinaryTree<String, String> bt = new BinaryTree<>();\n        bt.put(\"E\", \"5\");\n        bt.put(\"B\", \"2\");\n        bt.put(\"G\", \"7\");\n        bt.put(\"A\", \"1\");\n        bt.put(\"D\", \"4\");\n        bt.put(\"F\", \"6\");\n        bt.put(\"H\", \"8\");\n        bt.put(\"C\", \"3\");\n        Queue<String> queue = bt.layerErgodic();\n        for (String key : queue) {\n            System.out.println(key+\"=\"+bt.get(key));\n        }\n    }\n}\n```\n\n\n\n## 6.4 二叉树的最大深度问题\n\n> 1、需求：\n\n给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）;\n\n![image-20220715112431649](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715112431649.png)\n\n上面这棵树的最大深度为4。\n\n> 2、添加如下的API求最大深度：\n\n`public int maxDepth()：计算整个树的最大深度`\n\n`private int maxDepth(Node x):计算指定树x的最大深度`\n\n> 3、实现步骤：\n\n1. 如果根结点为空，则最大深度为0；\n\n2. 计算左子树的最大深度；\n\n3. 计算右子树的最大深度；\n\n4. 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1\n\n> 4、代码\n\n```java\n//计算整个树的最大深度\npublic int maxDepth() {\n    return maxDepth(root);\n}\n//计算指定树x的最大深度\nprivate int maxDepth(Node x) {\n    //1.如果根结点为空，则最大深度为0；\n    if (x == null) {\n        return 0;\n    }\n    int max = 0;\n    int maxL = 0;\n    int maxR = 0;\n    //2.计算左子树的最大深度；\n    if (x.left != null) {\n        maxL = maxDepth(x.left);\n    }\n    //3.计算右子树的最大深度；\n    if (x.right != null) {\n        maxR = maxDepth(x.right);\n    }\n    //4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1\n    max = maxL > maxR ? maxL + 1 : maxR + 1;\n    return max;\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        BinaryTree<String, String> bt = new BinaryTree<>();\n        bt.put(\"E\", \"5\");\n        bt.put(\"B\", \"2\");\n        bt.put(\"G\", \"7\");\n        bt.put(\"A\", \"1\");\n        bt.put(\"D\", \"4\");\n        bt.put(\"F\", \"6\");\n        bt.put(\"H\", \"8\");\n        bt.put(\"C\", \"3\");\n        int i = bt.maxDepth();\n        System.out.println(i);\n    }\n}\n```\n\n\n\n## 6.5 折纸问题\n\n> 1、需求：\n\n请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。\n\n给定一个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up\n\n![image-20220715112819213](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715112819213.png)\n\n> 2、分析：\n\n我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折 痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构 来描述对折后产生的折痕。\n\n这棵树有这样的特点：\n\n1. 根结点为下折痕；\n\n2. 每一个结点的左子结点为下折痕；\n\n3. 每一个结点的右子结点为上折痕；\n\n![image-20220715112857304](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715112857304.png)\n\n> 3、实现步骤：\n\n1. 定义结点类\n\n2. 构建深度为N的折痕树；\n\n3. 使用中序遍历，打印出树中所有结点的内容；\n\n> 4、构建深度为N的折痕树：\n\n1. 第一次对折，只有一条折痕，创建根结点；\n\n2. 如果不是第一次对折，则使用队列保存根结点；\n\n3. 循环遍历队列：\n   1. 从队列中拿出一个结点；\n   2. 如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；\n   3. 如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；\n   4. 判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一 个值为up的右子结点。\n\n> 5、实现代码\n\n```java\npublic class PaperFolding {\n    public static void main(String[] args) {\n        //构建折痕树\n        Node tree = createTree(3);\n        //遍历折痕树，并打印\n        printTree(tree);\n    }\n    //3.使用中序遍历，打印出树中所有结点的内容；\n    private static void printTree(Node tree) {\n        if (tree==null){\n            return;\n        }\n        printTree(tree.left);\n        System.out.print(tree.item+\",\");\n        printTree(tree.right);\n    }\n    //2.构建深度为N的折痕树；\n    private static Node createTree(int N) {\n        Node root = null;\n        for (int i = 0; i <N ; i++) {\n            if (i==0){\n                //1.第一次对折，只有一条折痕，创建根结点；\n                root = new Node(\"down\",null,null);\n            }else{\n                //2.如果不是第一次对折，则使用队列保存根结点；\n                Queue<Node> queue = new Queue<>();\n                queue.enqueue(root);\n                //3.循环遍历队列：\n                while(!queue.isEmpty()){\n                    //3.1从队列中拿出一个结点；\n                    Node tmp = queue.dequeue();\n                    //3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；\n                    if (tmp.left!=null){\n                        queue.enqueue(tmp.left);\n                    }\n                    //3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；\n                    if (tmp.right!=null){\n                        queue.enqueue(tmp.right);\n                    }\n                    //3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个\n                    值为down的左子结点，一个值为up的右子结点。\n                    if (tmp.left==null && tmp.right==null){\n                        tmp.left = new Node(\"down\",null,null);\n                        tmp.right = new Node(\"up\",null,null);\n                    }\n                }\n            }\n        }\n        return root;\n    }\n    //1.定义结点类\n    private static class Node{\n        //存储结点元素\n        String item;\n        //左子结点\n        Node left;\n        //右子结点\n        Node right;\n        public Node(String item,Node left,Node right){\n            this.item=item;\n            this.left=left;\n            this.right=right;\n        }\n    }\n}\n```\n\n\n\n# 7. 堆\n\n> 1、堆的定义\n\n堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。\n\n **堆的特性：**\n\n1. 它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不 是满的，那么要求左满右不满。\n\n![image-20220715113525127](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715113525127.png)\n\n2. 它通常用数组来实现。\n\n具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子 结点则分别在位置4,5,6和7，以此类推。\n\n![image-20220715113603031](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715113603031.png)\n\n如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不  使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2,向下一层就 令k等于2k或2k+1。\n\n3. 每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个 子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。\n\n\n\n## 7.1 堆的构建\n\n> 1、堆的API设计\n\n| **类名** | **Heap>**                                                    |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Heap(int capacity)：创建容量为capacity的Heap对象             |\n| 成员方法 | 1.  private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 |\n|          | 2.  private void exch(int i,int  j):交换堆中i索引和j索引处的值 |\n|          | 3.  public T delMax():删除堆中最大的元素,并返回这个最大元素  |\n|          | 4.  public void insert(T t)：往堆中插入一个元素              |\n|          | 5.  private void  swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 |\n|          | 6.  private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 |\n| 成员变量 | 1.  private T[] imtes : 用来存储元素的数组                   |\n|          | 2.  private int N：记录堆中元素的个数                        |\n\n> 2、insert插入方法的实现\n\n堆是用数组完成数据元素的存储的，由于数组的底层是一串连续的内存地址，所以我们要往堆中插入数据，我们只 能往数组中从索引0处开始，依次往后存放数据，但是堆中对元素的顺序是有要求的，每一个结点的数据要大于等 于它的两个子结点的数据，所以每次插入一个元素，都会使得堆中的数据顺序变乱，这个时候我们就需要通过一些方法让刚才插入的这个数据放入到合适的位置。\n\n![image-20220715113926279](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715113926279.png)\n\n![image-20220715113946610](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715113946610.png)\n\n所以，如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成 数据元素的交换，就可以完成堆的有序调整。\n\n> 3、delMax删除最大元素方法的实现\n\n由堆的特性我们可以知道，索引1处的元素，也就是根结点就是最大的元素，当我们把根结点的元素删除后，需要 有一个新的根结点出现，这时我们可以暂时把堆中最后一个元素放到索引1处，充当根结点，但是它有可能不满足 堆的有序性需求，这个时候我们就需要通过一些方法，让这个新的根结点放入到合适的位置。\n\n![image-20220715114712407](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715114712407.png)\n\n![image-20220715114746392](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715114746392.png)\n\n所以，当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k] 和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。\n\n> 4、堆的实现代码\n\n```java\n//堆代码\npublic class Heap<T extends Comparable<T>> {\n    //存储堆中的元素\n    private T[] items;\n    //记录堆中元素的个数\n    private int N;\n    public Heap(int capacity) {\n        items = (T[]) new Comparable[capacity+1];\n        N=0;\n    }\n    //判断堆中索引i处的元素是否小于索引j处的元素\n    private boolean less(int i,int j){\n        return items[i].compareTo(items[j])<0;\n    }\n    //交换堆中i索引和j索引处的值\n    private void exch(int i,int j){\n        T tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n    //往堆中插入一个元素\n    public void insert(T t){\n        items[++N] = t;\n        swim(N);\n    }\n    //删除堆中最大的元素,并返回这个最大元素\n    public T delMax(){\n        T max = items[1];\n        //交换索引1处和索引N处的值\n        exch(1,N);\n        //删除最后位置上的元素\n        items[N]=null;\n        N--;//个数-1\n        sink(1);\n        return max;\n    }\n    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void swim(int k){\n        //如果已经到了根结点，就不需要循环了\n        while(k>1){\n            //比较当前结点和其父结点\n            if(less(k/2,k)){\n                //父结点小于当前结点，需要交换\n                exch(k/2,k);\n            }\n            k = k/2;\n        }\n    }\n    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void sink(int k){\n        //如果当前已经是最底层了，就不需要循环了\n        while(2*k<=N){\n            //找到子结点中的较大者\n            int max;\n            if (2*k+1<=N){//存在右子结点\n                if (less(2*k,2*k+1)){\n                    max = 2*k+1;\n                }else{\n                    max = 2*k;\n                }\n            }else{//不存在右子结点\n                max = 2*k;\n            }\n            //比较当前结点和子结点中的较大者，如果当前结点不小，则结束循环\n            if (!less(k,max)){\n                break;\n            }\n            //当前结点小，则交换，\n            exch(k,max);\n            k = max;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        Heap<String> heap = new Heap<String>(20);\n        heap.insert(\"S\");\n        heap.insert(\"G\");\n        heap.insert(\"I\");\n        heap.insert(\"E\");\n        heap.insert(\"N\");\n        heap.insert(\"H\");\n        heap.insert(\"O\");\n        heap.insert(\"A\");\n        heap.insert(\"T\");\n        heap.insert(\"P\");\n        heap.insert(\"R\");\n        String del;\n        while((del=heap.delMax())!=null){\n            System.out.print(del+\",\");\n        }\n    }\n}\n```\n\n\n\n## 7.2 堆的排序\n\n> 1、需求\n\n给定一个数组：\n\nString[] arr = {\"S\",\"O\",\"R\",\"T\",\"E\",\"X\",\"A\",\"M\",\"P\",\"L\",\"E\"}\n\n请对数组中的字符按从小到大排序。\n\n> 2、实现步骤：\n\n1. 构造堆；\n\n2. 得到堆顶元素，这个值就是最大值；\n\n3. 交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置；\n\n4. 对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶；\n\n5. 重复2~4这个步骤，直到堆中剩一个元素为止。\n\n> 3、API设计：\n\n| **类名** | **<HeapSort>**                                               |\n| -------- | ------------------------------------------------------------ |\n| 成员方法 | 1.  public static void sort(Comparable[] source)：对source数组中的数据从小到大排序 |\n|          | 2.  private static void createHeap(Comparable[] source,  Comparable[] heap):根据原数组source，构造出堆heap |\n|          | 3.  private static  boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素 |\n|          | 4.  private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值 |\n|          | 5.  private static void sink(Comparable[] heap,  int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。 |\n\n> 4、堆构造过程\n\n堆的构造，最直观的想法就是另外再创建一个和新数组数组，然后从左往右遍历原数组，每得到一个元素后，添加 到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。\n\n上述的方式虽然很直观，也很简单，但是我们可以用更聪明一点的办法完成它。创建一个新数组，把原数组0~length-1的数据拷贝到新数组的1~length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后 对扫描到的每一个元素做下沉调整即可。\n\n![image-20220715115254151](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715115254151.png)\n\n![image-20220715115322080](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715115322080.png)\n\n* 堆构造完毕，堆有序！\n\n> 5、堆排序过程\n\n对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。\n\n1. 将堆顶元素和堆中最后一个元素交换位置；\n\n2. 通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到 了数组的最右边)\n\n3. 重复1~2步骤，直到堆中剩最后一个元素。\n\n![image-20220715115439401](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715115439401.png)\n\n![image-20220715115505007](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715115505007.png)\n\n![image-20220715115525609](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715115525609.png)\n\n![image-20220715115536253](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715115536253.png)\n\n> 6、代码：\n\n```java\n//对排序代码\npublic class HeapSort {\n    //对source数组中的数据从小到大排序\n    public static void sort(Comparable[] source) {\n        //1.创建一个比原数组大1的数组\n        Comparable[] heap = new Comparable[source.length + 1];\n        //2.构造堆\n        createHeap(source,heap);\n        //3.堆排序\n        //3.1定义一个变量，记录heap中未排序的所有元素中最大的索引\n        int N = heap.length-1;\n        while(N!=1){\n            //3.2交换heap中索引1处的元素和N处的元素\n            exch(heap,1,N);\n            N--;\n            //3.3对索引1处的元素在0~N范围内做下沉操作\n            sink(heap,1,N);\n        }\n        //4.heap中的数据已经有序，拷贝到source中\n        System.arraycopy(heap,1,source,0,source.length);\n    }\n    //根据原数组source，构造出堆heap\n    private static void createHeap(Comparable[] source, Comparable[] heap) {\n        //1.把source中的数据拷贝到heap中，从heap的1索引处开始填充\n        System.arraycopy(source,0,heap,1,source.length);\n        //2.从heap索引的一半处开始倒叙遍历，对得到的每一个元素做下沉操作\n        for (int i = (heap.length-1)/2; i>0 ; i--) {\n            sink(heap,i,heap.length-1);\n        }\n    }\n    //判断heap堆中索引i处的元素是否小于索引j处的元素\n    private static boolean less(Comparable[] heap, int i, int j) {\n        return heap[i].compareTo(heap[j])<0;\n    }\n    //交换heap堆中i索引和j索引处的值\n    private static void exch(Comparable[] heap, int i, int j) {\n        Comparable tmp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = tmp;\n    }\n    //在heap堆中，对target处的元素做下沉，范围是0~range\n    private static void sink(Comparable[] heap, int target, int range){\n        //没有子结点了\n        while (2*target<=range){\n            //1.找出target结点的两个子结点中的较大值\n            int max=2*target;\n            if (2*target+1<=range){\n                //存在右子结点\n                if (less(heap,2*target,2*target+1)){\n                    max=2*target+1;\n                }\n            }\n            //2.如果当前结点的值小于子结点中的较大值，则交换\n            if(less(heap,target,max)){\n                exch(heap,target,max);\n            }\n            //3.更新target的值\n            target=max;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        String[] arr = {\"S\", \"O\", \"R\", \"T\", \"E\", \"X\", \"A\", \"M\", \"P\", \"L\", \"E\"};\n        HeapSort.sort(arr);\n        System.out.println(Arrays.toString(arr));\n    }\n}\n```\n\n\n\n\n\n# 8. 优先队列\n\n普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。\n\n![image-20220715144646170](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715144646170.png)\n\n优先队列按照其作用不同，可以分为以下两种： \n\n**最大优先队列：**可以获取并删除队列中最大的值\n\n**最小优先队列：**可以获取并删除队列中最小的值\n\n\n\n## 8.1 最大优先队列\n\n我们之前学习过堆，而堆这种结构是可以方便的删除最大的值，所以，接下来我们可以基于堆区实现最大优先队列。\n\n> 1、最大优先队列API设计\n\n| **类名** | **MaxPriorityQueue>**                                        |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象 |\n| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 |\n|          | 2.private void exch(int i,int  j):交换堆中i索引和j索引处的值 |\n|          | 3.public T delMax():删除队列中最大的元素,并返回这个最大元素  |\n|          | 4.public void insert(T t)：往队列中插入一个元素              |\n|          | 5.private void  swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 |\n|          | 6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 |\n|          | 7.public int size():获取队列中元素的个数                     |\n|          | 8.public boolean  isEmpty():判断队列是否为空                 |\n| 成员变量 | 1.  private T[] imtes : 用来存储元素的数组                   |\n|          | 2.  private int N：记录堆中元素的个数                        |\n\n> 2、代码实现\n\n```java\n//最大优先队列代码\npublic class MaxPriorityQueue<T extends Comparable<T>> {\n    //存储堆中的元素\n    private T[] items;\n    //记录堆中元素的个数\n    private int N;\n    public MaxPriorityQueue(int capacity) {\n        items = (T[]) new Comparable[capacity+1];\n        N = 0;\n    }\n    //获取队列中元素的个数\n    public int size() {\n        return N;\n    }\n    //判断队列是否为空\n    public boolean isEmpty() {\n        return N == 0;\n    }\n    //判断堆中索引i处的元素是否小于索引j处的元素\n    private boolean less(int i, int j) {\n        return items[i].compareTo(items[j]) < 0;\n    }\n    //交换堆中i索引和j索引处的值\n    private void exch(int i, int j) {\n        T tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n    //往堆中插入一个元素\n    public void insert(T t) {\n        items[++N] = t;\n        swim(N);\n    }\n    //删除堆中最大的元素,并返回这个最大元素\n    public T delMax() {\n        T max = items[1];\n        //交换索引1处和索引N处的值\n        exch(1, N);\n        //删除最后位置上的元素\n        items[N] = null;\n        N--;//个数-1\n        sink(1);\n        return max;\n    }\n    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void swim(int k) {\n        //如果已经到了根结点，就不需要循环了\n        while (k > 1) {\n            //比较当前结点和其父结点\n            if (less(k / 2, k)) {\n                //父结点小于当前结点，需要交换\n                exch(k / 2, k);\n            }\n            k = k / 2;\n        }\n    }\n    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void sink(int k) {\n        //如果当前已经是最底层了，就不需要循环了\n        while (2 * k <= N) {\n            //找到子结点中的较大者\n            int max = 2 * k;\n            if (2 * k + 1 <= N) {//存在右子结点\n                if (less(2 * k, 2 * k + 1)) {\n                    max = 2 * k + 1;\n                }\n            }\n            //比较当前结点和子结点中的较大者，如果当前结点不小，则结束循环\n            if (!less(k, max)) {\n                break;\n            }\n            //当前结点小，则交换，\n            exch(k, max);\n            k = max;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        String[] arr = {\"S\", \"O\", \"R\", \"T\", \"E\", \"X\", \"A\", \"M\", \"P\", \"L\", \"E\"};\n        MaxPriorityQueue<String> maxpq = new MaxPriorityQueue<>(20);\n        for (String s : arr) {\n            maxpq.insert(s);\n        }\n        System.out.println(maxpq.size());\n        String del;\n        while(!maxpq.isEmpty()){\n            del = maxpq.delMax();\n            System.out.print(del+\",\");\n        }\n    }\n}\n```\n\n\n\n## 8.2 最小优先队列\n\n最小优先队列实现起来也比较简单，我们同样也可以基于堆来完成最小优先队列。\n\n我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性：\n\n1. 最大的元素放在数组的索引1处。\n\n2. 每个结点的数据总是大于等于它的两个子结点的数据。\n\n![image-20220715145151181](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715145151181.png)\n\n其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足 如下特性：\n\n1. 最小的元素放在数组的索引1处。\n\n2. 每个结点的数据总是小于等于它的两个子结点的数据\n\n![image-20220715145231351](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715145231351.png)\n\n> 1、最小优先队列API设计\n\n| **类名** | **MinPriorityQueue>**                                        |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象 |\n| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 |\n|          | 2.private void exch(int i,int  j):交换堆中i索引和j索引处的值 |\n|          | 3.public T delMin():删除队列中最小的元素,并返回这个最小元素  |\n|          | 4.public void insert(T t)：往队列中插入一个元素              |\n|          | 5.private void  swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 |\n|          | 6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 |\n|          | 7.public int size():获取队列中元素的个数                     |\n|          | 8.public boolean  isEmpty():判断队列是否为空                 |\n| 成员变量 | 1.  private T[] imtes : 用来存储元素的数组                   |\n|          | 2.  private int N：记录堆中元素的个数                        |\n\n> 2、最小优先队列代码实现\n\n```java\n//最小优先队列代码\npublic class MinPriorityQueue<T extends Comparable<T>> {\n    //存储堆中的元素\n    private T[] items;\n    //记录堆中元素的个数\n    private int N;\n\n    public MinPriorityQueue(int capacity) {\n        items = (T[]) new Comparable[capacity + 1];\n        N = 0;\n    }\n\n    //获取队列中元素的个数\n    public int size() {\n        return N;\n    }\n\n    //判断队列是否为空\n    public boolean isEmpty() {\n        return N == 0;\n    }\n\n    //判断堆中索引i处的元素是否小于索引j处的元素\n    private boolean less(int i, int j) {\n        return items[i].compareTo(items[j]) < 0;\n    }\n\n    //交换堆中i索引和j索引处的值\n    private void exch(int i, int j) {\n        T tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n\n    //往堆中插入一个元素\n    public void insert(T t) {\n        items[++N] = t;\n        swim(N);\n    }\n\n    //删除堆中最小的元素,并返回这个最小元素\n    public T delMin() {\n        //索引1处的值是最小值\n        T min = items[1];\n        //交换索引1处和索引N处的值\n        exch(1, N);\n        //删除索引N处的值\n        items[N] = null;\n        //数据元素-1\n        N--;\n        //对索引1处的值做下沉，使堆重新有序\n        sink(1);\n        //返回被删除的值\n        return min;\n    }\n\n    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void swim(int k) {\n        //如果没有父结点，则不再上浮\n        while (k > 1) {\n            //如果当前结点比父结点小，则交换\n            if (less(k, k / 2)) {\n                exch(k, k / 2);\n            }\n            k = k / 2;\n        }\n    }\n\n    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置\n    private void sink(int k) {\n        //如果没有子结点，则不再下沉\n        while (2 * k <= N) {\n            //找出子结点中的较小值的索引\n            int min = 2 * k;\n            if (2 * k + 1 <= N && less(2 * k + 1, 2 * k)) {\n                min = 2 * k + 1;\n            }\n            //如果当前结点小于子结点中的较小值，则结束循环\n            if (less(k, min)) {\n                break;\n            }\n            //当前结点大，交换\n            exch(min, k);\n            k = min;\n        }\n    }\n}\n\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        String[] arr = {\"S\", \"O\", \"R\", \"T\", \"E\", \"X\", \"A\", \"M\", \"P\", \"L\", \"E\"};\n        MinPriorityQueue<String> minpq = new MinPriorityQueue<>(20);\n        for (String s : arr) {\n            minpq.insert(s);\n        }\n        System.out.println(minpq.size());\n        String del;\n        while (!minpq.isEmpty()) {\n            del = minpq.delMin();\n            System.out.print(del + \",\");\n        }\n    }\n}\n```\n\n\n\n## 8.3 索引优先队列\n\n在之前实现的最大优先队列和最小优先队列，他们可以分别快速访问到队列中最大元素和最小元素，但是他们有一个缺点，就是没有办法通过索引访问已存在于优先队列中的对象，并更新它们。为了实现这个目的，在优先队列的基础上，学习一种新的数据结构，索引优先队列。接下来我们以最小索引优先队列举列。\n\n> 1、实现思路\n\n**步骤一：**\n\n存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。\n\n最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到items[k]即可。\n\n![image-20220715150715129](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715150715129.png)\n\n**步骤二：**\n\n步骤一完成后的结果，虽然我们给每个元素关联了一个整数，并且可以使用这个整数快速的获取到该元素，但是， items数组中的元素顺序是随机的，并不是堆有序的，所以，为了完成这个需求，我们可以增加一个数组int[]pq,来  保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。\n\n![image-20220715150754575](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715150754575.png)\n\n**步骤三：**\n\n通过步骤二的分析，我们可以发现，其实我们通过上浮和下沉做堆调整的时候，其实调整的是pq数组。如果需要 对items中的元素进行修改，比如让items[0]=“H”,那么很显然，我们需要对pq中的数据做堆调整，而且是调整pq[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需 要挑中pq[9]中元素的位置呢？\n\n最直观的想法就是遍历pq数组，拿出每一个元素和0做比较，如果当前元素是0，那么调整该索引处的元素即可， 但是效率很低。\n\n我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如： 在pq数组中：pq[1]=6;\n\n那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1;\n\n![image-20220715150825688](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715150825688.png)\n\n当有了pq数组后，如果我们修改items[0]=\"H\"，那么就可以先通过索引0，在qp数组中找到qp的索引：qp[0]=9,  那么直接调整pq[9]即可\n\n> 2、索引优先队列API设计\n\n| **类名** | **IndexMinPriorityQueue>**                                   |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | IndexMinPriorityQueue(int capacity)：创建容量为capacity的IndexMinPriorityQueue对象 |\n| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素 |\n|          | 2.private void exch(int i,int  j):交换堆中i索引和j索引处的值 |\n|          | 3.public int  delMin():删除队列中最小的元素,并返回该元素关联的索引 |\n|          | 4.public void insert(int i,T t)：往队列中插入一个元素,并关联索引i |\n|          | 5.private void  swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置 |\n|          | 6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 |\n|          | 7.public int size():获取队列中元素的个数                     |\n|          | 8.public  boolean isEmpty():判断队列是否为空                 |\n|          | 9.public  boolean contains(int k):判断k对应的元素是否存在    |\n|          | 10.public  void changeItem(int i, T t):把与索引i关联的元素修改为为t |\n|          | 11.public int minIndex():最小元素关联的索引                  |\n|          | 12.public void delete(int i):删除索引i关联的元素             |\n| 成员变量 | 1.  private T[] imtes : 用来存储元素的数组                   |\n|          | 2.  private int[] pq:保存每个元素在items数组中的索引，pq数组需要堆有序 |\n|          | 3.  private int [] qp:保存qp的逆序，pq的值作为索引，pq的索引作为值 |\n|          | 4.  private int N：记录堆中元素的个数                        |\n\n> 3、索引优先队列代码实现\n\n```java\n//最小索引优先队列代码\npackage cn.itcast;\n\npublic class IndexMinPriorityQueue<T extends Comparable<T>> {\n    //存储堆中的元素\n    private T[] items;\n    //保存每个元素在items数组中的索引，pq数组需要堆有序\n    private int[] pq;\n    //保存qp的逆序，pq的值作为索引，pq的索引作为值\n    private int[] qp;\n    //记录堆中元素的个数\n    private int N;\n    public IndexMinPriorityQueue(int capacity) {\n        items = (T[]) new Comparable[capacity + 1];\n        pq = new int[capacity + 1];\n        qp = new int[capacity + 1];\n        N = 0;\n        for (int i = 0; i < qp.length; i++) {\n            //默认情况下，qp逆序中不保存任何索引\n            qp[i] = -1;\n        }\n    }\n    //获取队列中元素的个数\n    public int size() {\n        return N;\n    }\n    //判断队列是否为空\n    public boolean isEmpty() {\n        return N == 0;\n    }\n    //判断堆中索引i处的元素是否小于索引j处的元素\n    private boolean less(int i, int j) {\n        //先通过pq找出items中的索引，然后再找出items中的元素进行对比\n        return items[pq[i]].compareTo(items[pq[j]]) < 0;\n    }\n    //交换堆中i索引和j索引处的值\n    private void exch(int i, int j) {\n        //先交换pq数组中的值\n        int tmp = pq[i];\n        pq[i] = pq[j];\n        pq[j] = tmp;\n        //更新qp数组中的值\n        qp[pq[i]] = i;\n        qp[pq[j]] = j;\n    }\n    //判断k对应的元素是否存在\n    public boolean contains(int k) {\n        //默认情况下，qp的所有元素都为-1，如果某个位置插入了数据，则不为-1\n        return qp[k] != -1;\n\n    }\n}\n\n//最小元素关联的索引\npublic int minIndex() {\n//pq的索引1处，存放的是最小元素在items中的索引\n    return pq[1];\n}\n\n//往队列中插入一个元素,并关联索引i\npublic void insert(int i, T t) {\n//如果索引i处已经存在了元素，则不让插入\n    if (contains(i)) {\n        throw new RuntimeException(\"该索引已经存在\");\n    }\n    //个数+1\n    N++;\n    //把元素存放到items数组中\n    items[i] = t;\n    //使用pq存放i这个索引\n    pq[N] = i;\n    //在qp的i索引处存放N\n    qp[i] = N;\n    //上浮items[pq[N]],让pq堆有序\n    swim(N);\n}\n\n//删除队列中最小的元素,并返回该元素关联的索引\npublic int delMin() {\n    //找到items中最小元素的索引\n    int minIndex = pq[1];\n    //交换pq中索引1处的值和N处的值\n    exch(1, N);\n    //删除qp中索引pq[N]处的值\n    qp[pq[N]] = -1;\n    //删除pq中索引N处的值\n    pq[N] = -1;\n    //删除items中的最小元素\n    items[minIndex] = null;\n    //元素数量-1\n    N--;\n    //对pq[1]做下沉，让堆有序\n    sink(1);\n    return minIndex;\n}\n\n//删除索引i关联的元素\npublic void delete(int i) {\n    //找出i在pq中的索引\n    int k = qp[i];\n    //把pq中索引k处的值和索引N处的值交换\n    exch(k, N);\n    //删除qp中索引pq[N]处的值\n    qp[pq[N]] = -1;\n    //删除pq中索引N处的值\n    pq[N] = -1;\n    //删除items中索引i处的值\n    items[i] = null;\n    //元素数量-1\n    N--;\n    //对pq[k]做下沉，让堆有序\n    sink(k);\n    //对pq[k]做上浮，让堆有序\n    swim(k);\n}\n\n//把与索引i关联的元素修改为为t\npublic void changeItem(int i, T t) {\n    //修改items数组中索引i处的值为t\n    items[i] = t;\n    //找到i在pq中的位置\n    int k = qp[i];\n    //对pq[k]做下沉，让堆有序\n    sink(k);\n    //对pq[k]做上浮，让堆有序\n    swim(k);\n}\n\n//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置\nprivate void swim(int k) {\n    //如果已经到了根结点，则结束上浮\n    while (k > 1) {\n        //比较当前结点和父结点，如果当前结点比父结点小，则交换位置\n        if (less(k, k / 2)) {\n            exch(k, k / 2);\n        }\n        k = k / 2;\n    }\n}\n\n//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置\nprivate void sink(int k) {\n    //如果当前结点已经没有子结点了，则结束下沉\n    while (2 * k <= N) {\n        //找出子结点中的较小值\n        int min = 2 * k;\n        if (2 * k + 1 <= N && less(2 * k + 1, 2 * k)) {\n            min = 2 * k + 1;\n        }\n        //如果当前结点的值比子结点中的较小值小，则结束下沉\n        if (less(k, min)) {\n            break;\n        }\n        exch(k, min);\n        k = min;\n    }\n}\n\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) {\n        String[] arr = {\"S\", \"O\", \"R\", \"T\", \"E\", \"X\", \"A\", \"M\", \"P\", \"L\", \"E\"};\n        IndexMinPriorityQueue<String> indexMinPQ = new IndexMinPriorityQueue<>(20);\n    //插入\n        for (int i = 0; i < arr.length; i++) {\n            indexMinPQ.insert(i,arr[i]);\n        }\n        System.out.println(indexMinPQ.size());\n    //获取最小值的索引\n        System.out.println(indexMinPQ.minIndex());\n    //测试修改\n        indexMinPQ.changeItem(0,\"Z\");\n        int minIndex=-1;\n        while(!indexMinPQ.isEmpty()){\n            minIndex = indexMinPQ.delMin();\n            System.out.print(minIndex+\",\");\n        }\n    }\n}\n```\n\n\n\n# 9. 树的进阶\n\n## 9.1 平衡树\n\n之前我们学习过二叉查找树，发现它的查询效率比单纯的链表和数组的查询效率要高很多，大部分情况下，确实是 这样的，但不幸的是，在最坏情况下，二叉查找树的性能还是很糟糕。\n\n例如我们依次往二叉查找树中插入9,8,7,6,5,4,3,2,1这9个数据，那么最终构造出来的树是长得下面这个样子：\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715151803341.png\" alt=\"image-20220715151803341\" style=\"zoom:67%;\" />\n\n我们会发现，如果我们要查找1这个元素，查找的效率依旧会很低。效率低的原因在于这个树并不平衡，全部是向左边分支，如果我们有一种方法，能够不受插入数据的影响，让生成的树都像完全二叉树那样，那么即使在最坏情况下，查找的效率依旧会很好。\n\n\n\n### 9.1.1 2-3查找树\n\n为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我 们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和 三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。\n\n> 1、2-3查找树的定义\n\n一棵2-3查找树要么为空，要么满足满足下面两个要求：\n\n**2-结点：**\n\n含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。\n\n**3-结点：**\n\n含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。\n\n![image-20220715152116351](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152116351.png)\n\n> 2、查找\n\n将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。\n\n![image-20220715152201499](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152201499.png)\n\n> 3、插入\n\n1. 向2-结点插入新建\n\n往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之 所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一 个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节 点结束于一个3-结点，那么可能有点麻烦。\n\n![image-20220715152255464](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152255464.png)\n\n2. 向一棵只含有一个3-结点的树中插入新键\n\n假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结 点能存放三个元素，暂时使其变成一个4-结点，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升， 左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。\n\n![image-20220715152350642](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152350642.png)\n\n\n\n3. 向一个父结点为2-结点的3-结点中插入新键\n\n和上面的情况一样一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。\n\n![image-20220715152437191](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152437191.png)\n\n4. 向一个父结点为3-结点的3-结点中插入新键\n\n当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点， 插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其 变为3-结点，不需要继续进行拆分。\n\n![image-20220715152510519](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152510519.png)\n\n![image-20220715152535160](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152535160.png)\n\n5. 分解根结点\n\n当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将 根结点拆分为两个2-结点，树的高度加1。\n\n![image-20220715152652168](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715152652168.png)\n\n> 4、2-3树的性质\n\n通过对2-3树插入操作的分析，我们发现在插入的时候，2-3树需要做一些局部的变换来保持2-3树的平衡。 一棵完全平衡的2-3树具有以下性质：\n\n1. 任意空链接到根结点的路径长度都是相等的。\n\n2. 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。\n\n3. 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。\n\n> 5、2-3树的实现\n\n直接实现2-3树比较复杂，因为：\n\n* 需要处理不同的结点类型，非常繁琐； 需要多次比较操作来将结点下移；\n* 需要上移来拆分4-结点；\n* 拆分4-结点的情况有很多种；\n\n2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要。\n\n\n\n### 9.1.2 红黑树\n\n我们前面介绍了2-3树，可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点都是2-结点，树的高度为lgN,相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。\n\n红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型：\n\n**红链接：**将两个2-结点连接起来构成一个3-结点；  \n\n**黑链接：**则是2-3树中的普通链接。\n\n确切的说，我们将3-结点表示为由由一条**左斜**的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2- 结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。\n\n![image-20220715153048462](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153048462.png)\n\n> 1、红黑树的定义\n\n红黑树是含有红黑链接并满足下列条件的二叉查找树：\n\n1. 红链接均为左链接；\n\n2. 没有任何一个结点同时和两条红链接相连；\n\n3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同；\n\n下面是红黑树与2-3树的对应关系：\n\n![image-20220715153151683](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153151683.png)\n\n> 2、红黑树结点API\n\n因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的Node结点中添加一个布 尔类型的变量color来表示链接的颜色。如果指向它的链接是红色的，那么该变量的值为true，如果链接是黑色的，那么该变量的值为false\n\n![image-20220715153230362](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153230362.png)\n\n**API设计：**\n\n| **类名** | **Node<Key,Value>**                                          |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Node(Key key, Value value,  Node left, Node right，boolean color)：创建Node对象 |\n| 成员变量 | 1.public Node left:记录左子结点                              |\n|          | 2.public Node right:记录右子结点                             |\n|          | 3.public Key key:存储键                                      |\n|          | 4. public Value  value:存储值                                |\n|          | 5. public boolean  color:由其父结点指向它的链接的颜色        |\n\n> 3、代码实现：\n\n```java\nprivate class Node<Key,Value>{\n    //存储键\n    public Key key;\n    //存储值\n    private Value value;\n    //记录左子结点\n    public Node left;\n    //记录右子结点\n    public Node right;\n    //由其父结点指向它的链接的颜色\n    public boolean color;\n    public Node(Key key, Value value, Node left,Node right,boolean color) {\n        this.key = key;\n        this.value = value;\n        this.left = left;\n        this.right = right;\n        this.color = color;\n    }\n}\n```\n\n> 4、平衡化\n\n在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。\n\n1. 左旋\n\n当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。\n\n**前提：**当前结点为h，它的右子结点为x；\n\n**左旋过程：**\n\n1. 让x的左子结点变为h的右子结点：h.right=x.left; \n\n2. 让h成为x的左子结点：x.left=h;\n\n3. 让h的color属性变为x的color属性值：x.color=h.color;\n\n4. 让h的color属性变为RED：h.color=true;\n\n![image-20220715153622000](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153622000.png)\n\n2. 右旋\n\n当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋\n\n**前提：**当前结点为h，它的左子结点为x；\n\n**右旋过程：**\n\n1. 让x的右子结点成为h的左子结点：h.left = x.right;\n\n2. 让h成为x的右子结点：x.right=h;\n\n3. 让x的color变为h的color属性值：x.color = h.color;\n\n4. 让h的color为RED；\n\n![image-20220715153719855](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153719855.png)\n\n> 5、向单个2-结点中插入新键\n\n一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键后，我们马上就需要将他们旋转。\n\n* 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。\n\n![image-20220715153814912](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153814912.png)\n\n* 如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把   红色右链接变成左链接，插入操作才算完成。形成的新的红黑树依然和3-结点等价，其中含有两个键，一条红 色链接。\n\n![image-20220715153834787](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153834787.png)\n\n> 6、向底部的2-结点插入新键\n\n用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一 区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方 式仍然适用。\n\n![image-20220715153912512](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153912512.png)\n\n> 7、颜色反转\n\n当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子 结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。\n\n![image-20220715153944865](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715153944865.png)\n\n> 8、向一棵双键树(即一个3-结点)中插入新键\n\n这种情况有可以分为三种子情况：\n\n1. 新键大于原树中的两个键\n\n![image-20220715154030470](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715154030470.png)\n\n2. 新键小于原树中的两个键\n\n![image-20220715154119726](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715154119726.png)\n\n3. 新键介于原数中两个键之间\n\n![image-20220715154137792](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715154137792.png)\n\n* 根结点的颜色总是黑色\n\n之前我们介绍结点API的时候，在结点Node对象中color属性表示的是父结点指向当前结点的连接的颜色，由于根 结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。\n\n> 10、向树底部的3-结点插入新键\n\n假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接(此时我们需要进行右旋转然后再转换)，或是中链 接(此时需要先左旋转然后再右旋转，最后转换颜色)。颜色转换会使中间结点的颜色变红，相当于将它送入了父结 点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2-结点或者根结点为止。\n\n![image-20220715154542222](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715154542222.png)\n\n![image-20220715154617932](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715154617932.png)\n\n> 11、红黑树的API设计\n\n| **类名** | **RedBlackTree, Value>**                                     |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | RedBlackTree()：创建RedBlackTree对象                         |\n| 成员方法 | 1.private boolean isRed(Node x)：判断当前结点的父指向链接是否为红色 |\n|          | 2.private Node rotateLeft(Node h):左旋调整                   |\n|          | 3.private Node rotateRight(Node h):右旋调整                  |\n|          | 4.private  void ﬂipColors(Node h)：颜色反转,相当于完成拆分4-结点 |\n|          | 5.public void  put(Key key, Value  val):在整个树上完成插入操作 |\n|          | 6.private Node put(Node h, Key key, Value  val):在指定树中，完成插入操作,并返回添加元素后新的树 |\n|          | 7. public Value get(Key key):根据key，从树中找出对应的值     |\n|          | 8.private Value get(Node x, Key key):从指定的树x中，找出key对应的值 |\n|          | 9.public int size():获取树中元素的个数                       |\n| 成员变量 | 1.private Node root : 记录根结点                             |\n|          | 2. private int N:记录树中元素的个数                          |\n|          | 3.private  static ﬁnal boolean  RED：红色链接标识            |\n|          | 4.private  static ﬁnal boolean  BLACK:黑色链接标识           |\n\n> 12、红黑树的实现\n\n```java\n//红黑树代码\npublic class RedBlackTree<Key extends Comparable<Key>, Value> {\n    //根节点\n    private Node root;\n    //记录树中元素的个数\n    private int N;\n    //红色链接\n    private static final boolean RED = true;\n    //黑色链接\n    private static final boolean BLACK = false;\n    /**\n     * 判断当前节点的父指向链接是否为红色\n     *\n     * @param x\n     * @return\n     */\n    private boolean isRed(Node x) {\n        //空结点默认是黑色链接\n        if (x == null) {\n            return false;\n        }\n        //非空结点需要判断结点color属性的值\n        return x.color == RED;\n    }\n    /**\n     * 左旋转\n     *\n     * @param h\n     * @return\n     */\n    private Node rotateLeft(Node h) {\n        //找出当前结点h的右子结点\n        Node hRight = h.right;\n        //找出右子结点的左子结点\n        Node lhRight = hRight.left;\n        //让当前结点h的右子结点的左子结点成为当前结点的右子结点\n        h.right = lhRight;\n        //让当前结点h称为右子结点的左子结点\n        hRight.left = h;\n        //让当前结点h的color编程右子结点的color\n        hRight.color = h.color;\n        //让当前结点h的color变为RED\n        h.color = RED;\n        //返回当前结点的右子结点\n        return hRight;\n    }\n    /**\n    * 右旋\n    *\n    * @param h\n    * @return\n    */\n    private Node rotateRight(Node h) {\n        //找出当前结点h的左子结点\n        Node hLeft = h.left;\n        //找出当前结点h的左子结点的右子结点\n        Node rHleft = hLeft.right;\n        //让当前结点h的左子结点的右子结点称为当前结点的左子结点\n        h.left = rHleft;\n        //让当前结点称为左子结点的右子结点\n        hLeft.right = h;\n        //让当前结点h的color值称为左子结点的color值\n        hLeft.color = h.color;\n        //让当前结点h的color变为RED\n        h.color = RED;\n        //返回当前结点的左子结点\n        return hLeft;\n    }\n    /**\n     * 颜色反转,相当于完成拆分4-节点\n     *\n     * @param h\n     */\n    private void flipColors(Node h) {\n        //当前结点的color属性值变为RED；\n        h.color = RED;\n        //当前结点的左右子结点的color属性值都变为黑色\n        h.left.color = BLACK;\n        h.right.color = BLACK;\n    }\n    /**\n     * 在整个树上完成插入操作\n     *\n     * @param key\n     * @param val\n     */\n    public void put(Key key, Value val) {\n        //在root整个树上插入key-val\n        root = put(root, key, val);\n        //让根结点的颜色变为BLACK\n        root.color = BLACK;\n    }\n        /**\n         * 在指定树中，完成插入操作,并返回添加元素后新的树\n         *\n         * @param h\n         * @param key\n         * @param val\n         */\n    private Node put(Node h, Key key, Value val) {\n        if (h == null) {\n            //标准的插入操作，和父结点用红链接相连\n            N++;\n            return new Node(key, val, null, null, RED);\n        }\n        //比较要插入的键和当前结点的键\n        int cmp = key.compareTo(h.key);\n        if (cmp < 0) {\n            //继续寻找左子树插入\n            h.left = put(h.left, key, val);\n        } else if (cmp > 0) {\n            //继续寻找右子树插入\n            h.right = put(h.right, key, val);\n        } else {\n          //已经有相同的结点存在，修改节点的值；\n            h.value = val;\n        }\n        //如果当前结点的右链接是红色，左链接是黑色，需要左旋\n        if (isRed(h.right) && !isRed(h.left)) {\n            h=rotateLeft(h);\n        }\n         //如果当前结点的左子结点和左子结点的左子结点都是红色链接，则需要右旋\n        if (isRed(h.left) && isRed(h.left.left)) {\n            h=rotateRight(h);\n        }\n        //如果当前结点的左链接和右链接都是红色，需要颜色变换\n        if (isRed(h.left) && isRed(h.right)) {\n            flipColors(h);\n        }\n        //返回当前结点\n        return h;\n    }\n    //根据key，从树中找出对应的值\n    public Value get(Key key) {\n        return get(root, key);\n    }\n    //从指定的树x中，查找key对应的值\n    public Value get(Node x, Key key) {\n        //如果当前结点为空，则没有找到,返回null\n        if (x == null) {\n            return null;\n        }\n        //比较当前结点的键和key\n        int cmp = key.compareTo(x.key);\n        if (cmp < 0) {\n            //如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；\n            return get(x.left, key);\n        } else if (cmp > 0) {\n            //如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；\n            return get(x.right, key);\n        } else {\n            //如果要查询的key等于当前结点的key，则树中返回当前结点的value。\n            return x.value;\n        }\n    }\n    //获取树中元素的个数\n    public int size() {\n        return N;\n    }\n    //结点类\n    private class Node {\n        //存储键\n        public Key key;\n        //存储值\n        private Value value;\n        //记录左子结点\n        public Node left;\n        //记录右子结点\n        public Node right;\n        //由其父结点指向它的链接的颜色\n        public boolean color;\n        public Node(Key key, Value value, Node left, Node right, boolean color) {\n            this.key = key;\n            this.value = value;\n            this.left = left;\n            this.right = right;\n            this.color = color;\n        }\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        RedBlackTree<Integer, String> bt = new RedBlackTree<>();\n        bt.put(4, \"二哈\");\n        bt.put(1, \"张三\");\n        bt.put(3, \"李四\");\n        bt.put(5, \"王五\");\n        System.out.println(bt.size());\n        bt.put(1,\"老三\");\n        System.out.println(bt.get(1));\n        System.out.println(bt.size());\n    }\n}\n```\n\n\n\n## 9.2 B-树\n\n前面我们已经学习了二叉查找树、2-3树以及它的实现红黑树。2-3树中，一个结点做多能有两个key，它的实现红  黑树中使用对链接染色的方式去表达这两个key。接下来我们学习另外一种树型结构B树，这种数据结构中，一个结 点允许多于两个key的存在。\n\nB树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度进行查找、顺序读取、插 入和删除等操作。\n\n> 1、B树的特性\n\nB树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选 择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：\n\n* 每个结点最多有M-1个key，并且以升序排列；\n* 每个结点最多能有M个子结点；\n* 根结点至少有两个子结点；\n\n![image-20220715165436182](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715165436182.png)\n\n> 2、B树存储数据\n\n若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。\n\n![image-20220715165805421](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715165805421.png)\n\n> 3、B树在磁盘文件中的应用\n\n在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。\n\n> 4、磁盘\n\n磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级。\n\n![image-20220715170137083](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715170137083.png)\n\n磁盘由盘片构成,每个盘片有两面，又称为盘面  。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内  。盘片的每个表面是由一组称为磁道同心圆组成的 ，每个磁道被划分为了一组扇区 ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。\n\n> 5、磁盘IO\n\n![image-20220715170212378](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715170212378.png)\n\n磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头 定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就 可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 **寻道时间**，**旋转时间**，以及**传送时间**。\n\n由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘\n\n**I/O**，减少读写操作。  为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字\n\n**节**，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的 局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻 道时间，只需很少的旋转时间），因此预读可以提高I/O效率。\n\n**页**是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储 块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程  序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位 置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。\n\n**文件系统**的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每  个结点只需要一次I/O就可以完全载入。那么3层的B树可以容纳1024*1024*1024差不多10亿个数据，如果换成二叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查 找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。\n\n\n\n## 9.3 B+树\n\nB+树是对B树的一种变形树，它与B树的差异在于：\n\n1. 非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；\n\n2. 树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。\n\n> 1、B+树存储数据\n\n若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。\n\n![image-20220715170442646](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715170442646.png)\n\n>2、B+树和B树的对比\n\n**B+ 树的优点在于：**\n\n1.由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。 2.B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。\n\n**B树的优点在于：**\n\n由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶 子结点的深度，才能找到value。\n\n> 3、B+树在数据库中的应用\n\n在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题， 在很多数据库中，都是用到了B+树来提高查询的效率；\n\n在操作数据库时，我们为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这 个索引就是B+树这种数据结构实现的。\n\n> 4、未建立主键索引查询\n\n![image-20220715170648060](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715170648060.png)\n\n执行`select * from user where id=18`，需要从第一条数据开始，一直查询到第6条，发现id=18，此时才能查询出目标结果，共需要比较6次；\n\n> 5、建立主键索引查询\n\n![image-20220715170749402](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715170749402.png)\n\n> 6、区间查询\n\n执行`select * from user where id>=12 and id<=18`如果有了索引，由于B+树的叶子结点形成了一个有序链表，所以我们只需要找到id为12的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。\n\n\n\n# 10. 并查集\n\n并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作： \n\n* 查询元素p和元素q是否属于同一组\n* 合并元素p和元素q所在的组\n\n![image-20220715171019840](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715171019840.png)\n\n> 1、并查集结构\n\n并查集也是一种树型结构，但这棵树跟我们之前讲的二叉树、红黑树、B树等都不一样，这种树的要求比较简单：\n\n1. 每个元素都唯一的对应一个结点；\n\n2. 每一组数据中的多个元素都在同一颗树中；\n\n3. 一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；\n\n4. 元素在树中并没有子父级关系的硬性要求；\n\n![image-20220715171058304](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715171058304.png)\n\n> 2、并查集API设计\n\n| **类名** | **UF**                                                       |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | UF(int N)：初始化并查集，以整数标识(0,N-1)个结点             |\n| 成员方法 | 1.  public int  count()：获取当前并查集中的数据有多少个分组  |\n|          | 2.  public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 |\n|          | 3.  public int  ﬁnd(int p):元素p所在分组的标识符             |\n|          | 4.  public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |\n| 成员变量 | 1.  private int[] eleAndGroup: 记录结点元素和该元素所在分组的标识  2.  private int count：记录并查集中数据的分组个数 |\n\n> 3、并查集的实现\n\n* UF(int N)构造方法实现\n\n1. 初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组；\n\n2. 初始化数组eleAndGroup；\n\n3. 把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点 所在的分组，那么初始化情况下，i索引处存储的值就是i\n\n![image-20220715171308384](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715171308384.png)\n\n* union(int p,int q)合并方法实现\n\n1. 如果p和q已经在同一个分组中，则无需合并\n\n2. 如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即 可\n\n3. 分组数量-1\n\n![image-20220715171338493](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715171338493.png)\n\n> 4、代码\n\n```java\n//并查集代码\npublic class UF {\n    //记录结点元素和该元素所在分组的标识\n    private int[] eleAndGroup;\n    //记录并查集中数据的分组个数\n    private int count;\n    //初始化并查集\n    public UF(int N){\n        //初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组\n        this.count=N;\n        //初始化数组\n        eleAndGroup = new int[N];\n        //把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i索引处存储的值就是i\n        for (int i = 0; i < N; i++) {\n            eleAndGroup[i]=i;\n        }\n    }\n    //获取当前并查集中的数据有多少个分组\n    public int count(){\n        return count;\n    }\n    //元素p所在分组的标识符\n    public int find(int p){\n        return eleAndGroup[p];\n    }\n    //判断并查集中元素p和元素q是否在同一分组中\n    public boolean connected(int p,int q){\n        return find(p)==find(q);\n    }\n    //把p元素所在分组和q元素所在分组合并\n    public void union(int p,int q){\n        //如果p和q已经在同一个分组中，则无需合并；\n        if (connected(p,q)){\n            return;\n        }\n        //如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即可\n        int pGroup = find(p);\n        int qGroup = find(q);\n        for (int i = 0; i < eleAndGroup.length; i++) {\n            if (eleAndGroup[i]==pGroup){\n                eleAndGroup[i]=qGroup;\n            }\n        }\n        //分组数量-1\n        count--;\n    }\n}\n//测试代码\npublic class Test {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请录入并查集中元素的个数:\");\n        int N = sc.nextInt();\n        UF uf = new UF(N);\n        while(true){\n            System.out.println(\"请录入您要合并的第一个点:\");\n            int p = sc.nextInt();\n            System.out.println(\"请录入您要合并的第二个点:\");\n            int q = sc.nextInt();\n            //判断p和q是否在同一个组\n            if (uf.connected(p,q)){\n                System.out.println(\"结点：\"+p+\"结点\"+q+\"已经在同一个组\");\n                continue;\n            }\n            uf.union(p,q);\n            System.out.println(\"总共还有\"+uf.count()+\"个分组\");\n        }\n    }\n}\n```\n\n> 5、并查集应用举例\n\n如果我们并查集存储的每一个整数表示的是一个大型计算机网络中的计算机，则我们就可以通过connected(int p,int q)来检测，该网络中的某两台计算机之间是否连通？如果连通，则他们之间可以通信，如果不连通，则不能通信，此时我们又可以调用union(int p,int q)使得p和q之间连通，这样两台计算机之间就可以通信了。\n\n一般像计算机这样网络型的数据，我们要求网络中的每两个数据之间都是相连通的，也就是说，我们需要调用很多 次union方法，使得网络中所有数据相连，其实我们很容易可以得出，如果要让网络中的数据都相连，则我们至少 要调用N-1次union方法才可以，但由于我们的union方法中使用for循环遍历了所有的元素，所以很明显，我们之前实现的合并算法的时间复杂度是O(N^2)，如果要解决大规模问题，它是不合适的，所以我们需要对算法进行优化。\n\n\n\n## 10.1 UF_Tree算法优化\n\n为了提升union算法的性能，我们需要重新设计ﬁnd方法和union方法的实现，此时我们先需要对我们的之前数据结  构中的eleAndGourp数组的含义进行重新设定：\n\n1. 我们仍然让eleAndGroup数组的索引作为某个结点的元素；\n\n2. eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点；\n\n![image-20220715171713329](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715171713329.png)\n\n> 1、UF_Tree API设计\n\n| **类名** | **UF_Tree**                                                  |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | UF_Tree(int N)：初始化并查集，以整数标识(0,N-1)个结点        |\n| 成员方法 | 1.  public int  count()：获取当前并查集中的数据有多少个分组  |\n|          | 2.  public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 |\n|          | 3.  public int  ﬁnd(int p):元素p所在分组的标识符             |\n|          | 4.  public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |\n| 成员变量 | 1.  private int[]  eleAndGroup: 记录结点元素和该元素的父结点 |\n|          | 2.  private int count：记录并查集中数据的分组个数            |\n\n> 2、ﬁnd(int p)查询方法实现\n\n1. 判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；\n\n2. 如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；\n\n![image-20220715171910941](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715171910941.png)\n\n> 3、union(int p,int q)合并方法实现\n\n1. 找到p元素所在树的根结点\n\n2. 找到q元素所在树的根结点\n\n3. 如果p和q已经在同一个树中，则无需合并；\n\n4. 如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；\n\n5. 分组数量-1\n\n![image-20220715171946353](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715171946353.png)\n\n> 4、代码\n\n```java\npackage cn.itcast;\npublic class UF_Tree {\n    //记录结点元素和该元素所的父结点\n    private int[] eleAndGroup;\n    //记录并查集中数据的分组个数\n    private int count;\n\n    //初始化并查集\n    public UF_Tree(int N) {\n        //初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组\n        this.count = N;\n        //初始化数组\n        eleAndGroup = new int[N];\n        //把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点的父结点，那么初始化情况下，i索引处存储的值就是i\n        for (int i = 0; i < N; i++) {\n            eleAndGroup[i] = i;\n        }\n    }\n\n    //获取当前并查集中的数据有多少个分组\n    public int count() {\n        return count;\n    }\n\n    //元素p所在分组的标识符\n    public int find(int p) {\n        while (true) {\n            //判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；\n            if (p == eleAndGroup[p]) {\n                return p;\n            }\n            //如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；\n            p = eleAndGroup[p];\n        }\n    }\n\n    //判断并查集中元素p和元素q是否在同一分组中\n    public boolean connected(int p, int q) {\n        return find(p) == find(q);\n    }\n\n    //把p元素所在分组和q元素所在分组合并\n    public void union(int p, int q) {\n        //找到p元素所在树的根结点\n        int pRoot = find(p);\n        //找到q元素所在树的根结点\n        int qRoot = find(q);\n        //如果p和q已经在同一个树中，则无需合并；\n        if (pRoot == qRoot) {\n            return;\n        }\n        //如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；\n        eleAndGroup[pRoot] = qRoot;\n        //分组数量-1\n        count--;\n    }\n}\n```\n\n> 5、优化后的性能分析\n\n我们优化后的算法union，如果要把并查集中所有的数据连通，仍然至少要调用N-1次union方法，但是，我们发现union方法中已经没有了for循环，所以union算法的时间复杂度由O(N^2)变为了O(N)。\n\n但是这个算法仍然有问题，因为我们之前不仅修改了union算法，还修改了ﬁnd算法。我们修改前的ﬁnd算法的时  间复杂度在任何情况下都为O(1)，但修改后的ﬁnd算法在最坏情况下是O(N)：\n\n![image-20220715172155165](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715172155165.png)\n\n在union方法中调用了ﬁnd方法，所以在最坏情况下union算法的时间复杂度仍然为O(N^2)。\n\n\n\n## 10.2 路径压缩\n\nUF_Tree中最坏情况下union算法的时间复杂度为O(N^2)，其最主要的问题在于最坏情况下，树的深度和数组的大 小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化ﬁnd方法。\n\n之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，如果  我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小 树的深度。\n\n![image-20220715172227802](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715172227802.png)\n\n只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高ﬁnd方法的效   率。为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码 调整数组中的值。\n\n> 1、UF_Tree_Weighted API设计\n\n| **类名** | **UF_Tree_Weighted**                                         |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | UF_Tree_Weighted(int N)：初始化并查集，以整数标识(0,N-1)个结点 |\n| 成员方法 | 1.  public int  count()：获取当前并查集中的数据有多少个分组  |\n|          | 2.  public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中 |\n|          | 3.  public int  ﬁnd(int p):元素p所在分组的标识符             |\n|          | 4.  public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |\n| 成员变量 | 1.  private int[] eleAndGroup: 记录结点元素和该元素的父结点  |\n|          | 2.  private int[] sz: 存储每个根结点对应的树中元素的个数3.private int count：记录并查集中数据的分组个数 |\n\n> 2、代码\n\n```java\npublic class UF_Tree_Weighted {\n    //记录结点元素和该元素所的父结点\n    private int[] eleAndGroup;\n    //存储每个根结点对应的树中元素的个数\n    private int[] sz;\n    //记录并查集中数据的分组个数\n    private int count;\n    //初始化并查集\n    public UF_Tree_Weighted(int N){\n        //初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组\n        this.count=N;\n        //初始化数组\n        eleAndGroup = new int[N];\n        sz = new int[N];\n        //把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点的父结点，那么初始化情况下，i索引处存储的值就是i\n        for (int i = 0; i < N; i++) {\n            eleAndGroup[i]=i;\n        }\n        //把sz数组中所有的元素初始化为1，默认情况下，每个结点都是一个独立的树，每个树中只有一个元素\n        for (int i = 0; i < sz.length; i++) {\n            sz[i]=1;\n        }\n    }\n    //获取当前并查集中的数据有多少个分组\n    public int count(){\n        return count;\n    }\n    //元素p所在分组的标识符\n    public int find(int p){\n        while(true){\n            //判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；\n            if (p==eleAndGroup[p]){\n                return p;\n            }\n            //如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；\n            p=eleAndGroup[p];\n        }\n    }\n    //判断并查集中元素p和元素q是否在同一分组中\n    public boolean connected(int p,int q){\n        return find(p)==find(q);\n    }\n    //把p元素所在分组和q元素所在分组合并\n    public void union(int p,int q){\n        //找到p元素所在树的根结点\n        int pRoot = find(p);\n        //找到q元素所在树的根结点\n        int qRoot = find(q);\n        //如果p和q已经在同一个树中，则无需合并；\n        if (pRoot==qRoot){\n            return;\n        }\n        //如果p和q不在同一个分组，比较p所在树的元素个数和q所在树的元素个数,把较小的树合并到较大的树上\n        if (sz[pRoot]<sz[qRoot]){\n            eleAndGroup[pRoot] = qRoot;\n            //重新调整较大树的元素个数\n            sz[qRoot]+=sz[pRoot];\n        }else{\n            eleAndGroup[qRoot]=pRoot;\n            sz[pRoot]+=sz[qRoot];\n        }\n        //分组数量-1\n        count--;\n    }\n}\n```\n\n\n\n## 10.3 案例-畅通工程\n\n某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目 标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问 最少还需要建设多少条道路？\n\n在我们的测试数据文件夹中有一个trﬃc_project.txt文件，它就是诚征道路统计表，下面是对数据的解释：\n\n![image-20220715172628144](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715172628144.png)\n\n总共有20个城市，目前已经修改好了7条道路，问还需要修建多少条道路，才能让这20个城市之间全部相通？\n\n> 1、解题思路：\n\n1. 创建一个并查集UF_Tree_Weighted(20);\n\n2. 分别调用union(0,1),union(6,9),union(3,8),union(5,11),union(2,12),union(6,10),union(4,8)，表示已经修建好的道路把对应的城市连接起来；\n\n3. 如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前 并查集中剩余的数目，减去1，就是还需要修建的道路数目；\n\n> 2、代码：\n\n```java\npublic class Traffic_Project {\n    public static void main(String[] args)throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new\n                InputStreamReader(Traffic_Project.class.getClassLoader().getResourceAsStream(\"traffic_projec\n                t.txt\")));\n        //读取城市数目，初始化并查集\n        int number = Integer.parseInt(reader.readLine());\n        UF_Tree_Weighted uf = new UF_Tree_Weighted(number);\n        //读取已经修建好的道路数目\n        int roadNumber = Integer.parseInt(reader.readLine());\n        //循环读取已经修建好的道路，并调用union方法\n        for (int i = 0; i < roadNumber; i++) {\n            String line = reader.readLine();\n            int p = Integer.parseInt(line.split(\" \")[0]);\n            int q = Integer.parseInt(line.split(\" \")[1]);\n            uf.union(p,q);\n        }\n        //获取剩余的分组数量\n        int groupNumber = uf.count();\n        //计算出还需要修建的道路\n        System.out.println(\"还需要修建\"+(groupNumber-1)+\"道路，城市才能相通\");\n    }\n}\n```\n\n\n\n# 11. 图的入门\n\n> 1、图的定义及分类\n\n**定义：**图是由一组顶点和一组能够将两个顶点相连的边组成的\n\n![image-20220715172909202](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715172909202.png)\n\n**特殊的图：**\n\n1. 自环：即一条连接一个顶点和其自身的边；\n\n2. 平行边：连接同一对顶点的两条边；\n\n![image-20220715172938209](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715172938209.png)\n\n**图的分类：**\n\n按照连接两个顶点的边的不同，可以把图分为以下两种： \n\n* 无向图：边仅仅连接两个顶点，没有其他含义；\n\n* 有向图：边不仅连接两个顶点，并且具有方向；\n\n\n\n## 11.1 无向图的基本概念\n\n> 1、图的相关术语\n\n**相邻顶点：**当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。 \n\n**度：**某个顶点的度就是依附于该顶点的边的个数\n\n**子图：**是一幅图的所有边的子集(包含这些边依附的顶点)组成的图； \n\n**路径：**是由边顺序连接的一系列的顶点组成\n\n**环：**是一条至少含有一条边且终点和起点相同的路径\n\n![image-20220715173147899](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715173147899.png)\n\n**连通图：**如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图\n\n**连通子图：**一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图\n\n![image-20220715173226364](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715173226364.png)\n\n\n\n> 2、图的存储结构\n\n要表示一幅图，只需要表示清楚以下两部分内容即可：\n\n1. 图中所有的顶点；\n\n2. 所有连接顶点的边；\n\n常见的图的存储结构有两种：邻接矩阵和邻接表\n\n> 3、邻接矩阵\n\n1. 使用一个V*V的二维数组int[V] adj,把索引的值看做是顶点；\n\n2. 如果顶点v和顶点w相连，我们只需要将adj[v][w]和adj[w][v]的值设置为1,否则设置为0即可\n\n![image-20220715173421294](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715173421294.png)\n\n很明显，邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能 不够用。\n\n> 4、邻接表\n\n1. 使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；\n\n2. 每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点\n\n![image-20220715173505717](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715173505717.png)\n\n很明显，邻接表的空间并不是是线性级别的，所以后面我们一直采用邻接表这种存储形式来表示图。\n\n\n\n## 11.2 图的实现\n\n> 1、图的API设计\n\n| **类名** | **Graph**                                                |\n| -------- | -------------------------------------------------------- |\n| 构造方法 | Graph(int V)：创建一个包含V个顶点但不包含边的图          |\n| 成员方法 | 1.public int V():获取图中顶点的数量                      |\n|          | 2.public int E():获取图中边的数量                        |\n|          | 3.public void addEdge(int v,int  w):向图中添加一条边 v-w |\n|          | 4.public Queue adj(int v)：获取和顶点v相邻的所有顶点     |\n| 成员变量 | 1.private ﬁnal int V: 记录顶点数量                       |\n|          | 2.private int E: 记录边数量                              |\n|          | 3.private  Queue[] adj: 邻接表                           |\n\n> 2、代码实现\n\n```java\npublic class Graph {\n    //顶点数目\n    private final int V;\n    //边的数目\n    private int E;\n    //邻接表\n    private Queue<Integer>[] adj;\n    public Graph(int V){\n        //初始化顶点数量\n        this.V = V;\n        //初始化边的数量\n        this.E=0;\n        //初始化邻接表\n        this.adj = new Queue[V];\n        //初始化邻接表中的空队列\n        for (int i = 0; i < adj.length; i++) {\n            adj[i] = new Queue<Integer>();\n        }\n    }\n    //获取顶点数目\n    public int V(){\n        return V;\n    }\n    //获取边的数目\n    public int E(){\n        return E;\n    }\n    //向图中添加一条边 v-w\n    public void addEdge(int v, int w) {\n        //把w添加到v的链表中，这样顶点v就多了一个相邻点w\n        adj[v].enqueue(w);\n        //把v添加到w的链表中，这样顶点w就多了一个相邻点v\n        adj[w].enqueue(v);\n        //边的数目自增1\n        E++;\n    }\n    //获取和顶点v相邻的所有顶点\n    public Queue<Integer> adj(int v){\n        return adj[v];\n    }\n}\n```\n\n\n\n## 11.3 深度优先搜索\n\n在很多情况下，我们需要遍历图，得到图的一些性质，例如，找出图中与指定的顶点相连的所有顶点，或者判定某 个顶点与指定顶点是否相通，是非常常见的需求。\n\n有关图的搜索，最经典的算法有**深度优先搜索**和**广度优先搜索**，接下来我们分别讲解这两种搜索算法。\n\n> 1、深度优先搜索\n\n所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。\n\n![image-20220715174041838](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715174041838.png)\n\n很明显，在由于边是没有方向的，所以，如果4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相  邻链表中，那么为了不对顶点进行重复搜索，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布 尔类型的数组  boolean[V]  marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true， 如果没有搜索，标记为false；\n\n> 2、API设计\n\n| **类名** | **DepthFirstSearch**                                         |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | DepthFirstSearch(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点 |\n| 成员方法 | 1.private void  dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点 |\n|          | 2.public boolean  marked(int w):判断w顶点与s顶点是否相通     |\n|          | 3.public int count():获取与顶点s相通的所有顶点的总数         |\n| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 |\n|          | 2. private int count：记录有多少个顶点与s顶点相通            |\n\n> 3、代码\n\n```java\npublic class DepthFirstSearch {\n    //索引代表顶点，值表示当前顶点是否已经被搜索\n    private boolean[] marked;\n    //记录有多少个顶点与s顶点相通\n    private int count;\n    //构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相邻顶点\n    public DepthFirstSearch(Graph G,int s){\n        //创建一个和图的顶点数一样大小的布尔数组\n        marked = new boolean[G.V()];\n        //搜索G图中与顶点s相同的所有顶点\n        dfs(G,s);\n    }\n    //使用深度优先搜索找出G图中v顶点的所有相邻顶点\n    private void dfs(Graph G, int v){\n        //把当前顶点标记为已搜索\n        marked[v]=true;\n        //遍历v顶点的邻接表，得到每一个顶点w\n        for (Integer w : G.adj(v)){\n            //如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点\n            if (!marked[w]){\n                dfs(G,w);\n            }\n        }\n        //相通的顶点数量+1\n        count++;\n    }\n    //判断w顶点与s顶点是否相通\n    public boolean marked(int w){\n        return marked[w];\n    }\n    //获取与顶点s相通的所有顶点的总数\n    public int count(){\n        return count;\n    }\n}\n```\n\n\n\n## 11.4 广度优先搜索\n\n所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后 找子结点。\n\n![image-20220715174445487](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715174445487.png)\n\n> 1、API设计：\n\n| **类名** | **BreadthFirstSearch**                                       |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | BreadthFirstSearch(Graph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点 |\n| 成员方法 | 1.private void  bfs(Graph G, int v)：使用广度优先搜索找出G图中v顶点的所有相邻顶点 |\n|          | 2.public boolean  marked(int w):判断w顶点与s顶点是否相通     |\n|          | 3.public int count():获取与顶点s相通的所有顶点的总数         |\n| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 |\n|          | 2. private int  count：记录有多少个顶点与s顶点相通           |\n|          | 3. private  Queue waitSearch: 用来存储待搜索邻接表的点       |\n\n> 2、代码实现\n\n```java\npublic class BreadthFirstSearch {\n    //索引代表顶点，值表示当前顶点是否已经被搜索\n    private boolean[] marked;\n    //记录有多少个顶点与s顶点相通\n    private int count;\n    //用来存储待搜索邻接表的点\n    private Queue<Integer> waitSearch;\n    //构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点\n    public BreadthFirstSearch(Graph G, int s) {\n        //创建一个和图的顶点数一样大小的布尔数组\n        marked = new boolean[G.V()];\n        //初始化待搜索顶点的队列\n        waitSearch = new Queue<Integer>();\n        //搜索G图中与顶点s相同的所有顶点\n        dfs(G, s);\n    }\n    //使用广度优先搜索找出G图中v顶点的所有相邻顶点\n    private void dfs(Graph G, int v) {\n        //把当前顶点v标记为已搜索\n        marked[v]=true;\n        //把当前顶点v放入到队列中，等待搜索它的邻接表\n        waitSearch.enqueue(v);\n        //使用while循环从队列中拿出待搜索的顶点wait，进行搜索邻接表\n        while(!waitSearch.isEmpty()){\n            Integer wait = waitSearch.dequeue();\n            //遍历wait顶点的邻接表，得到每一个顶点w\n            for (Integer w : G.adj(wait)) {\n                //如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点\n                if (!marked[w]) {\n                    dfs(G, w);\n                }\n            }\n        }\n        //相通的顶点数量+1\n        count++;\n    }\n    //判断w顶点与s顶点是否相通\n    public boolean marked(int w) {\n        return marked[w];\n    }\n    //获取与顶点s相通的所有顶点的总数\n    public int count() {\n        return count;\n    }\n}\n```\n\n\n\n## 11.5 案例-畅通工程续1\n\n某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目 标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。目 前的道路状况，9号城市和10号城市是否相通？9号城市和8号城市是否相通？\n\n在我们的测试数据文件夹中有一个trﬃc_project.txt文件，它就是诚征道路统计表，下面是对数据的解释：\n\n![image-20220715180129821](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715180129821.png)\n\n总共有20个城市，目前已经修改好了7条道路，问9号城市和10号城市是否相通？9号城市和8号城市是否相通？\n\n> 1、解题思路：\n\n1. 创建一个图Graph对象，表示城市；\n\n2. 分别调用addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)，表示已 经修建好的道路把对应的城市连接起来；\n\n3. 通过Graph对象和顶点9，构建DepthFirstSearch对象或BreadthFirstSearch对象；\n\n4. 调用搜索对象的marked(10)方法和marked(8)方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相 通。\n\n> 2、代码：\n\n```java\npackage cn.itcast;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class Traffic_Project2 {\n    public static void main(String[] args) throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new\n                InputStreamReader(Traffic_Project2.class.getClassLoader().getResourceAsStream(\"traffic_proje\n                ct.txt\")));\n        //读取城市数目，初始化Graph图\n        int number = Integer.parseInt(reader.readLine());\n        Graph G = new Graph(number);\n        //读取已经修建好的道路数目\n        int roadNumber = Integer.parseInt(reader.readLine());\n        //循环读取已经修建好的道路，并调用addEdge方法\n        for (int i = 0; i < roadNumber; i++) {\n            String line = reader.readLine();\n            int p = Integer.parseInt(line.split(\" \")[0]);\n            int q = Integer.parseInt(line.split(\" \")[1]);\n            G.addEdge(p, q);\n        }\n        //根据图G和顶点9构建图的搜索对象\n        //BreadthFirstSearch search = new BreadthFirstSearch(G,9);\n        DepthFirstSearch search = new DepthFirstSearch(G, 9);\n        //调用搜索对象的marked(10)方法和marked(8)方法\n        boolean flag1 = search.marked(10);\n        boolean flag2 = search.marked(8);\n        System.out.println(\"9号城市和10号城市是否已相通：\" + flag1);\n        System.out.println(\"9号城市和8号城市是否已相通：\" + flag2);\n    }\n}\n```\n\n\n\n## 11.6 路径查找\n\n在实际生活中，地图是我们经常使用的一种工具，通常我们会用它进行导航，输入一个出发城市，输入一个目的地 城市，就可以把路线规划好，而在规划好的这个路线上，会路过很多中间的城市。这类问题翻译成专业问题就是： 从s顶点到v顶点是否存在一条路径？如果存在，请找出这条路径。\n\n![image-20220715180413869](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715180413869.png)\n\n例如在上图上查找顶点0到顶点4的路径用红色标识出来,那么我们可以把该路径表示为  0-2-3-4。\n\n> 1、路径查找API设计\n\n| **类名** | **DepthFirstPaths**                                          |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | DepthFirstPaths(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径 |\n| 成员方法 | 1.private void  dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相邻顶点 |\n|          | 2.public boolean  hasPathTo(int v):判断v顶点与s顶点是否存在路径 |\n|          | 3.public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点) |\n| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 |\n|          | 2. private int s:起点                                        |\n|          | 3. private int[] edgeTo:索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 |\n\n> 2、路径查找实现\n\n我们实现路径查找，最基本的操作还是得遍历并搜索图，所以，我们的实现暂且基于深度优先搜索来完成。其搜索 的过程是比较简单的。我们添加了edgeTo[]整型数组，这个整型数组会记录从每个顶点回到起点s的路径。\n\n如果我们把顶点设定为0，那么它的搜索可以表示为下图：\n\n![image-20220715180624904](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715180624904.png)\n\n![image-20220715180640002](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715180640002.png)\n\n根据最终edgeTo的结果，我们很容易能够找到从起点0到任意顶点的路径；\n\n> 3、代码\n\n```java\npublic class DepthFirstPaths {\n    //索引代表顶点，值表示当前顶点是否已经被搜索\n    private boolean[] marked;\n    //起点\n    private int s;\n    //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点\n    private int[] edgeTo;\n    //构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径\n    public DepthFirstPaths(Graph G, int s){\n        //创建一个和图的顶点数一样大小的布尔数组\n        marked = new boolean[G.V()];\n        //创建一个和图顶点数一样大小的整型数组\n        edgeTo = new int[G.V()];\n        //初始化顶点\n        this.s=s;\n        //搜索G图中起点为s的所有路径\n        dfs(G,s);\n    }\n    //使用深度优先搜索找出G图中v顶点的所有相邻顶点\n    private void dfs(Graph G, int v){\n        //把当前顶点标记为已搜索\n        marked[v]=true;\n        //遍历v顶点的邻接表，得到每一个顶点w\n        for (Integer w : G.adj(v)){\n            //如果当前顶点w没有被搜索过，则将edgeTo[w]设置为v,表示w的前一个顶点为v，并递归搜索与w顶点相通的其他顶点\n            if (!marked[w]){\n                edgeTo[w]=v;\n                dfs(G,w);\n            }\n        }\n    }\n    //判断w顶点与s顶点是否存在路径\n    public boolean hasPathTo(int v){\n        return marked[v];\n    }\n    //找出从起点s到顶点v的路径(就是该路径经过的顶点)\n    public Stack<Integer> pathTo(int v){\n        //当前v顶点与s顶点不连通，所以直接返回null，没有路径\n        if (!hasPathTo(v)){\n            return null;\n        }\n        //创建路劲中经过的顶点的容器\n        Stack<Integer> path = new Stack<Integer>();\n        //第一次把当前顶点存进去，然后将x变换为到达当前顶点的前一个顶点edgeTo[x],在把前一个顶点存进去，继续将x变化为到达前一个顶点的前一个顶点，继续存，一直到x的值为s为止，相当于逆推法，最后把s放进去\n        for (int x = v;x!=s;x=edgeTo[x]){\n            //把当前顶点放入容器\n            path.push(x);\n        }\n        //把起点s放入容器\n        path.push(s);\n        return path;\n    }\n}\n//测试代码\npublic class DepthFirstPathsTest {\n    public static void main(String[] args) throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new\n                InputStreamReader(DepthFirstPathsTest.class.getClassLoader().getResourceAsStream(\"road_find.\n                txt\")));\n        //读取城市数目，初始化Graph图\n        int number = Integer.parseInt(reader.readLine());\n        Graph G = new Graph(number);\n        //读取城市的连通道路\n        int roadNumber = Integer.parseInt(reader.readLine());\n        //循环读取道路，并调用addEdge方法\n        for (int i = 0; i < roadNumber; i++) {\n            String line = reader.readLine();\n            int p = Integer.parseInt(line.split(\" \")[0]);\n            int q = Integer.parseInt(line.split(\" \")[1]);\n            G.addEdge(p, q);\n        }\n        //根据图G和顶点0路径查找对象\n        DepthFirstPaths paths = new DepthFirstPaths(G, 0);\n        //调用查找对象的pathTo(4)方法得到路径\n        Stack<Integer> path = paths.pathTo(4);\n        //遍历打印\n        StringBuilder sb = new StringBuilder();\n        for (Integer v : path) {\n            sb.append(v+\"-\");\n        }\n        sb.deleteCharAt(sb.length()-1);\n        System.out.println(sb);\n    }\n}\n```\n\n\n\n# 12. 图的进阶\n\n## 12.1 有向图的基本概念\n\n> 1、概述\n\n**定义：**有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。\n\n**出度：**由某个顶点指出的边的个数称为该顶点的出度。\n\n**入度：**指向某个顶点的边的个数称为该顶点的入度。\n\n**有向路径：**由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。\n\n**有向环：**一条至少含有一条边，且起点和终点相同的有向路径。\n\n![image-20220715213254762](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715213254762.png)\n\n* 一副有向图中两个顶点v和w可能存在以下**四种关系**：\n\n1. 没有边相连；\n\n2. 存在从v到w的边v—>w;\n3. 存在从w到v的边w—>v;\n4. 既存在w到v的边，也存在v到w的边，即双向连接；\n\n理解有向图是一件比较简单的，但如果要通过眼睛看出复杂有向图中的路径就不是那么容易了。\n\n![image-20220715213347356](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715213347356.png)\n\n> 2、有向图API设计\n\n| **类名** | **Digraph**                                                  |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Digraph(int V)：创建一个包含V个顶点但不包含边的有向图        |\n| 成员方法 | 1.public int  V():获取图中顶点的数量                         |\n|          | 2.public int E():获取图中边的数量                            |\n|          | 3.public void addEdge(int v,int w):向有向图中添加一条边 v->w |\n|          | 4.public Queue adj(int v)：获取由v指出的边所连接的所有顶点   |\n|          | 5.private Digraph reverse():该图的反向图                     |\n| 成员变量 | 1.private  ﬁnal int V: 记录顶点数量                          |\n|          | 2.private int E: 记录边数量                                  |\n|          | 3.private Queue[] adj: 邻接表                                |\n\n在api中设计了一个反向图，其因为有向图的实现中，用adj方法获取出来的是由当前顶点v指向的其他顶点，如果 能得到其反向图，就可以很容易得到指向v的其他顶点。\n\n> 3、有向图实现\n\n```java\npublic class Digraph {\n    //顶点数目\n    private final int V;\n    //边的数目\n    private int E;\n    //邻接表\n    private Queue<Integer>[] adj;\n    public Digraph(int V){\n        //初始化顶点数量\n        this.V = V;\n        //初始化边的数量\n        this.E=0;\n        //初始化邻接表\n        this.adj = new Queue[V];\n        //初始化邻接表中的空队列\n        for (int i = 0; i < adj.length; i++) {\n            adj[i] = new Queue<Integer>();\n        }\n    }\n    //获取顶点数目\n    public int V(){\n        return V;\n    }\n    //获取边的数目\n    public int E(){\n        return E;\n    }\n    //向有向图中添加一条边 v->w\n    public void addEdge(int v, int w) {\n        //由于有向图中边是有向的，v->w 边，只需要让w出现在v的邻接表中，而不需要让v出现在w的邻接表中\n        adj[v].enqueue(w);\n        //边的数目自增1\n        E++;\n    }\n    //获取由v指出的边所连接的所有顶点\n    public Queue<Integer> adj(int v){\n        return adj[v];\n    }\n    //该图的反向图\n    private Digraph reverse(){\n        //创建新的有向图对象\n        Digraph r = new Digraph(V);\n        //遍历0~V-1所有顶点,拿到每一个顶点v\n        for (int v=0;v<V;v++){\n            //得到原图中的v顶点对应的邻接表,原图中的边为 v->w,则反向图中边为w->v;\n            for (Integer w : adj(v)) {\n                r.addEdge(w,v);\n            }\n        }\n        return r;\n    }\n}\n```\n\n\n\n## 12.2 拓扑排序\n\n在现实生活中，我们经常会同一时间接到很多任务去完成，但是这些任务的完成是有先后次序的。以我们学习java 学科为例，我们需要学习很多知识，但是这些知识在学习的过程中是需要按照先后次序来完成的。从java基础，到jsp/servlet，到ssm，到springboot等是个循序渐进且有依赖的过程。在学习jsp前要首先掌握java基础和html基础，学习ssm框架前要掌握jsp/servlet之类才行。\n\n![image-20220715214305298](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715214305298.png)\n\n为了简化问题，我们使用整数为顶点编号的标准模型来表示这个案例：\n\n![image-20220715214327180](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715214327180.png)\n\n此时如果某个同学要学习这些课程，就需要指定出一个学习的方案，我们只需要对图中的顶点进行排序，让它转换 为一个线性序列，就可以解决问题，这时就需要用到一种叫**拓扑排序**的算法。\n\n**拓扑排序：**\n\n给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明 确的表示出每个顶点的优先级。下列是一副拓扑排序后的示意图：\n\n![image-20220715214349983](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715214349983.png)\n\n> 1、检测有向图中的环\n\n如果学习x课程前必须先学习y课程，学习y课程前必须先学习z课程，学习z课程前必须先学习x课程，那么一定是有 问题了，我们就没有办法学习了，因为这三个条件没有办法同时满足。其实这三门课程x、y、z的条件组成了一个环：\n\n![image-20220715214428355](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715214428355.png)\n\n因此，如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。\n\n> 2、检测有向环的API设计\n\n| **类名** | **DirectedCycle**                                            |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | DirectedCycle(Digraph  G)：创建一个检测环对象，检测图G中是否有环 |\n| 成员方法 | 1.private void dfs(Digraph G,int  v)：基于深度优先搜索，检测图G中是否有环 |\n|          | 2.public boolean  hasCycle():判断图中是否有环                |\n| 成员变量 | 1.  private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 |\n|          | 2. private boolean  hasCycle: 记录图中是否有环               |\n|          | 3.  private boolean[] onStack:索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上 |\n\n\n\n### 12.2.1 检测有向环实现\n\n> 1、检测有向环实现\n\n在API中添加了onStack[]  布尔数组，索引为图的顶点，当我们**深度搜索**时：\n\n1. 在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；\n\n2. 如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；\n\n3. 如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；\n\n![image-20220715214634641](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715214634641.png)\n\n![image-20220715214648783](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715214648783.png)\n\n> 2、代码\n\n```java\npublic class DirectedCycle {\n    //索引代表顶点，值表示当前顶点是否已经被搜索\n    private boolean[] marked;\n    //记录图中是否有环\n    private boolean hasCycle;\n    //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上\n    private boolean[] onStack;\n    //创建一个检测环对象，检测图G中是否有环\n    public DirectedCycle(Digraph G){\n        //创建一个和图的顶点数一样大小的marked数组\n        marked = new boolean[G.V()];\n        //创建一个和图的顶点数一样大小的onStack数组\n        onStack = new boolean[G.V()];\n        //默认没有环\n        this.hasCycle=false;\n        //遍历搜索图中的每一个顶点\n        for (int v = 0; v <G.V(); v++) {\n            //如果当前顶点没有搜索过，则搜索\n            if (!marked[v]){\n                dfs(G,v);\n            }\n        }\n    }\n    //基于深度优先搜索，检测图G中是否有环\n    private void dfs(Digraph G, int v){\n        //把当前顶点标记为已搜索\n        marked[v]=true;\n        //让当前顶点进栈\n        onStack[v]=true;\n        //遍历v顶点的邻接表，得到每一个顶点w\n        for (Integer w : G.adj(v)){\n            //如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点\n            if (!marked[w]){\n                dfs(G,w);\n            }\n            //如果顶点w已经被搜索过，则查看顶点w是否在栈中，如果在，则证明图中有环，修改hasCycle标记，结束循环\n            if (onStack[w]){\n                hasCycle=true;\n                return;\n            }\n        }\n        //当前顶点已经搜索完毕，让当前顶点出栈\n        onStack[v]=false;\n    }\n    //判断w顶点与s顶点是否相通\n    public boolean hasCycle(){\n        return hasCycle;\n    }\n}\n\n//测试代码\npublic class DirectedCycleTest {\n    public static void main(String[] args) throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new InputStreamReader(DirectedCycleTest.class.getClassLoader().getResourceAsStream(\"cycle_test.txt\")));\n        //读取顶点个数，初始化Graph图\n        int number = Integer.parseInt(reader.readLine());\n        Digraph G = new Digraph(number);\n        //读取边的个数\n        int roadNumber = Integer.parseInt(reader.readLine());\n        //读取边，并调用addEdge方法\n        for (int i = 0; i < roadNumber; i++) {\n            String line = reader.readLine();\n            int p = Integer.parseInt(line.split(\" \")[0]);\n            int q = Integer.parseInt(line.split(\" \")[1]);\n            G.addEdge(p, q);\n        }\n        //创建测试检测环对象\n        DirectedCycle cycle = new DirectedCycle(G);\n        //输出图中是否有环\n        System.out.println(cycle.hasCycle());\n    }\n}\n```\n\n\n\n### 12.2.2 基于深度优先的顶点排序\n\n> 1、基于深度优先的顶点排序\n\n如果要把图中的顶点生成线性序列其实是一件非常简单的事，之前我们学习并使用了多次深度优先搜索，我们会发 现其实深度优先搜索有一个特点，那就是在一个连通子图上，每个顶点只会被搜索一次，如果我们能在深度优先搜 索的基础上，添加一行代码，只需要将搜索的顶点放入到线性序列的数据结构中，我们就能完成这件事。\n\n> 2、顶点排序API设计\n\n| **类名** | **DepthFirstOrder**                                          |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | DepthFirstOrder(Digraph   G)：创建一个顶点排序对象，生成顶点线性序列； |\n| 成员方法 | 1.private void dfs(Digraph G,int v)：基于深度优先搜索，生成顶点线性序列 |\n|          | 2.public Stack  reversePost():获取顶点线性序列               |\n| 成员变量 | 1.  private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索 |\n|          | 2.  private Stack  reversePost: 使用栈，存储顶点序列         |\n\n> 3、顶点排序实现\n\n在API的设计中，我们添加了一个栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该 顶点放入到reversePost中，这样就可以实现顶点排序。\n\n![image-20220715215504581](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715215504581.png)\n\n![image-20220715215344603](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715215344603.png)\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715215527418.png\" alt=\"image-20220715215527418\" style=\"zoom:67%;\" />\n\n> 4、代码实现\n\n```java\npublic class DepthFirstOrder {\n    //索引代表顶点，值表示当前顶点是否已经被搜索\n    private boolean[] marked;\n    //使用栈，存储顶点序列\n    private Stack<Integer> reversePost;\n    //创建一个检测环对象，检测图G中是否有环\n    public DepthFirstOrder(Digraph G){\n        //创建一个和图的顶点数一样大小的marked数组\n        marked = new boolean[G.V()];\n        reversePost = new Stack<Integer>();\n        //遍历搜索图中的每一个顶点\n        for (int v = 0; v <G.V(); v++) {\n            //如果当前顶点没有搜索过，则搜索\n            if (!marked[v]){\n                dfs(G,v);\n            }\n        }\n    }\n    //基于深度优先搜索，检测图G中是否有环\n    private void dfs(Digraph G, int v){\n        //把当前顶点标记为已搜索\n        marked[v]=true;\n        //遍历v顶点的邻接表，得到每一个顶点w\n        for (Integer w : G.adj(v)){\n            //如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点\n            if (!marked[w]){\n                dfs(G,w);\n            }\n        }\n        //当前顶点已经搜索完毕，让当前顶点入栈\n        reversePost.push(v);\n    }\n    //获取顶点线性序列\n    public Stack<Integer> reversePost(){\n        return reversePost;\n    }\n}\n```\n\n\n\n### 12.2.3 拓扑排序实现\n\n前面已经实现了环的检测以及顶点排序，那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环， 则调用顶点排序即可。\n\n> 1、API设计\n\n| **类名** | **TopoLogical**                                |\n| -------- | ---------------------------------------------- |\n| 构造方法 | TopoLogical(Digraph G)：构造拓扑排序对象       |\n| 成员方法 | 1.public boolean  isCycle()：判断图G是否有环   |\n|          | 2.public Stack  order():获取拓扑排序的所有顶点 |\n| 成员变量 | 1.private  Stack order: 顶点的拓扑排序         |\n\n> 2、代码\n\n```java\npublic class TopoLogical {\n    //顶点的拓扑排序\n    private Stack<Integer> order;\n    //构造拓扑排序对象\n    public TopoLogical(Digraph G) {\n        //创建检测环对象，检测图G中是否有环\n        DirectedCycle dCycle = new DirectedCycle(G);\n        if (!dCycle.hasCycle()){\n            //如果没有环，创建顶点排序对象，进行顶点排序\n            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G);\n            order = depthFirstOrder.reversePost();\n        }\n    }\n    //判断图G是否有环\n    private boolean isCycle(){\n        return order==null;\n    }\n    //获取拓扑排序的所有顶点\n    public Stack<Integer> order(){\n        return order;\n    }\n}\n//测试代码\npublic class TopoLogicalTest {\n    public static void main(String[] args) throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new\n                InputStreamReader(TopoLogicalTest.class.getClassLoader().getResourceAsStream(\"topological_te\n                st.txt\")));\n        //读取顶点个数，初始化Graph图\n        int number = Integer.parseInt(reader.readLine());\n        Digraph G = new Digraph(number);\n        //读取边的个数\n        int roadNumber = Integer.parseInt(reader.readLine());\n        //读取边，并调用addEdge方法\n        for (int i = 0; i < roadNumber; i++) {\n            String line = reader.readLine();\n            int p = Integer.parseInt(line.split(\" \")[0]);\n            int q = Integer.parseInt(line.split(\" \")[1]);\n            G.addEdge(p, q);\n        }\n        //创建拓扑排序对象对象\n        TopoLogical topo = new TopoLogical(G);\n        Stack<Integer> order = topo.order();\n        //遍历打印\n        StringBuilder sb = new StringBuilder();\n        for (Integer v : order) {\n            sb.append(v+\"->\");\n        }\n        sb.deleteCharAt(sb.length()-1);\n        sb.deleteCharAt(sb.length()-1);\n        System.out.println(sb);\n    }\n}\n```\n\n\n\n## 12.3 加权无向图\n\n加权无向图是一种为每条边关联一个权重值或是成本的图模型。这种图能够自然地表示许多应用。在一副航空图   中，边表示航线，权值则可以表示距离或是费用。在一副电路图中，边表示导线，权值则可能表示导线的长度即成 本，或是信号通过这条先所需的时间。此时我们很容易就能想到，最小成本的问题，例如，从西安飞纽约，怎样飞 才能使时间成本最低或者是金钱成本最低？\n\n在下图中，从顶点0到顶点4有三条路径，分别为0-2-3-4,0-2-4,0-5-3-4,那我们如果要通过那条路径到达4顶点最好 呢？此时就要考虑，那条路径的成本最低。\n\n![image-20220715220110358](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715220110358.png)\n\n\n\n### 12.3.1 加权无向图边的表示\n\n加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用对象来描述一条边。\n\n> 1、API设计：\n\n| **类名** | **Edge implements Comparable**                               |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | Edge(int v,int  w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |\n| 成员方法 | 1.public double weight():获取边的权重值                      |\n|          | 2.public int either():获取边上的一个点                       |\n|          | 3. public int other(int vertex)):获取边上除了顶点vertex外的另外一个顶点 |\n|          | 4.  public int compareTo(Edge that)：比较当前边和参数that边的权重，如果当前边权重大，返回1，如果一样大，返回0，如果当前权重小，返回-1 |\n| 成员变量 | 1.private ﬁnal int v：顶点一                                 |\n|          | 2.private ﬁnal int w：顶点二                                 |\n|          | 3.private  ﬁnal double weight：当前边的权重                  |\n\n> 2、代码：\n\n```java\npublic class Edge implements Comparable<Edge> {\n    private final int v;//顶点一\n    private final int w;//顶点二\n    private final double weight;//当前边的权重\n    //通过顶点v和w，以及权重weight值构造一个边对象\n    public Edge(int v, int w, double weight) {\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n//获取边的权重值\npublic double weight(){\nreturn weight;\n}\n    //获取边上的一个点\n    public int either(){\n        return v;\n    }\n    //获取边上除了顶点vertex外的另外一个顶点\n    public int other(int vertex){\n        if (vertex==v){\n            //如果传入的顶点vertext是v，则返回另外一个顶点w\n            return w;\n        }else{\n            //如果传入的顶点vertext不是v，则返回v即可\n            return v;\n        }\n    }\n    @Override\n    public int compareTo(Edge that) {\n        int cmp;\n        if (this.weight()>that.weight()){\n            //如果当前边的权重大于参数边that的权重，返回1\n            cmp=1;\n        }else if(this.weight()<that.weight()){\n            //如果当前边的权重小于参数边that的权重，返回-1\n            cmp=-1;\n        }else{\n            //如果当前边的权重等于参数边that的权重，返回0\n            cmp=0;\n        }\n        return cmp;\n    }\n}\n```\n\n\n\n### 12.3.2 加权无向图的实现\n\n之前我们已经完成了无向图，在无向图的基础上，我们只需要把边的表示切换成Edge对象即可。\n\n> 1、API设计：\n\n| **类名** | **EdgeWeightedGraph**                                        |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | EdgeWeightedGraph(int  V)：创建一个含有V个顶点的空加权无向图 |\n| 成员方法 | 1.public int  V():获取图中顶点的数量                         |\n|          | 2.public int E():获取图中边的数量                            |\n|          | 3.public void addEdge(Edge e):向加权无向图中添加一条边e      |\n|          | 4.public Queue  adj(int v)：获取和顶点v关联的所有边          |\n|          | 5.public Queue  edges()：获取加权无向图的所有边              |\n| 成员变量 | 1.private  ﬁnal int V: 记录顶点数量                          |\n|          | 2.private int E: 记录边数量                                  |\n|          | 3.private Queue[] adj: 邻接表                                |\n\n> 2、代码：\n\n```java\npublic class EdgeWeightedGraph {\n    //顶点总数\n    private final int V;\n    //边的总数\n    private int E;\n    //邻接表\n    private Queue<Edge>[] adj;\n    //创建一个含有V个顶点的空加权无向图\n    public EdgeWeightedGraph(int V) {\n        //初始化顶点数量\n        this.V = V;\n        //初始化边的数量\n        this.E = 0;\n        //初始化邻接表\n        this.adj = new Queue[V];\n        //初始化邻接表中的空队列\n        for (int i = 0; i < adj.length; i++) {\n            adj[i] = new Queue<Edge>();\n        }\n    }\n    //获取图中顶点的数量\n    public int V() {\n        return V;\n    }\n    //获取图中边的数量\n    public int E() {\n        return E;\n    }\n    //向加权无向图中添加一条边e\n    public void addEdge(Edge e) {\n        //获取边中的一个顶点v\n        int v = e.either();\n        //获取边中的另一个顶点w\n        int w = e.other(v);\n        //因为是无向图，所以边e需要同时出现在两个顶点的邻接表中\n        adj[v].enqueue(e);\n        adj[w].enqueue(e);\n        //边的数量+1\n        E++;\n    }\n    //获取和顶点v关联的所有边\n    public Queue<Edge> adj(int v) {\n        return adj[v];\n    }\n    //获取加权无向图的所有边\n    public Queue<Edge> edges() {\n        //创建一个队列，存储所有的边\n        Queue<Edge> allEdge = new Queue<>();\n        //遍历顶点，拿到每个顶点的邻接表\n        for (int v = 0; v < this.V; v++) {\n            //遍历邻接表，拿到邻接表中的每条边\n            for (Edge e : adj(v)) {\n            /*\n            因为无向图中，每条边对象Edge都会在两个顶点的邻接表中各出现一次，为了不重复获取，暂定\n            一条规则：\n            除了当前顶点v，再获取边e中的另外一个顶点w，如果v<w则添加，这样可以保证同一条边\n            只会被统计一次\n            */\n                if (e.other(v) < v) {\n                    allEdge.enqueue(e);\n                }\n            }\n        }\n        return allEdge;\n    }\n}\n```\n\n\n\n## 12.4 最小生成树\n\n之前学习的加权图，我们发现它的边关联了一个权重，那么我们就可以根据这个权重解决最小成本问题，但如何才能找到最小成本对应的顶点和边呢？最小生成树相关算法可以解决。\n\n> 1、定义\n\n图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边 的权重之和)最小的生成树\n\n![image-20220715221234637](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221234637.png)\n\n> 2、约定：\n\n只考虑连通图。最小生成树的定义说明它只能存在于连通图中，如果图不是连通的，那么分别计算每个连通图子图 的最小生成树，合并到一起称为最小生成森林。\n\n![image-20220715221258937](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221258937.png)\n\n所有边的权重都各不相同。如果不同的边权重可以相同，那么一副图的最小生成树就可能不唯一了，虽然我们的算 法可以处理这种情况，但为了好理解，我们约定所有边的权重都各不相同。\n\n\n\n### 12.4.1 最小生成树原理\n\n> 1、树的性质\n\n1. 用一条边接树中的任意两个顶点都会产生一个新的环；\n\n![image-20220715221408502](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221408502.png)\n\n2. 从树中删除任意一条边，将会得到两棵独立的树；\n\n![image-20220715221428844](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221428844.png)\n\n> 2、切分定理\n\n要从一副连通图中找出该图的最小生成树，需要通过切分定理完成。\n\n**切分：**将图的所有顶点按照某些规则分为两个非空且没有交集的集合。\n\n**横切边：**连接两个属于不同集合的顶点的边称之为横切边。\n\n例如我们将图中的顶点切分为两个集合，灰色顶点属于一个集合，白色顶点属于另外一个集合，那么效果如下：\n\n![image-20220715221525977](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221525977.png)\n\n**切分定理：**在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树。\n\n![image-20220715221545823](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221545823.png)\n\n**注意**:一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。\n\n![image-20220715221606088](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221606088.png)\n\n\n\n### 12.4.2 贪心算法\n\n贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，**使用切分定理找到最小生成树的一条边，不断的重复直到找到最小生成树的所有边**。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221730625.png\" alt=\"image-20220715221730625\" style=\"zoom: 67%;\" />\n\n![image-20220715221838090](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221838090.png)\n\n![image-20220715221912897](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715221912897.png)\n\n计算图的最小生成树的算法有很多种，但这些算法都可以看做是贪心算法的一种特殊情况，这些算法的不同之处在 于保存切分和判定权重最小的横切边的方式。\n\n\n\n### 12.4.3  Prim算法\n\n我们学习第一种计算最小生成树的方法叫Prim算法，它的每一步都会为一棵生成中的树添加一条边。一开始这棵树 只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加  入到树中。\n\n**Prim算法的切分规则：**\n\n把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。\n\n![image-20220715222109654](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715222109654.png)\n\n> 1、Prim算法API设计\n\n| **类名** | **PrimMST**                                                  |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | PrimMST(EdgeWeightedGraph  G)：根据一副加权无向图，创建最小生成树计算对象； |\n| 成员方法 | 1.  private void visit(EdgeWeightedGraph G, int v)：将顶点v添加到最小生成树中，并且更新数据 |\n|          | 2. public Queue edges():获取最小生成树的所有边               |\n| 成员变量 | 1.private Edge[] edgeTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边 |\n|          | 2.private double[] distTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重 |\n|          | 3.private boolean[] marked:索引代表顶点，如果当前顶点已经在树中，则值为true，否则为  false |\n|          | 4.private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 |\n\n> 2、Prim算法的实现原理\n\nPrim算法始终将图中的顶点切分成两个集合，最小生成树顶点和非最小生成树顶点，通过不断的重复做某些操作，可以逐渐将非最小生成树中的顶点加入到最小生成树中，直到所有的顶点都加入到最小生成树中。\n\n我们在设计API的时候，使用最小索引优先队列存放树中顶点与非树中顶点的有效横切边，那么它是如何表示的呢？我们可以让最小索引优先队列的索引值表示图的顶点，让最小索引优先队列中的值表示从其他某个顶点到当前顶点的边权重。\n\n![image-20220715222345809](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715222345809.png)\n\n初始化状态，先默认0是最小生成树中的唯一顶点，其他的顶点都不在最小生成树中，此时横切边就是顶点0的邻接表中0-2,0-4,0-6,0-7这四条边，我们只需要将索引优先队列的2、4、6、7索引处分别存储这些边的权重值就可以表示了\n\n现在只需要从这四条横切边中找出权重最小的边，然后把对应的顶点加进来即可。所以找到0-7这条横切边的权重最小，因此把0-7这条边添加进来，此时0和7属于最小生成树的顶点，其他的不属于，现在顶点7的邻接表中的边也成为了横切边，这时需要做两个操作：\n\n1. 0-7这条边已经不是横切边了，需要让它失效：\n\n只需要调用最小索引优先队列的delMin()方法即可完成；\n\n2. 2和4顶点各有两条连接指向最小生成树，需要只保留一条：\n   1. 4-7的权重小于0-4的权重，所以保留4-7，调用索引优先队列的change(4,0.37)即可，\n   2. 0-2的权重小于2-7的权重，所以保留0-2，不需要做额外操作。\n\n![image-20220715222502827](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715222502827.png)\n\n我们不断重复上面的动作，就可以把所有的顶点添加到最小生成树中。\n\n> 3、代码\n\n```java\npackage cn.itcast;\npublic class PrimMST {\n    //索引代表顶点，值表示当前顶点和最小生成树之间的最短边\n    private Edge[] edgeTo;\n    //索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重\n    private double[] distTo;\n    //索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false\n    private boolean[] marked;\n    //存放树中顶点与非树中顶点之间的有效横切边\n    private IndexMinPriorityQueue<Double> pq;\n    //根据一副加权无向图，创建最小生成树计算对象\n    public PrimMST(EdgeWeightedGraph G) {\n        //创建一个和图的顶点数一样大小的Edge数组，表示边\n        this.edgeTo = new Edge[G.V()];\n        //创建一个和图的顶点数一样大小的double数组，表示权重，并且初始化数组中的内容为无穷大，无穷大即表示不存在这样的边\n        this.distTo = new double[G.V()];\n        for (int i = 0; i < distTo.length; i++) {\n            distTo[i] = Double.POSITIVE_INFINITY;\n        }\n        //创建一个和图的顶点数一样大小的boolean数组，表示当前顶点是否已经在树中\n        this.marked = new boolean[G.V()];\n        //创建一个和图的顶点数一样大小的索引优先队列，存储有效横切边\n        this.pq = new IndexMinPriorityQueue<>(G.V());\n        //默认让顶点0进入树中，但0顶点目前没有与树中其他的顶点相连接，因此初始化distTo[0]=0.0\n        distTo[0] = 0.0;\n        //使用顶点0和权重0初始化pq\n        pq.insert(0, 0.0);\n        //遍历有效边队列\n        while (!pq.isEmpty()) {\n            //找到权重最小的横切边对应的顶点，加入到最小生成树中\n            visit(G, pq.delMin());\n        }\n    }\n    //将顶点v添加到最小生成树中，并且更新数据\n    private void visit(EdgeWeightedGraph G, int v) {\n        //把顶点v添加到树中\n        marked[v] = true;\n        //遍历顶点v的邻接表,得到每一条边Edge e,\n        for (Edge e : G.adj(v)) {\n            //边e的一个顶点是v，找到另外一个顶点w；\n            int w = e.other(v);\n            //检测是否已经在树中，如果在，则继续下一次循环，如果不在，则需要修正当前顶点w距离最小生\n            成树的最小边edgeTo[w]以及它的权重distTo[w]，还有有效横切边也需要修正\n            if (marked[w]) {\n                continue;\n            }\n            //如果v-w边e的权重比目前distTo[w]权重小，则需要修正数据\n            if (e.weight() < distTo[w]) {\n                //把顶点w距离最小生成树的边修改为e\n                edgeTo[w] = e;\n                //把顶点w距离最小生成树的边的权重修改为e.weight()\n                distTo[w] = e.weight();\n                //如果pq中存储的有效横切边已经包含了w顶点，则需要修正最小索引优先队列w索引关联的权重值\n                if (pq.contains(w)) {\n                    pq.changeItem(w, e.weight());\n                } else {\n                    //如果pq中存储的有效横切边不包含w顶点，则需要向最小索引优先队列中添加v-w和其权重值\n                    pq.insert(w, e.weight());\n                }\n            }\n        }\n    }\n    //获取最小生成树的所有边\n    public Queue<Edge> edges() {\n        //创建队列\n        Queue<Edge> edges = new Queue<>();\n        //遍历edgeTo数组，找到每一条边，添加到队列中\n        for (int i = 0; i < marked.length; i++) {\n            if (edgeTo[i]!=null){\n                edges.enqueue(edgeTo[i]);\n            }\n        }\n        return edges;\n    }\n}\n//测试代码\npublic class PrimTest {\n    public static void main(String[] args) throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new\n                InputStreamReader(PrimTest.class.getClassLoader().getResourceAsStream(\"min_create_tree_test\n                        .txt\")));\n        //读取顶点数目，初始化EdgeWeightedGraph图\n        int number = Integer.parseInt(reader.readLine());\n        EdgeWeightedGraph G = new EdgeWeightedGraph(number);\n        //读取边的数目\n        int edgeNumber = Integer.parseInt(reader.readLine());\n        //循环读取每一条边，并调用addEdge方法\n        for (int i = 0; i < edgeNumber; i++) {\n            String line = reader.readLine();\n            int v = Integer.parseInt(line.split(\" \")[0]);\n            int w = Integer.parseInt(line.split(\" \")[1]);\n            double weight = Double.parseDouble(line.split(\" \")[2]);\n            G.addEdge(new Edge(v, w, weight));\n        }\n        //构建PrimMST对象\n        PrimMST mst = new PrimMST(G);\n        //获取最小生成树的边\n        Queue<Edge> edges = mst.edges();\n        //打印输出\n        for (Edge edge : edges) {\n            if (edge!=null){\n                System.out.println(edge.either() + \"-\" + edge.other(edge.either()) + \"::\" +\n                        edge.weight());\n            }\n        }\n    }\n}\n```\n\n\n\n## 12.5 kruskal算法\n\nkruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它 们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。\n\n> 1、kruskal算法和prim算法的区别：\n\nPrim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。kruskal算法构造最小生成树的时候也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林，kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。\n\n![image-20220715222904045](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715222904045.png)\n\n> 2、算法API设计\n\n| **类名** | **KruskalMST**                                               |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | KruskalMST(EdgeWeightedGraph  G)：根据一副加权无向图，创建最小生成树计算对象； |\n| 成员方法 | 1.public Queue edges():获取最小生成树的所有边                |\n| 成员变量 | 1.  private Queue mst：保存最小生成树的所有边                |\n|          | 2.  private UF_Tree_Weighted uf: 索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并 |\n|          | 3. private MinPriorityQueue pq: 存储图中所有的边，使用最小优先队列，对边按照权重进行排序 |\n\n> 3、kruskal算法的实现原理\n\n在设计API的时候，使用了一个MinPriorityQueue pq存储图中所有的边，每次使用pq.delMin()取出权重最小的边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶\n\n点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会 形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树   合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。\n\n![image-20220715223127927](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715223127927.png)\n\n![image-20220715223154795](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715223154795.png)\n\n![image-20220715223221328](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715223221328.png)\n\n> 4、代码\n\n```java\npublic class KruskalMST {\n    //保存最小生成树的所有边\n    private Queue<Edge> mst;\n    //索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并\n    private UF_Tree_Weighted uf;\n    //存储图中所有的边，使用最小优先队列，对边按照权重进行排序\n    private MinPriorityQueue<Edge> pq;\n    //根据一副加权无向图，创建最小生成树计算对象\n    public KruskalMST(EdgeWeightedGraph G) {\n        //初始化mst队列\n        this.mst = new Queue<Edge>();\n        //初始化并查集对象uf,容量和图的顶点数相同\n        this.uf = new UF_Tree_Weighted(G.V());\n        //初始化最小优先队列pq，容量比图的边的数量大1，并把图中所有的边放入pq中\n        this.pq = new MinPriorityQueue<>(G.E()+1);\n        for (Edge edge : G.edges()) {\n            pq.insert(edge);\n        }\n        //如果优先队列pq不为空，也就是还有边未处理，并且mst中的边还不到V-1条，继续遍历\n        while (!pq.isEmpty() && mst.size() < G.V() - 1) {\n            //取出pq中权重最小的边e\n            Edge e = pq.delMin();\n            //获取边e的两个顶点v和w\n            int v = e.either();\n            int w = e.other(v);\n/*\n通过uf.connect(v,w)判断v和w是否已经连通，\n如果连通:\n则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵\n树的任意两个顶点上添加一条边，都会形成环，\n而最小生成树不能有环的存在;\n如果不连通:\n则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树,并把这条边加入\n到mst队列中\n*/\n            if (uf.connected(v,w)){\n                continue;\n            }\n            uf.union(v,w);\n            mst.enqueue(e);\n        }\n    }\n    //获取最小生成树的所有边\n    public Queue<Edge> edges() {\n        return mst;\n    }\n}\n//测试代码\npublic class KruskalTest {\n    public static void main(String[] args) throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new\n                InputStreamReader(KruskalTest.class.getClassLoader().getResourceAsStream(\"min_create_tree_te\n                st.txt\")));\n        //读取顶点数目，初始化EdgeWeightedGraph图\n        int number = Integer.parseInt(reader.readLine());\n        EdgeWeightedGraph G = new EdgeWeightedGraph(number);\n        //读取边的数目\n        int edgeNumber = Integer.parseInt(reader.readLine());\n        //循环读取每一条边，并调用addEdge方法\n        for (int i = 0; i < edgeNumber; i++) {\n            String line = reader.readLine();\n            int v = Integer.parseInt(line.split(\" \")[0]);\n            int w = Integer.parseInt(line.split(\" \")[1]);\n            double weight = Double.parseDouble(line.split(\" \")[2]);\n            G.addEdge(new Edge(v, w, weight));\n        }\n        //构建PrimMST对象\n        KruskalMST mst = new KruskalMST(G);\n        //获取最小生成树的边\n        Queue<Edge> edges = mst.edges();\n        //打印输出\n        for (Edge edge : edges) {\n            if (edge!=null){\n                System.out.println(edge.either() + \"-\" + edge.other(edge.either()) + \"::\" +\n                        edge.weight());\n            }\n        }\n    }\n}\n```\n\n\n\n## 12.6 加权有向图\n\n之前学习的加权无向图中，边是没有方向的，并且同一条边会同时出现在该边的两个顶点的邻接表中，为了能够处 理含有方向性的图的问题，我们需要实现以下加权有向图。\n\n\n\n### 12.6.1 加权有向图边的表示\n\n> 1、API设计：\n\n| **类名** | **DirectedEdge**                                             |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | DirectedEdge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |\n| 成员方法 | 1.public double weight():获取边的权重值                      |\n|          | 2.public int from():获取有向边的起点                         |\n|          | 3.public int to():获取有向边的终点                           |\n| 成员变量 | 1.private ﬁnal  int v：起点                                  |\n|          | 2.private ﬁnal int w：终点                                   |\n|          | 3.private  ﬁnal double weight：当前边的权重                  |\n\n> 2、代码\n\n```java\npublic class DirectedEdge {\n    private final int v;//起点\n    private final int w;//终点\n    private final double weight;//当前边的权重\n    //通过顶点v和w，以及权重weight值构造一个边对象\n    public DirectedEdge(int v, int w, double weight) {\n        this.v = v;\n        this.w = w;\n        this.weight = weight;\n    }\n    //获取边的权重值\n    public double weight(){\n        return weight;\n    }\n    //获取有向边的起点\n    public int from(){\n        return v;\n    }\n    //获取有向边的终点\n    public int to(){\n        return w;\n    }\n}\n```\n\n\n\n### 12.6.2 加权有向图的实现\n\n之前我们已经完成了有向图，在有向图的基础上，我们只需要把边的表示切换成DirectedEdge对象即可。\n\n> 1、API设计：\n\n| **类名** | **EdgeWeightedDigraph**                                      |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | EdgeWeightedDigraph(int  V)：创建一个含有V个顶点的空加权有向图 |\n| 成员方法 | 1.public int  V():获取图中顶点的数量                         |\n|          | 2.public int E():获取图中边的数量                            |\n|          | 3.public void addEdge(DirectedEdge e):向加权有向图中添加一条边e |\n|          | 4.public Queue  adj(int v)：获取由顶点v指出的所有的边        |\n|          | 5.public Queue edges()：获取加权有向图的所有边               |\n| 成员变量 | 1.private  ﬁnal int V: 记录顶点数量                          |\n|          | 2.private int E: 记录边数量                                  |\n|          | 3.private Queue[] adj: 邻接表                                |\n\n> 2、代码：\n\n```java\npublic class EdgeWeightedDigraph {\n    //顶点总数\n    private final int V;\n    //边的总数\n    private int E;\n    //邻接表\n    private Queue<DirectedEdge>[] adj;\n    //创建一个含有V个顶点的空加权有向图\n    public EdgeWeightedDigraph(int V) {\n        //初始化顶点数量\n        this.V = V;\n        //初始化边的数量\n        this.E = 0;\n        //初始化邻接表\n        this.adj = new Queue[V];\n        //初始化邻接表中的空队列\n        for (int i = 0; i < adj.length; i++) {\n            adj[i] = new Queue<DirectedEdge>();\n        }\n    }\n    //获取图中顶点的数量\n    public int V() {\n        return V;\n    }\n    //获取图中边的数量\n    public int E() {\n        return E;\n    }\n    //向加权有向图中添加一条边e\n    public void addEdge(DirectedEdge e) {\n        //获取有向边的起点\n        int v = e.from();\n        //因为是有向图，所以边e只需要出现在起点v的邻接表中\n        adj[v].enqueue(e);\n        //边的数量+1\n        E++;\n    }\n    //获取由顶点v指出的所有的边\n    public Queue<DirectedEdge> adj(int v) {\n        return adj[v];\n    }\n    //获取加权有向图的所有边\n    public Queue<DirectedEdge> edges() {\n        //创建一个队列，存储所有的边\n        Queue<DirectedEdge> allEdge = new Queue<>();\n        //遍历顶点，拿到每个顶点的邻接表\n        for (int v = 0; v < this.V; v++) {\n            //遍历邻接表，拿到邻接表中的每条边存储到队列中\n            for (DirectedEdge e : adj(v)) {\n                allEdge.enqueue(e);\n            }\n        }\n        return allEdge;\n    }\n}\n```\n\n\n\n## 12.7 最短路径\n\n有了加权有向图之后，我们立刻就能联想到实际生活中的使用场景，例如在一副地图中，找到顶点a与地点b之间的`距离/时间/费用`路径，这条路径可以是距离最短，也可以是时间最短，也可以是费用最小等，如果我们把成本，那么就需要找到地点a和地点b之间成本最小的路径，也就是我们接下来要解决的最短路径问题。\n\n> 1、定义\n\n在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。\n\n![image-20220715224215165](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715224215165.png)\n\n> 2、性质\n\n1. 路径具有方向性；\n\n2. 权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低\n\n3. 只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径， 为了简化问题，这里只考虑连通图。\n\n4. 最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一 条即可。\n\n> 3、最短路径树：\n\n给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有 顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。\n\n> 4、最短路径树API设计\n\n计算最短路径树的经典算法是dijstra算法，为了实现它，先设计如下API：\n\n| **类名** | **DijkstraSP**                                               |\n| -------- | ------------------------------------------------------------ |\n| 构造方法 | public DijkstraSP(EdgeWeightedDigraph G, int s)：根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象 |\n| 成员方法 | 1.private void relax(EdgeWeightedDigraph G, int v)：松弛图G中的顶点v |\n|          | 2.public double  distTo(int v):获取从顶点s到顶点v的最短路径的总权重 |\n|          | 3.public boolean  hasPathTo(int v):判断从顶点s到顶点v是否可达 |\n|          | 4.public Queue pathTo(int v):查询从起点s到顶点v的最短路径中所有的边 |\n| 成员变量 | 1. private DirectedEdge[] edgeTo: 索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边 |\n|          | 2. private double[] distTo: 索引代表顶点，值从顶点s到当前顶点的最短路径的总权重 |\n|          | 3. private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 |\n\n\n\n### 12.7.1 松弛技术\n\n松弛这个词来源于生活：一条橡皮筋沿着两个顶点的某条路径紧紧展开，如果这两个顶点之间的路径不止一条，还有存在更短的路径，那么把皮筋转移到更短的路径上，皮筋就可以放松了。\n\n![image-20220715224456997](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715224456997.png)\n\n松弛这种简单的原理刚好可以用来计算最短路径树。\n\n在我们的API中，需要用到两个成员变量edgeTo和distTo，分别存储边和权重。一开始给定一幅图G和顶点s，我们 只知道图的边以及这些边的权重，其他的一无所知，此时初始化顶点s到顶点s的最短路径的总权重disto[s]=0；顶  点s到其他顶点的总权重默认为无穷大，随着算法的执行，不断的使用松弛技术处理图的边和顶点，并按一定的条 件更新edgeTo和distTo中的数据，最终就可以得到最短路劲树。\n\n> 1、边的松弛：\n\n放松边v->w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w？\n\n如果是，则v-w这条边需要加入到最短路径树中，更新edgeTo和distTo中的内容：edgeTo[w]=表示v->w这条边的\n\nDirectedEdge对象，distTo[w]=distTo[v]+v->w这条边的权重；\n\n如果不是，则忽略v->w这条边。\n\n![image-20220715224513859](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715224513859.png)\n\n> 2、顶点的松弛：\n\n顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶 点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。\n\n 如果把起点设置为顶点0，那么找出起点0到顶点6的最短路径0->2->7>3->6的过程如下:\n\n![image-20220715224559570](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/image-20220715224559570.png)\n\n\n\n### 12.7.2 Dijstra算法实现\n\nDisjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边是有效横切边pq队列中的权重最小的边。\n\n```java\npublic class DijkstraSP {\n    //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边\n    private DirectedEdge[] edgeTo;\n    //索引代表顶点，值从顶点s到当前顶点的最短路径的总权重\n    private double[] distTo;\n    //存放树中顶点与非树中顶点之间的有效横切边\n    private IndexMinPriorityQueue<Double> pq;\n    //根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象\n    public DijkstraSP(EdgeWeightedDigraph G, int s){\n        //创建一个和图的顶点数一样大小的DirectedEdge数组，表示边\n        this.edgeTo = new DirectedEdge[G.V()];\n        //创建一个和图的顶点数一样大小的double数组，表示权重，并且初始化数组中的内容为无穷大，无穷大即表示不存在这样的边\n        this.distTo = new double[G.V()];\n        for (int i = 0; i < distTo.length; i++) {\n            distTo[i] = Double.POSITIVE_INFINITY;\n        }\n        //创建一个和图的顶点数一样大小的索引优先队列，存储有效横切边\n        this.pq = new IndexMinPriorityQueue<>(G.V());\n        //默认让顶点s进入树中，但s顶点目前没有与树中其他的顶点相连接，因此初始化distTo[s]=0.0\n        distTo[s] = 0.0;\n        //使用顶点s和权重0.0初始化pq\n        pq.insert(s, 0.0);\n        //遍历有效边队列\n        while (!pq.isEmpty()) {\n            //松弛图G中的顶点\n            relax(G, pq.delMin());\n        }\n    }\n    //松弛图G中的顶点v\n    private void relax(EdgeWeightedDigraph G, int v){\n        //松弛顶点v就是松弛顶点v邻接表中的每一条边，遍历邻接表\n        for (DirectedEdge e : G.adj(v)) {\n            //获取边e的终点\n            int w = e.to();\n            //起点s到顶点w的权重是否大于起点s到顶点v的权重+边e的权重,如果大于，则修改s->w的路径：\n            edgeTo[w]=e,并修改distTo[v] = distTo[v]+e.weitht(),如果不大于，则忽略\n            if (distTo(w)>distTo(v)+e.weight()){\n                distTo[w]=distTo[v]+e.weight();\n                edgeTo[w]=e;\n                //如果顶点w已经存在于优先队列pq中，则重置顶点w的权重\n                if (pq.contains(w)){\n                    pq.changeItem(w,distTo(w));\n                }else{\n                    //如果顶点w没有出现在优先队列pq中，则把顶点w及其权重加入到pq中\n                    pq.insert(w,distTo(w));\n                }\n            }\n        }\n    }\n    //获取从顶点s到顶点v的最短路径的总权重\n    public double distTo(int v){\n        return distTo[v];\n    }\n    //判断从顶点s到顶点v是否可达\n    public boolean hasPathTo(int v){\n        return distTo[v]<Double.POSITIVE_INFINITY;\n    }\n    //查询从起点s到顶点v的最短路径中所有的边\n    public Queue<DirectedEdge> pathTo(int v){\n        //如果顶点s到v不可达，则返回null\n        if (!hasPathTo(v)){\n            return null;\n        }\n        //创建队列Queue保存最短路径的边\n        Queue<DirectedEdge> edges = new Queue<>();\n        //从顶点v开始，逆向寻找，一直找到顶点s为止，而起点s为最短路劲树的根结点，所以\n        edgeTo[s]=null;\n        DirectedEdge e=null;\n        while(true){\n            e = edgeTo[v];\n            if (e==null){\n                break;\n            }\n            edges.enqueue(e);\n            v = e.from();\n        }\n        return edges;\n    }\n}\n\n//测试代码\npublic class DijkstraSpTest {\n    public static void main(String[] args) throws Exception {\n        //创建输入流\n        BufferedReader reader = new BufferedReader(new\n                InputStreamReader(DijkstraSpTest.class.getClassLoader().getResourceAsStream(\"min_route_test\n                        .txt\")));\n        //读取顶点数目，初始化EdgeWeightedDigraph图\n        int number = Integer.parseInt(reader.readLine());\n        EdgeWeightedDigraph G = new EdgeWeightedDigraph(number);\n        //读取边的数目\n        int edgeNumber = Integer.parseInt(reader.readLine());\n        //循环读取每一条边，并调用addEdge方法\n        for (int i = 0; i < edgeNumber; i++) {\n            String line = reader.readLine();\n            int v = Integer.parseInt(line.split(\" \")[0]);\n            int w = Integer.parseInt(line.split(\" \")[1]);\n            double weight = Double.parseDouble(line.split(\" \")[2]);\n            G.addEdge(new DirectedEdge(v, w, weight));\n        }\n        //根据图G和顶点0，构建DijkstraSP对象\n        DijkstraSP dsp = new DijkstraSP(G, 0);\n        //获取起点0到顶点6的最短路径\n        Queue<DirectedEdge> edges = dsp.pathTo(6);\n        //打印输出\n        for (DirectedEdge edge : edges) {\n            System.out.println(edge.from() + \"->\" + edge.to() + \"::\" + edge.weight());\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n', '关于数据结构与算法的完整笔记', 2, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/db1fa9ae-1fa0-404a-9266-a5d020f9ab3e.png', '1', '0', 323, '0', 1, '2023-02-21 22:40:11', 1, '2023-02-21 22:40:11', 0);
INSERT INTO `sg_article` VALUES (13, '23种设计模式完整笔记', '# 23种设计模式\n\n> 记录流程方案\n\n1. 概述\n2. 举例\n3. 优缺点\n4. 适合的使用场景\n5. 现实案例\n\n设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 *Gang of Four* (*GoF*) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为**创建型模式**、**结构型模式**和**行为型模式**。\n\n**创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。**\n\n> OOP七大原则\n\n有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：\n\n1. **开闭原则：【最重要】**\n\n**对拓展开放，对修改关闭；**对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。\n\n2. **里氏替换原则**：\n\n继承必须确保超类所拥有的性质在子类中仍然成立。\n\n3. **依赖倒置原则**：\n\n**面向接口编程，而不是面向实现**。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。\n\n4. **单一职责原则**：\n\n每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。【将对象解耦，提高内聚性】\n\n5. **接口隔离原则**：\n\n要为各个类建立它们需要的专用接口。\n\n6. **迪米特法则**：\n\n只与你的直接朋友交谈，不跟“陌生人”说话。\n\n7. **合成复用原则**：\n\n尽量先试用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n\n\n\n## 1. 创建型模式\n\n创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。\n\n\n\n### 1.1 单例模式\n\n单例模式用得最多，错得最多。\n\n饿汉模式最简单：\n\n```java\npublic class Singleton {\n    // 首先，将 new Singleton() 堵死\n    private Singleton() {};\n    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建\n    private static Singleton instance = new Singleton();\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n    // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，\n    // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了\n    public static Date getDate(String mode) {return new Date();}\n}\n```\n\n> 很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。\n\n饱汉模式最容易出错：\n\n```java\npublic class Singleton {\n    // 首先，也是先堵死 new Singleton() 这条路\n    private Singleton() {}\n    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的\n    private static volatile Singleton instance = null;\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            // 加锁\n            synchronized (Singleton.class) {\n                // 这一次判断也是必须的，不然会有并发问题\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n> 双重检查，指的是两次检查 instance 是否为 null。\n>\n> volatile 在这里是需要的，希望能引起读者的关注。\n>\n> 很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。\n\n嵌套类最经典，以后大家就用它吧：\n\n```java\npublic class Singleton3 {\n\n    private Singleton3() {}\n    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性\n    private static class Holder {\n        private static Singleton3 instance = new Singleton3();\n    }\n    public static Singleton3 getInstance() {\n        return Holder.instance;\n    }\n}\n```\n\n> 注意，很多人都会把这个**嵌套类**说成是**静态内部类**，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。\n\n最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。\n\n虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。\n\n\n\n### 1.2 简单工厂模式\n\n* **目的：实现创建者和调用者的分离。**\n* **核心性质：实例化对象不使用new，用工厂方法代替**\n\n> 简介\n\n简单工厂模式：一又称为静态工厂方法（static Factory Method)模式，它属于类创建型模式。\n\n在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有**共同的父类**。\n\n![image-20230212165946719](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212165946719.png)\n\n和名字一样简单，非常简单，直接上代码吧：\n\n```java\npublic class FoodFactory {\n\n    public static Food makeFood(String name) {\n        if (name.equals(\"noodle\")) {\n            Food noodle = new LanZhouNoodle();\n            noodle.addSpicy(\"more\");\n            return noodle;\n        } else if (name.equals(\"chicken\")) {\n            Food chicken = new HuangMenChicken();\n            chicken.addCondiment(\"potato\");\n            return chicken;\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n*其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。*\n\n简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。\n\n我们强调**职责单一**原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。\n\n\n\n### 1.3 工厂模式\n\n> 概述\n\n简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。\n\n定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。\n\n![image-20230212170503809](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212170503809.png)\n\n如Collection   LinkedList ArrayList  ListItr  Itr\n\n```java\npublic interface FoodFactory {\n    Food makeFood(String name);\n}\npublic class ChineseFoodFactory implements FoodFactory {\n\n    @Override\n    public Food makeFood(String name) {\n        if (name.equals(\"A\")) {\n            return new ChineseFoodA();\n        } else if (name.equals(\"B\")) {\n            return new ChineseFoodB();\n        } else {\n            return null;\n        }\n    }\n}\npublic class AmericanFoodFactory implements FoodFactory {\n\n    @Override\n    public Food makeFood(String name) {\n        if (name.equals(\"A\")) {\n            return new AmericanFoodA();\n        } else if (name.equals(\"B\")) {\n            return new AmericanFoodB();\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。\n\n客户端调用：\n\n```java\npublic class APP {\n    public static void main(String[] args) {\n        // 先选择一个具体的工厂\n        FoodFactory factory = new ChineseFoodFactory();\n        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象\n        Food food = factory.makeFood(\"A\");\n    }\n}\n```\n\n虽然都是调用 makeFood(\"A\")  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。\n\n第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。\n\n**核心在于，我们需要在第一步选好我们需要的工厂**。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。\n\n虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：\n\n![(factory-1)](https://www.javadoop.com/blogimages/design-pattern/factory-1.png)\n\n\n\n### 1.4 抽象工厂模式\n\n又叫：组合工厂模式\n\n当涉及到**产品族**的时候，就需要引入抽象工厂模式了。\n\n![image-20230212171514892](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212171514892.png)\n\n一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。\n\n因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：\n\n![factory-1](https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png)\n\n这个时候的客户端调用是这样的：\n\n```java\n// 得到 Intel 的 CPU\nCPUFactory cpuFactory = new IntelCPUFactory();\nCPU cpu = intelCPUFactory.makeCPU();\n\n// 得到 AMD 的主板\nMainBoardFactory mainBoardFactory = new AmdMainBoardFactory();\nMainBoard mainBoard = mainBoardFactory.make();\n\n// 组装 CPU 和主板\nComputer computer = new Computer(cpu, mainBoard);\n```\n\n单独看 CPU 工厂和主板工厂，它们分别是前面我们说的**工厂模式**。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。\n\n但是，这种方式有一个问题，那就是如果 **Intel 家产的 CPU 和 AMD 产的主板不能兼容使用**，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。\n\n下面就是我们要说的**产品族**的概念，它代表了组成某个产品的一系列附件的集合：\n\n![abstract-factory-2](https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png)\n\n当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。\n\n![abstract-factory-3](https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png)\n\n这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。\n\n```java\npublic static void main(String[] args) {\n    // 第一步就要选定一个“大厂”\n    ComputerFactory cf = new AmdFactory();\n    // 从这个大厂造 CPU\n    CPU cpu = cf.makeCPU();\n    // 从这个大厂造主板\n    MainBoard board = cf.makeMainBoard();\n  	// 从这个大厂造硬盘\n  	HardDisk hardDisk = cf.makeHardDisk();\n  \n    // 将同一个厂子出来的 CPU、主板、硬盘组装在一起\n    Computer result = new Computer(cpu, board, hardDisk);\n}\n```\n\n当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了**对修改关闭，对扩展开放**这个设计原则。\n\n\n\n### 1.5 建造者模式\n\n> 概述\n\n经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：\n\n![image-20230212181536775](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212181536775.png)\n\n```java\nFood food = new FoodBuilder().a().b().c().build();\nFood food = Food.builder().a().b().c().build();\n```\n\n套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。\n\n来一个中规中矩的建造者模式：\n\n```java\nclass User {\n    // 下面是“一堆”的属性\n    private String name;\n    private String password;\n    private String nickName;\n    private int age;\n\n    // 构造方法私有化，不然客户端就会直接调用构造方法了\n    private User(String name, String password, String nickName, int age) {\n        this.name = name;\n        this.password = password;\n        this.nickName = nickName;\n        this.age = age;\n    }\n	// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，\n    // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好\n    public static UserBuilder builder() {\n        return new UserBuilder();\n    }\n   \n    public static class UserBuilder {\n        // 下面是和 User 一模一样的一堆属性\n        private String  name;\n        private String password;\n        private String nickName;\n        private int age;\n\n        private UserBuilder() {\n        }\n\n        // 链式调用设置各个属性值，返回 this，即 UserBuilder\n        public UserBuilder name(String name) {\n            this.name = name;\n            return this;\n        }\n\n        public UserBuilder password(String password) {\n            this.password = password;\n            return this;\n        }\n\n        public UserBuilder nickName(String nickName) {\n            this.nickName = nickName;\n            return this;\n        }\n\n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n\n        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。\n        // 当然，可以在 “复制” 之前做点检验\n        public User build() {\n            if (name == null || password == null) {\n                throw new RuntimeException(\"用户名和密码必填\");\n            }\n            if (age <= 0 || age >= 150) {\n                throw new RuntimeException(\"年龄不合法\");\n            }\n            // 还可以做赋予”默认值“的功能\n          	if (nickName == null) {\n                nickName = name;\n            }\n            return new User(name, password, nickName, age);\n        }\n    }\n}\n```\n\n核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性**复制**给实际产生的对象。\n\n看看客户端的调用：\n\n```java\npublic class APP {\n    public static void main(String[] args) {\n        User d = User.builder()\n                .name(\"foo\")\n                .password(\"pass12345\")\n                .age(25)\n                .build();\n    }\n}\n```\n\n说实话，建造者模式的**链式**写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 **Builder 的构造方法**中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。\n\n> 题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:\n\n```java\n@Builder\nclass User {\n    private String  name;\n    private String password;\n    private String nickName;\n    private int age;\n}\n```\n\n> 怎么样，省下来的时间是不是又可以干点别的了。\n\n当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 **return this** 就可以了，然后就可以像下面这样调用：\n\n```java\nUser user = new User().setName(\"\").setPassword(\"\").setAge(20);\n```\n\n> 很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。\n\n\n\n### 1.6 原型模式\n\n> (clone)\n\n这是我要说的创建型模式的最后一个设计模式了。\n\n原型模式很简单：有一个原型**实例**，基于这个原型实例产生新的实例，也就是“克隆”了。\n\nObject 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先**实现 Cloneable 接口**，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出CloneNotSupportedException 异常。\n\n```java\nprotected native Object clone() throws CloneNotSupportedException;\n```\n\njava 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。\n\n* 浅克隆\n\n![image-20230212184626855](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212184626855.png)\n\n* 深克隆\n\n![image-20230212184640045](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212184640045.png)\n\n原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。\n\n\n\n### 1.7 创建型模式总结\n\n创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是**面向对象**的代码，所以我们第一步当然是需要创建一个对象了。\n\n1. 简单工厂模式最简单；\n\n2. 工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；\n\n3. 抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。\n\n4. 单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；\n\n5. 建造者模式专门对付属性很多的那种类，为了让代码更优美；\n\n6. 原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。\n\n\n\n## 2. 结构型模式\n\n* 作用：旨在通过改变代码结构来达到**解耦**的目的，使得我们的代码容易维护和扩展。\n\n### 2.1 代理模式\n\n第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。\n\n既然说是**代理**，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。\n\n> 理解**代理**这个词，这个模式其实就简单了。\n\n```java\npublic interface FoodService {\n    Food makeChicken();\n    Food makeNoodle();\n}\n\npublic class FoodServiceImpl implements FoodService {\n    public Food makeChicken() {\n      	Food f = new Chicken()\n        f.setChicken(\"1kg\");\n      	f.setSpicy(\"1g\");\n      	f.setSalt(\"3g\");\n        return f;\n    }\n    public Food makeNoodle() {\n        Food f = new Noodle();\n        f.setNoodle(\"500g\");\n        f.setSalt(\"5g\");\n        return f;\n    }\n}\n\n// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService\npublic class FoodServiceProxy implements FoodService {\n  \n    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入\n    private FoodService foodService = new FoodServiceImpl();\n    \n    public Food makeChicken() {\n        System.out.println(\"我们马上要开始制作鸡肉了\");\n      \n        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，\n        // 代理只是在核心代码前后做些“无足轻重”的事情\n        Food food = foodService.makeChicken();\n      \n        System.out.println(\"鸡肉制作完成啦，加点胡椒粉\"); // 增强\n      	food.addCondiment(\"pepper\");\n      \n        return food;\n    }\n    public Food makeNoodle() {\n        System.out.println(\"准备制作拉面~\");\n        Food food = foodService.makeNoodle();\n        System.out.println(\"制作完成啦\")\n        return food;\n    }\n}\n```\n\n客户端调用，注意，我们要用代理来实例化接口：\n\n```java\n// 这里用代理类来实例化\nFoodService foodService = new FoodServiceProxy();\nfoodService.makeChicken();\n```\n\n![proxy](https://www.javadoop.com/blogimages/design-pattern/proxy-1.png)\n\n我们发现没有，代理模式说白了就是做 **“方法包装”** 或做 **“方法增强”**。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。\n\n说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。\n\n\n\n### 2.2 适配器模式\n\n说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。\n\n适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。\n\n![image-20230212190539982](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212190539982.png)\n\n适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。\n\n\n\n#### 2.2.1 默认适配器模式\n\n首先，我们先看看最简单的适配器模式**默认适配器模式(Default Adapter)**是怎么样的。\n\n我们用 Appache commons-io 包中的FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。\n\n```java\npublic interface FileAlterationListener {\n    void onStart(final FileAlterationObserver observer);\n    void onDirectoryCreate(final File directory);\n    void onDirectoryChange(final File directory);\n    void onDirectoryDelete(final File directory);\n    void onFileCreate(final File file);\n    void onFileChange(final File file);\n    void onFileDelete(final File file);\n    void onStop(final FileAlterationObserver observer);\n}\n```\n\n此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的**文件创建**和**文件删除**事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。\n\n所以，我们需要下面的一个**适配器**，它用于实现上面的接口，但是**所有的方法都是空方法**，这样，我们就可以转而定义自己的类来继承下面这个类即可。\n\n```java\npublic class FileAlterationListenerAdaptor implements FileAlterationListener {\n\n    public void onStart(final FileAlterationObserver observer) {\n    }\n\n    public void onDirectoryCreate(final File directory) {\n    }\n\n    public void onDirectoryChange(final File directory) {\n    }\n\n    public void onDirectoryDelete(final File directory) {\n    }\n\n    public void onFileCreate(final File file) {\n    }\n\n    public void onFileChange(final File file) {\n    }\n\n    public void onFileDelete(final File file) {\n    }\n\n    public void onStop(final FileAlterationObserver observer) {\n    }\n}\n```\n\n比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：\n\n```java\npublic class FileMonitor extends FileAlterationListenerAdaptor {\n    public void onFileCreate(final File file) {\n        // 文件创建\n        doSomething();\n    }\n\n    public void onFileDelete(final File file) {\n        // 文件删除\n        doSomething();\n    }\n}\n```\n\n> MVC中也有默认适配器模式\n\n当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍**“正统的”**适配器模式。\n\n\n\n#### 2.2.2 对象适配器模式\n\n> (构造传入类似对象)\n\n来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。\n\n```java\npublic interface Duck {\n    public void quack(); // 鸭的呱呱叫\n    public void fly(); // 飞\n}\n\npublic interface Cock {\n    public void gobble(); // 鸡的咕咕叫\n    public void fly(); // 飞\n}\n\npublic class WildCock implements Cock {\n    public void gobble() {\n        System.out.println(\"咕咕叫\");\n    }\n    public void fly() {\n        System.out.println(\"鸡也会飞哦\");\n    }\n}\n```\n\n鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：\n\n```java\n// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用\npublic class CockAdapter implements Duck {\n  \n    Cock cock;\n    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用\n  	public CockAdapter(Cock cock) {\n        this.cock = cock;\n    }\n  \n    // 实现鸭的呱呱叫方法\n    @Override\n  	public void quack() {\n        // 内部其实是一只鸡的咕咕叫\n        cock.gobble();\n    }\n  \n  	@Override\n  	public void fly() {\n        cock.fly();\n    }\n}\n```\n\n客户端调用很简单了：\n\n```java\npublic static void main(String[] args) {\n    // 有一只野鸡\n  	Cock wildCock = new WildCock();\n  	// 成功将野鸡适配成鸭\n  	Duck duck = new CockAdapter(wildCock);\n  	...\n}\n```\n\n到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。\n\n我们用一个图来简单说明下：\n\n![adapter-1](https://www.javadoop.com/blogimages/design-pattern/adapter-1.png)\n\n上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。\n\n\n\n#### 2.2.3 类适配器模式\n\n> (继承)\n\n废话少说，直接上图：\n\n![adapter-1](https://www.javadoop.com/blogimages/design-pattern/adapter-2.png)\n\n看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 `Target t = new SomeAdapter();` 就可以了。\n\n\n\n#### 2.2.4 适配器模式总结\n\n1. 类适配和对象适配的异同\n\n   一个采用继承，一个采用组合；\n\n   类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。\n\n   总体来说，对象适配用得比较多。\n\n2. 适配器模式和代理模式的异同\n\n   比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。\n\n   ![adapter-5](https://www.javadoop.com/blogimages/design-pattern/adapter-5.png)\n\n\n\n### 2.3 桥接模式\n\n> 概述\n\n理解桥梁模式，其实就是理解代码抽象和解耦。（继承改为关联关系）\n\n* UML概述图\n\n![image-20230212192121495](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212192121495.png)\n\n* 降维打击\n\n![image-20230212191203582](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/image-20230212191203582.png)\n\n我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。\n\n```java\npublic interface DrawAPI {\n   public void draw(int radius, int x, int y);\n}\n```\n\n然后是一系列实现类：\n\n```java\npublic class RedPen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用红色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\npublic class GreenPen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用绿色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\npublic class BluePen implements DrawAPI {\n    @Override\n    public void draw(int radius, int x, int y) {\n        System.out.println(\"用蓝色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n    }\n}\n```\n\n定义一个抽象类，此类的实现类都需要使用 DrawAPI：\n\n```java\npublic abstract class Shape {\n    protected DrawAPI drawAPI;\n    protected Shape(DrawAPI drawAPI) {//构造\n        this.drawAPI = drawAPI;\n    }\n    public abstract void draw();\n}\n```\n\n定义抽象类的子类：他可以注入笔\n\n```java\n// 圆形\npublic class Circle extends Shape {\n    private int radius;\n    public Circle(int radius, DrawAPI drawAPI) {\n        super(drawAPI);//调用父类的有参构造\n        this.radius = radius;\n    }\n    public void draw() {\n        drawAPI.draw(radius, 0, 0);\n    }\n}\n// 长方形\npublic class Rectangle extends Shape {\n    private int x;\n    private int y;\n    public Rectangle(int x, int y, DrawAPI drawAPI) {\n        super(drawAPI);\n        this.x = x;\n        this.y = y;\n    }\n    public void draw() {\n        drawAPI.draw(0, x, y);\n    }\n}\n```\n\n最后，我们来看客户端演示：\n\n```java\npublic static void main(String[] args) {\n    Shape greenCircle = new Circle(10, new GreenPen());\n    Shape redRectangle = new Rectangle(4, 8, new RedPen());\n    greenCircle.draw();\n    redRectangle.draw();\n}\n```\n\n可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：\n\n![bridge-1](https://www.javadoop.com/blogimages/design-pattern/bridge-1.png)\n\n这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。\n\n> 本节引用了[这里](https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm)的例子，并对其进行了修改。\n\n\n\n### 2.4 装饰模式\n\n> (实现同一接口，不断构造)\n\n要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 **Java IO** 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。\n\n首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：\n\n> 意思说说，他们都是实现了同一接口，但是每层都继承父类，然后包装父类对应的方法。举个例子：你也构造一个汽车，这个汽车多安了几排灯，最终的效果是开灯时不仅开启了原来的灯，也开启了你的灯。是不是跟代理有点类似？\n\n<img src=\"https://www.javadoop.com/blogimages/design-pattern/decorator-1.png\" alt=\"decorator-1\" style=\"zoom:50%;\" />\n\n我们来说说装饰模式的出发点，从图中可以看到，接口 `Component` 其实已经有了 `ConcreteComponentA` 和 `ConcreteComponentB` 两个实现类了，但是，如果我们要**增强**这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来**装饰**实现类，以达到增强的目的。\n\n> 从名字来简单解释下装饰器。既然说是装饰，那么往往就是**添加小功能**这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。\n\n首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 **ConcreteDecorator** 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent 的区别是，它们只是装饰者，起**装饰**作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中**加了层皮来装饰**而已。\n\n> 注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。\n\n下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。\n\n最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。\n\n在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea......但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？\n\n不说废话了，上代码。\n\n首先，定义饮料抽象基类：\n\n```java\npublic abstract class Beverage {//饮料\n  	// 返回描述\n  	public abstract String getDescription();\n  	// 返回价格\n  	public abstract double cost();\n}\n```\n\n然后是三个基础饮料实现类，红茶、绿茶和咖啡：\n\n```java\npublic class BlackTea extends Beverage {\n  	public String getDescription() {\n        return \"红茶\";\n    }\n  	public double cost() {\n        return 10;\n    }\n}\npublic class GreenTea extends Beverage {\n    public String getDescription() {\n        return \"绿茶\";\n    }\n  	public double cost() {\n        return 11;\n    }\n}\n...// 咖啡省略\n```\n\n定义调料，也就是装饰者的基类，此类必须继承自 Beverage：\n\n```java\n// 调料\npublic abstract class Condiment extends Beverage {\n    \n}\n```\n\n然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：\n\n```java\npublic class Lemon extends Condiment {\n    private Beverage bevarage;\n    // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，\n    // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶\n    public Lemon(Beverage bevarage) {\n        this.bevarage = bevarage;\n    }\n    public String getDescription() {\n        // 装饰\n        return bevarage.getDescription() + \", 加柠檬\";\n    }\n    public double cost() {\n        // 装饰\n        return beverage.cost() + 2; // 加柠檬需要 2 元\n    }\n}\n\npublic class Mango extends Condiment {\n    private Beverage bevarage;\n    public Mango(Beverage bevarage) {\n        this.bevarage = bevarage;\n    }\n    public String getDescription() {\n        return bevarage.getDescription() + \", 加芒果\";\n    }\n    public double cost() {\n        return beverage.cost() + 3; // 加芒果需要 3 元\n    }\n}\n...// 给每一种调料都加一个类\n```\n\n看客户端调用：\n\n```java\npublic static void main(String[] args) {\n    // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡\n    Beverage beverage = new GreenTea();\n    // 开始装饰\n    beverage = new Lemon(beverage); // 先加一份柠檬\n    beverage = new Mongo(beverage); // 再加一份芒果\n\n    System.out.println(beverage.getDescription() + \" 价格：￥\" + beverage.cost());\n    //\"绿茶, 加柠檬, 加芒果 价格：￥16\"\n}\n```\n\n如果我们需要 **芒果-珍珠-双份柠檬-红茶**：\n\n```java\nBeverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea()))));\n```\n\n是不是很变态？\n\n看看下图可能会清晰一些：\n\n![decorator-2](https://www.javadoop.com/blogimages/design-pattern/decorator-2.png)\n\n到这里，大家应该已经清楚装饰模式了吧。\n\n\n\n> 装饰模式应用：Stream\n\n下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：\n\n![decorator-3](https://www.javadoop.com/blogimages/design-pattern/decorator-3.png)\n\n我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。\n\nFilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，\n\n- 比如 BufferedInputStream 代表用缓冲来装饰，也就**使得输入流具有了缓冲的功能**，\n- LineNumberInputStream 代表用行号来装饰，在操作的时候就可以**取得行号**了，\n- DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的**基本类型值**。\n\n当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：\n\n```java\nInputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(\"\")));\n```\n\n这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。\n\n我们应该像下面这样使用：\n\n```java\nDataInputStream is = new DataInputStream(\n  							new BufferedInputStream(\n                              	new FileInputStream(\"\")));\n```\n\n> 所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。\n\n\n\n### 2.5 门面模式\n\n> (持有多个类似属性)\n\n门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。\n\n首先，我们定义一个接口：\n\n```java\npublic interface Shape {\n   void draw();\n}\n```\n\n定义几个实现类：\n\n```java\npublic class Circle implements Shape {\n    @Override\n    public void draw() {\n       System.out.println(\"Circle::draw()\");\n    }\n}\n\npublic class Rectangle implements Shape {\n    @Override\n    public void draw() {\n       System.out.println(\"Rectangle::draw()\");\n    }\n}\n```\n\n客户端调用：\n\n```java\npublic static void main(String[] args) {\n    // 画一个圆形\n  	Shape circle = new Circle();\n  	circle.draw();\n  \n  	// 画一个长方形\n  	Shape rectangle = new Rectangle();\n  	rectangle.draw();\n}\n```\n\n以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。\n\n下面，我们看看怎么用门面模式来让客户端调用更加友好一些。\n\n我们先定义一个门面：\n\n```java\npublic class ShapeMaker {\n   private Shape circle;\n   private Shape rectangle;\n   private Shape square;\n\n   public ShapeMaker() {\n      circle = new Circle();\n      rectangle = new Rectangle();\n      square = new Square();\n   }\n\n  /**\n   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定\n   */\n  \n   public void drawCircle(){\n      circle.draw();\n   }\n   public void drawRectangle(){\n      rectangle.draw();\n   }\n   public void drawSquare(){\n      square.draw();\n   }\n}\n```\n\n看看现在客户端怎么调用：\n\n```java\npublic static void main(String[] args) {\n  ShapeMaker shapeMaker = new ShapeMaker();\n\n  // 客户端调用现在更加清晰了\n  shapeMaker.drawCircle();\n  shapeMaker.drawRectangle();\n  shapeMaker.drawSquare();		\n}\n```\n\n门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。\n\n\n\n### 2.6 组合模式\n\n> (对象和list调用方法一致)\n\n> 桥接模式是传入对象，组合模式是list和对象调用方法一致\n\n组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。\n\n直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。\n\n```java\npublic class Employee {\n   private String name;\n   private String dept;\n   private int salary;\n   private List<Employee> subordinates; // 下属\n\n   public Employee(String name,String dept, int sal) {\n      this.name = name;\n      this.dept = dept;\n      this.salary = sal;\n      subordinates = new ArrayList<Employee>();\n   }\n\n   public void add(Employee e) {\n      subordinates.add(e);\n   }\n\n   public void remove(Employee e) {\n      subordinates.remove(e);\n   }\n\n   public List<Employee> getSubordinates(){\n     return subordinates;\n   }\n\n   public String toString(){\n      return (\"Employee :[ Name : \" + name + \", dept : \" + dept + \", salary :\" + salary+\" ]\");\n   }   \n}\n```\n\n通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。\n\n> 很多源码中如果出现xxxComposite的样式，就是组合模式\n\n\n\n### 2.7 享元模式\n\n> (map复用生成过的)\n\n英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。\n\n复用对象最简单的方式是，用一个 `HashMap `来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。\n\n这种简单的代码我就不演示了。\n\n\n\n### 2.8 结构型模式总结\n\n前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？\n\n1. 代理模式是做方法增强的\n2. 适配器模式是把鸡包装成鸭这种用来适配接口的\n3. 桥梁模式做到了很好的解耦\n4. 装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景\n5. 门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可\n6. 组合模式用于描述具有层次结构的数据\n7. 享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。\n\n\n\n## 3. 行为型模式\n\n行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。\n\n\n\n### 3.1 策略模式\n\n> (传入不同策略对象，但调用相同方法，线程池)\n\n策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。\n\n下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。\n\n> 洗衣机多种策略，线程池里的拒绝策略\n>\n> 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。\n\n首先，先定义一个策略接口：\n\n```java\npublic interface Strategy {\n   public void draw(int radius, int x, int y);\n}\n```\n\n然后我们定义具体的几个策略：\n\n```java\npublic class RedPen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用红色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\npublic class GreenPen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用绿色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\npublic class BluePen implements Strategy {\n   @Override\n   public void draw(int radius, int x, int y) {\n      System.out.println(\"用蓝色笔画图，radius:\" + radius + \", x:\" + x + \", y:\" + y);\n   }\n}\n```\n\n使用策略的类：\n\n```java\npublic class Context {\n   private Strategy strategy;\n\n   public Context(Strategy strategy){\n      this.strategy = strategy;\n   }\n\n   public int executeDraw(int radius, int x, int y){\n      return strategy.draw(radius, x, y);\n   }\n}\n```\n\n客户端演示：\n\n```java\npublic static void main(String[] args) {\n    Context context = new Context(new BluePen()); // 使用绿色笔来画\n  	context.executeDraw(10, 0, 0);\n}\n```\n\n放到一张图上，让大家看得清晰些：\n\n![strategy-1](https://www.javadoop.com/blogimages/design-pattern/strategy-1.png)\n\n这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：\n\n![bridge-1](https://www.javadoop.com/blogimages/design-pattern/bridge-1.png)\n\n要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。**桥梁模式的耦合更低**，结构更复杂一些。\n\n\n\n### 3.2 观察者模式\n\n> (注册观察者后通知)\n\n观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。\n\n首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：\n\n```java\npublic class Subject {\n    private List<Observer> observers = new ArrayList<Observer>();\n    private int state;\n    public int getState() {\n        return state;\n    }\n    public void setState(int state) {\n        this.state = state;\n        // 数据已变更，通知观察者们\n        notifyAllObservers();\n    }\n    // 注册观察者\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    // 通知观察者们\n    public void notifyAllObservers() {\n        for (Observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n```\n\n定义观察者接口：\n\n```java\npublic abstract class Observer {\n    protected Subject subject;\n    public abstract void update();\n}\n```\n\n其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。\n\n我们来定义具体的几个观察者类：\n\n```java\npublic class BinaryObserver extends Observer {\n    // 在构造方法中进行订阅主题\n    public BinaryObserver(Subject subject) {\n        this.subject = subject;\n        // 通常在构造方法中将 this 发布出去的操作一定要小心\n        this.subject.attach(this);\n    }\n    // 该方法由主题类在数据变更的时候进行调用\n    @Override\n    public void update() {\n        String result = Integer.toBinaryString(subject.getState());\n        System.out.println(\"订阅的数据发生变化，新的数据处理为二进制值为：\" + result);\n    }\n}\n\npublic class HexaObserver extends Observer {\n    public HexaObserver(Subject subject) {\n        this.subject = subject;\n        this.subject.attach(this);\n    }\n    @Override\n    public void update() {\n        String result = Integer.toHexString(subject.getState()).toUpperCase();\n        System.out.println(\"订阅的数据发生变化，新的数据处理为十六进制值为：\" + result);\n    }\n}\n```\n\n客户端使用也非常简单：\n\n```java\npublic static void main(String[] args) {\n    // 先定义一个主题\n    Subject subject1 = new Subject();\n    // 定义观察者\n    new BinaryObserver(subject1);\n    new HexaObserver(subject1);\n  \n    // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用\n    subject.setState(11);\n}\n```\n\noutput:\n\n```\n订阅的数据发生变化，新的数据处理为二进制值为：1011\n订阅的数据发生变化，新的数据处理为十六进制值为：B\n```\n\n当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。\n\n实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。\n\n还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。\n\n\n\n### 3.3 责任链模式\n\n> (靠next指针一直调用)\n\n责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。\n\n有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。\n\n> 如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？\n\n首先，我们要定义流程上节点的基类：\n\n```java\npublic abstract class RuleHandler {\n    // 后继节点 ，如果把这个类命名为next你就更能理解了\n    protected RuleHandler successor;\n  \n    public abstract void apply(Context context);\n  \n    public void setSuccessor(RuleHandler successor) {\n        this.successor = successor;\n    }\n  \n    public RuleHandler getSuccessor() {\n        return successor;\n    }\n}\n```\n\n接下来，我们需要定义具体的每个节点了。\n\n校验用户是否是新用户：\n\n```java\npublic class NewUserRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        if (context.isNewUser()) {\n            // 如果有后继节点的话，传递下去\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(context);\n            }\n        } else {\n            throw new RuntimeException(\"该活动仅限新用户参与\");\n        }\n    }\n}\n```\n\n校验用户所在地区是否可以参与：\n\n```java\npublic class LocationRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        boolean allowed = activityService.isSupportedLocation(context.getLocation);\n        if (allowed) {\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(context);\n            }\n        } else {\n            throw new RuntimeException(\"非常抱歉，您所在的地区无法参与本次活动\");\n        }\n    }\n}\n```\n\n校验奖品是否已领完：\n\n```java\npublic class LimitRuleHandler extends RuleHandler {\n    public void apply(Context context) {\n        int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品\n        if (remainedTimes > 0) {\n            if (this.getSuccessor() != null) {\n                this.getSuccessor().apply(userInfo);\n            }\n        } else {\n            throw new RuntimeException(\"您来得太晚了，奖品被领完了\");\n        }\n    }\n}\n```\n\n客户端：\n\n```java\npublic static void main(String[] args) {\n    RuleHandler newUserHandler = new NewUserRuleHandler();\n    RuleHandler locationHandler = new LocationRuleHandler();\n    RuleHandler limitHandler = new LimitRuleHandler();\n  \n    // 假设本次活动仅校验地区和奖品数量，不校验新老用户\n    locationHandler.setSuccessor(limitHandler);\n  \n    locationHandler.apply(context);\n}\n```\n\n代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。\n\n至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。\n\n\n\n### 3.4 模板方法模式\n\n> (回调)\n\n在含有继承结构的代码中，模板方法模式是非常常用的。\n\n通常会有一个抽象类：\n\n```java\npublic abstract class AbstractTemplate {\n    // 这就是模板方法\n    public void templateMethod() {\n        init();\n        apply(); // 这个是重点\n        end(); // 可以作为钩子方法\n    }\n\n    protected void init() {\n        System.out.println(\"init 抽象层已经实现，子类也可以选择覆写\");\n    }\n\n    // 留给子类实现\n    protected abstract void apply();\n\n    protected void end() {\n    }\n}\n```\n\n模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。\n\n我们写一个实现类：\n\n```java\npublic class ConcreteTemplate extends AbstractTemplate {\n    public void apply() {\n        System.out.println(\"子类实现抽象方法 apply\");\n    }\n\n    public void end() {\n        System.out.println(\"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了\");\n    }\n}\n```\n\n客户端调用演示：\n\n```java\npublic static void main(String[] args) {\n    AbstractTemplate t = new ConcreteTemplate();\n    // 调用模板方法\n    t.templateMethod();\n}\n```\n\n代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。\n\n> 如果在源码中看到了final修饰符，而该方法中调用了其他源码，很可能就是模板方法模式\n\n\n\n### 3.5 状态模式\n\nupdate: 2017-10-19\n\n废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。\n\n核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。\n\n定义状态接口：\n\n```java\npublic interface State {\n    public void doAction(Context context);\n}\n```\n\n定义减库存的状态：\n\n```java\npublic class DeductState implements State {\n\n    public void doAction(Context context) {\n        System.out.println(\"商品卖出，准备减库存\");\n        context.setState(this);\n\n        //... 执行减库存的具体操作\n    }\n\n    public String toString() {\n        return \"Deduct State\";\n    }\n} \n```\n\n定义补库存状态：\n\n```java\npublic class RevertState implements State {\n  \n    public void doAction(Context context) {\n        System.out.println(\"给此商品补库存\");\n        context.setState(this);\n\n        //... 执行加库存的具体操作\n    }\n\n    public String toString() {\n        return \"Revert State\";\n    }\n}\n```\n\n前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：\n\n```java\npublic class Context {\n    private State state;\n  	private String name;\n  	public Context(String name) {\n        this.name = name;\n    }\n    \n  	public void setState(State state) {\n        this.state = state;\n    }\n  	public void getState() {\n        return this.state;\n    }\n}\n```\n\n我们来看下客户端调用，大家就一清二楚了：\n\n```java\npublic static void main(String[] args) {\n    // 我们需要操作的是 iPhone X\n    Context context = new Context(\"iPhone X\");\n  	\n    // 看看怎么进行补库存操作\n  	State revertState = new RevertState();\n  	revertState.doAction(context);\n  \n    // 同样的，减库存操作也非常简单\n  	State deductState = new DeductState();\n  	deductState.doAction(context);\n  \n  	// 如果需要我们可以获取当前的状态\n    // context.getState().toString();\n}\n```\n\n读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。\n\n不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。\n\n\n\n### 3.6 访问者模式\n\n> 精髓：传入一个对象，在我们这里调用该对象的方法，而该方法会把this指针传进去\n\n传入访问者，遍历元素调用\n\n```java\n/**\n * 具体元素类, 用于访问者访问\n **/\npublic class ElementA implements IElement {\n\n    private String name;\n\n    public ElementA(String name) {  this.name = name;  }\n\n    /** 接受访问者访问自己  */\n    @Override\n    public void accept(IVisitor visitor) {\n        visitor.viewElementA(this);\n    }\n\n    @Override\n    public String getName() {   return name; }\n}\n```\n\n```java\n/* 具体访问者类, 用于访问元素 **/\npublic class VisitorA implements  IVisitor{\n\n    @Override\n    public void viewElementA(ElementA elementA) {\n        System.out.println(\"A访问者 访问 A元素: \" + elementA.getName());\n    }\n\n    @Override\n    public void viewElementB(ElementB elementB) {\n        System.out.println(\"A访问者 访问 B元素: \" + elementB.getName());\n    }\n}\n```\n\n```java\npublic class ElementStructure {\n\n    List<IElement> listElement = new ArrayList<>(10);\n\n    public void addElement(IElement element) {\n        lstElement.add(element);\n    }\n\n    public void show(IVisitor visitor) {// 传入访问者\n        for (IElement element : listElement) {\n            element.accept(visitor);//visitor.viewElementA(this);\n        }\n    }\n}\n```\n\n\n\n### 3.7 行为型模式总结\n\n行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。\n\n\n\n## 4.记忆方式\n\n 第1章 代码无错就是优？——简单工厂模式\n\n 第2章 商场促销——策略模式\n\n 第3章 拍摄UFO——单一职责原则\n\n 第4章 考研求职两不误——开放-封闭原则\n\n 第5章 会修电脑不会修收音机？——依赖倒转原则\n\n 第6章 穿什么有这么重要？——装饰模式\n\n 第7章 为别人做嫁衣——代理模式\n\n 第8章 雷锋依然在人间——工厂方法模式\n\n 第9章 简历复印——原型模式\n\n 第10章 考题抄错会做也白搭——模板方法模式\n\n 第11章 无熟人难办事？——迪米特法则\n\n 第12章 牛市股票还会亏钱？——外观模式\n\n 第13章 好菜每回味不同——建造者模式\n\n 第14章 老板回来，我不知道——观察者模式\n\n 第15章 就不能不换DB吗？——抽象工厂模式\n\n 第16章 无尽加班何时休——状态模式\n\n 第17章 在NBA我需要翻译——适配器模式\n\n 第18章 如果再回到从前——备忘录模式\n\n 第19章 分公司=一部门——组合模式\n\n 第20章 想走？可以！先买票——迭代器模式\n\n 第21章 有些类也需计划生育——单例模式\n\n 第22章 手机软件何时统一——桥接模式\n\n 第23章 烤羊肉串引来的思考——命令模式\n\n 第24章 加薪非要老总批？——职责链模式\n\n 第25章 世界需要和平——中介者模式\n\n 第26章 项目多也别傻做——享元模式\n\n 第27章 其实你不懂老板的心——解释器模式\n\n 第28章 男人和女人——访问者模式\n\n 第29章 OOTV杯超级模式大赛——模式总结', '关于23种设计模式的完整笔记', 3, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/27706cad-88ef-465e-8bbf-d609e1e7ac8e.jpg', '1', '0', 354, '0', 1, '2023-02-21 22:41:18', 1, '2023-02-21 22:41:18', 0);
INSERT INTO `sg_article` VALUES (14, 'Spring完整笔记', '# Spring\n\n## 目录\n\n[toc]\n\n> 学习大纲（容器思想）\n\n![image-20220125092207196](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220125092207196.png)\n\n\n\n## 1. Spring简介\n\n### 1.1 Spring背景\n\n- Spring：春天 给软件行业带来了春天\n- 2002，首次推出了Spring框架的雏形：interface21框架\n- Spring框架即是以interface21框架为基础经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版\n- Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！\n- SSH :Struct2 + Spring + Hibernate\n- SSM：SpringMVC + Spring +Mybatis\n\n> 学习必备网站\n\n- 官网：https://spring.io/\n\n- 官方下载地址：http://repo.spring.io/release/org/springframework/spring\n- GitHub：https://github.com/spring-projects/spring-framework\n- Spring核心技术地址：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config\n\n\n\n### 1.2 Spring优点\n\n- Spring是一个开源的免费的框架（容器）！\n- Spring是一个轻量级的，非入侵式的框架\n\n- 控制反转（IOC），面向切面编程（AOP）\n- 支持事务的处理，对框架整合的支持！\n\n==**Spring就是一个轻量级的控制反转（IOC）和切面编程（AOP）的框架！**==\n\n\n\n### 1.3 Spring组成\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20201223175525840.png)\n\n==现代化的java开发，就是基于Spring开发！==\n\n![image-20220129143821151](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220129143821151.png)\n\n* Spring Boot\n  * 一个快速开发的脚手架\n  * 基于SpringBoot可以快速的开发单个微服务\n  * 约定大于配置！\n* Spring Cloud\n  * SpringCloud是基于SpringBoot实现的\n\n> 学习SpringBoot前提\n\n因为大部分公司都用SpringBoot进行快速开发，学习SpringBoot之前要先学会Spring和SpringMVC！\n\n> Spring弊端\n\n**Spring弊端：发展太久后，违背了“简化开发”的理念！配置十分繁琐，人称“配置地狱”！**\n\n> Spring的maven配置\n\n~~~xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.3.15</version>\n</dependency>\n~~~\n\n\n\n## 2. IOC控制反转(*)\n\n### 2.1 IOC组成理论推导\n\n> 1、原来的实现方式\n\n1.UserDao接口\n\n~~~java\npublic interface UserDao {\n    void getUser();\n}\n~~~\n\n2.UserDaoImpl实现类\n\n~~~java\npublic class UserDaoImpl implements UserDao{\n    public void getUser() {\n        System.out.println(\"默认获取用户的数据\");\n    }\n}\n~~~\n\n3.UserService业务接口\n\n~~~java\npublic interface UserService {\n    void getUser();\n}\n~~~\n\n4.UserServiceImpl实现类\n\n~~~java\npublic class UserServiceImpl implements UserService{\n\n    private UserDao userDao = new UserDaoImpl();\n\n    public void getUser() {\n        userDao.getUser();\n    }\n}\n~~~\n\n问题：如果想要改变，就需要每次更改UserDao\n\n> 2、解决方法\n\n​	**若将UserDao使用Set接口实现**\n\n~~~java\npublic class UserServiceImpl implements UserService{\n\n    private UserDao userDao;\n    //利用set进行动态实现值得注入\n    public void setUserDao(UserDao userDao) {\n		this.userDao = userDao;\n	}\n\n    public void getUser() {\n        userDao.getUser();\n    }\n}\n~~~\n\n> 3、思想图解\n\n![image-20220129152145177](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220129152145177.png)\n\n- 之前，程序通过new主动创建对象！控制权在程序猿手上\n- 使用set注入后，程序不再具有主动性，而是变成了被动的接受对象！\n- 这种思想，从本质上解决了问题，程序员不用再去管理对象的创建了，降低了耦合性！\n\n\n\n### 2.2 IOC本质\n\n**控制反转IOC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IOC的一种方法**， 也有人认为DI只是IOC的另一种说法。没有IOC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓的控制反转就是：获得依赖的方式反转了。\n\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。\n\n**控制反转是一种通过描述（xml或注解）并通过第三方去生产或获取特定对象的方式。在spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection，DI）**\n\n![image-20220129152350741](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220129152350741.png)\n\n\n\n### 2.3 HelloSpring\n\n> 1、beans.xml层\n\n![image-20220208143102277](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220208143102277.png)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--使用Spring来创建对象，在Spring这些都称为Bean-->\n    <bean id=\"hello\" class=\"com.koko.util.Hello\">\n        <property name=\"name\" value=\"spring\"/>\n    </bean>\n\n</beans>\n```\n\n> 2、实体类层\n\n![image-20220208143137360](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220208143137360.png)\n\n```java\npackage com.koko.util;\n\npublic class Hello {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Hello{\" +\n                \"name=\'\" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n```\n\n> 3、测试\n\n```java\n@Test\npublic void test01(){\n    //获取spring的上下文对象\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n\n    //我们的对象现在都在spring中管理，我们要使用，直接去里面取出来\n    Hello hello = (Hello) context.getBean(\"hello\");\n    System.out.println(hello.toString());\n\n}\n```\n\n![image-20220208143215406](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220208143215406.png)\n\n**会发现，已经不需要手动new对象，对象是在xml文件中配置。或者通俗来讲，不需要改底层代码，而xml文件不算底层代码。**\n\n\n\n> **概念：控制反转**\n\n- **控制：** 谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的\n- **反转:** 程序本身不创建对象，而变成被动的接收对象。\n- **依赖注入：** 就是利用set方法来进行注入的\n- **IOC是一种编程思想，由主动的编程变为被动的接收，所谓的IOC，即对象由Spring来创建，管理，装配**\n\n\n\n> 小技巧\n\n**【ctrl+alt+u】查询继承与接口的关系**\n\n![image-20220208142824392](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220208142824392.png)\n\n\n\n### 2.4 IOC创建对象的方式\n\n1. 默认使用无参构造创建对象\n2. 使用有参构造创建对象的三种方式\n\n> a.下标赋值 Constructor argument index\n\n```xml\n<bean id=\"user\" class=\"com.yang.entity.User\">\n    <constructor-arg index=\"0\" value=\"张三\"/>\n    <constructor-arg index=\"1\" value=\"18\"/>\n</bean>\n```\n\n> b.变量类型赋值 Constructor argument type matching\n\n```xml\n<bean id=\"user1\" class=\"com.yang.entity.User\">\n    <constructor-arg type=\"int\" value=\"18\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"张三\"/>\n</bean>\n```\n\n> **c.变量名称赋值 Constructor argument name**\n\n```xml\n<bean id=\"user2\" class=\"com.yang.entity.User\">\n    <constructor-arg name=\"name\" value=\"张三\"/>\n    <constructor-arg name=\"age\" value=\"18\"/>\n</bean>\n```\n\n==在获取spring的上下文对象（ new ClassPathXmlApplicationContext(“beans.xml”); ）时，spring容器中的所有的对象就已经被创建了。[单例模式]==\n\n\n\n## 3. Spring的基础配置\n\n### 3.1 别名alias\n\n~~~xml\n<!--如果添加了别名，通过别名也可以获取对象-->\n<alias name=\"user\" alias=\"userAlias\"/>\n~~~\n\n注：可以给别名起别名，只能一对一修改别名，无意义\n\n\n\n### 3.2 Bean的配置\n\n~~~xml\n<!--\n        id: bean的唯一标识符，也就是相当于我们学的对象名\n        class： bean对象的全限定名：包名 + 类型\n        name： 也是别名 而且name可以同时设置多个别名，可以用逗号 空格 分号隔开\n    -->\n<bean id=\"user1\" class=\"com.yang.entity.User\" name=\"test test1, test2; test3\"> \n    <constructor-arg type=\"int\" value=\"18\"/>\n    <constructor-arg type=\"java.lang.String\" value=\"张三\"/>\n</bean>\n~~~\n\n\n\n### 3.3 import\n\n**import，一般用于团队开发使用，他可以将多个配置文件，导入合并为1个**\n		假设，现在项目中又多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以用import将所有人的beans.xml合并为一个总的！\n\n- appliacationContext1.xml\n- appliacationContext2.xml\n- appliacationContext3.xml\n- 合并\n\n~~~xml\n<import resource=\"applicationContext1.xml\"/>\n<import resource=\"applicationContext2.xml\"/>\n<import resource=\"applicationContext3.xml\"/>\n~~~\n\n\n\n## 4. DI依赖注入（*）\n\n### 4.1 构造器注入\n\n### 4.2 set方式注入 【重点】\n\n> **依赖注入**\n\n依赖：bean对象的创建依赖于容器\n		注入：bean对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n> 1.复杂类型\n\n~~~java\npackage com.koko.pojo;\n\npublic class Address {\n\n    private String address;\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n    @Override\n    public String toString() {\n        return \"Address{\" +\n                \"address=\'\" + address + \'\\\'\' +\n                \'}\';\n    }\n}\n~~~\n\n> 2.真实测试对象\n\n~~~java\npackage com.koko.pojo;\n\nimport java.util.*;\n\npublic class Student {\n\n    private String name;\n    private Address address;\n    private String [] books;\n    private List<String> hobbies;\n    private Map<String, String> card;\n    private Set<String> games;\n    private String wife;\n    private Properties info;\n\n    //以及Getter与Setter方法,toString方法\n}\n~~~\n\n> 3.applicationContext.xml\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"address\" class=\"com.koko.pojo.Address\">\n        <property name=\"address\" value=\"Dalian\"/>\n    </bean>\n\n    <!--第一种 普通注入 value-->\n    <bean id=\"student\" class=\"com.koko.pojo.Student\">\n        <property name=\"name\" value=\"yang\"/>\n        <!--第二种 Bean注入， ref-->\n        <property name=\"address\" ref=\"address\"/>\n\n        <!--数组-->\n        <property name=\"books\">\n            <array>\n                <value>红楼梦</value>\n                <value>三国演义</value>\n                <value>水浒传</value>\n                <value>西游记</value>\n            </array>\n        </property>\n\n        <!--List-->\n        <property name=\"hobbies\">\n            <list>\n                <value>抽烟</value>\n                <value>喝酒</value>\n                <value>烫头</value>\n            </list>\n        </property>\n\n        <!--Map-->\n        <property name=\"card\">\n            <map>\n                <entry key=\"身份证\" value=\"220.......\"/>\n                <entry key=\"银行卡\" value=\"626.......\"/>\n            </map>\n        </property>\n\n        <!--Set-->\n        <property name=\"games\">\n            <set>\n                <value>LOL</value>\n                <value>COC</value>\n                <value>BOB</value>\n            </set>\n        </property>\n\n        <!--null-->\n        <property name=\"wife\">\n            <null/>\n        </property>\n\n        <!--Properties-->\n        <property name=\"info\">\n            <props>\n                <prop key=\"driver\">驱动</prop>\n                <prop key=\"name\">root</prop>\n                <prop key=\"password\">123456</prop>\n            </props>\n        </property>\n    </bean>\n</beans>\n~~~\n\n>4.测试类\n\n```java\n@Test\npublic void test01(){\n    ApplicationContext contest = new ClassPathXmlApplicationContext(\"applicationContest.xml\");\n\n    Student student = (Student) contest.getBean(\"student\");\n    System.out.println(student.toString());\n}\n```\n\n~~~java\n        /*\n        * Student{\n        * name=\'yang\',\n        * address=Address{address=\'Dalian\'},\n        * books=[红楼梦, 三国演义, 水浒传, 西游记],\n        * hobbies=[抽烟, 喝酒, 烫头],\n        * card={身份证=220......., 银行卡=626.......},\n        * games=[LOL, COC, BOB],\n        * wife=\'null\',\n        * info={password=123456, name=root, driver=驱动}}\n        * */\n~~~\n\n\n\n### 4.3 pc标签注入\n\n> 1、官方文档\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210110191424534.png)\n\n**1、p标签注入，须在beans中引入**\n\n**xmlns:p=\"http://www.springframework.org/schema/p\"**\n\n**2、c标签注入，需在实体中增加有参构造方法**\n\n**并引入 xmlns:c=\"http://www.springframework.org/schema/c\"**\n\n> 2、beans.xml配置\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:c=\"http://www.springframework.org/schema/c\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--p命名空间注入，可以直接注入属性的值：property-->\n    <bean id=\"p_test\" class=\"com.koko.pojo.User\" p:name=\"koko\" p:age=\"18\"/>\n\n    <!--c命名空间注入，通过构造器注入：construct-args-->\n    <bean id=\"c_test\" class=\"com.koko.pojo.User\" c:name=\"koko\" c:age=\"18\"/>\n\n</beans>\n~~~\n\n> 3、测试：\n\n~~~java\n@Test\npublic void test01(){\nApplicationContext contest = new ClassPathXmlApplicationContext(\"applicationContest.xml\");\n\nUser user =contest.getBean(\"p_test\",User.class);\nSystem.out.println(user);\n}\n~~~\n\n> 4、注意\n\np命名和c命名空间不能直接使用，要导入xml约束！\n\n~~~properties\nxmlns:p=\"http://www.springframework.org/schema/p\"\nxmlns:c=\"http://www.springframework.org/schema/c\"\n~~~\n\n\n\n### 4.4 Bean的作用域\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210110191656330.png)\n\n> **1.单例模式（Spring默认机制）**\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210110192236774.png)\n\n~~~xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\n~~~\n\n>**2.原型模式：每次从容器中get对象时，都重新创建**\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210110192420718.png)\n\n~~~xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n~~~\n\n**3.其余的request、session、application、websocket这些只能在web开发中使用**\n\n\n\n## 5. Bean的自动装配\n\n- 自动装配是spring满足bean依赖的一种方式\n- Spring会在上下文中自动寻找，并自动给bean装配属性\n\n> 在Spring中由三种装配方式\n\n1. 在xml中显式配置\n2. 在java中显式配置\n3. **隐式的自动装配bean**\n\n~~~xml\n<--1.在xml中显式配置-->\n<bean id=\"dog\" class=\"com.koko.pojo.Dog\"/>\n<bean id=\"cat\" class=\"com.koko.pojo.Cat\"/>\n\n<bean id=\"people\" class=\"com.koko.pojo.People\">\n    <property name=\"cat\" ref=\"cat\"/>\n    <property name=\"dog\" ref=\"dog\"/>\n    <property name=\"name\" value=\"name\"/>\n</bean>\n~~~\n\n> 改进：\n\n### 5.1 byName与byType自动装配\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"cat\" class=\"com.koko.pojo.Cat\"/>\n    <bean id=\"dog\" class=\"com.koko.pojo.Dog\"/>\n    \n    <!--\n        byName:会在容器上下文中查找，和自己对象set方法后面的值相对应的beanid\n        byType：会自动在容器上下文中查找，和自己对象属性类型相同的bean\n    -->\n    <bean id=\"people\" class=\"com.koko.pojo.People\" autowire=\"byName\">\n        <property name=\"name\" value=\"koko\"/>\n    </bean>\n    <bean id=\"people\" class=\"com.koko.pojo.People\" autowire=\"byType\">\n        <property name=\"name\" value=\"koko\"/>\n    </bean>\n\n</beans>\n~~~\n\n> 测试\n\n```java\n@Test\npublic void testMethodAutowire() {\n    ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n    People people = context.getBean(\"people\", People.class);\n    people.getCat().shout();\n    people.getDog().shout();\n}\n```\n\n**小结：**\n		byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致\n		byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致\n\n\n\n### 5.2 使用注解实现自动装配\n\n> 1、配置注解的支持context:annotation-config\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xmlns:context=\"http://www.springframework.org/schema/context\"\n      xmlns:aop=\"http://www.springframework.org/schema/aop\"\n      xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       https://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       https://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/aop\n       https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n   <!--开启注解支持-->\n   <context:annotation-config/>\n</beans>\n~~~\n\n\n\n### 5.3 @Autowired与@Resource自动装配\n\n> 1、@Autowired\n\n~~~java\npublic class People {\n    @Autowired\n    private Cat cat;\n    @Autowired\n    @Qualifier(value = \"xxx\")\n    private Dog dog;\n    private String name;\n}\n~~~\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier（value = “xxx”）去配置@Autowired的使用，指定一个唯一的bean对象注入！\n\n\n\n> 2、@Resource\n\n**不指定name值，先去判断byName和byType，有一个能注入即成功**\n\n~~~java\npublic class People {\n    @Resource(name = \"xxxx\")\n    private Cat cat;\n}\n~~~\n\n\n\n> **3、小结：@Resource和@Autowired的区别**\n\n- 都是用来自动装配的，都可以放在属性字段上\n- @Autowired通过byType的方式实现，而且必须要求这个对象存在！\n\n- @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！\n- 执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byName的方式实现。\n\n\n\n### 5.4 使用注解开发\n\n在Spring4之后，要使用注解开发，必须保证aop的包导入了\n\n![image-20220209170107209](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220209170107209.png)\n\n> 使用注解需要导入context约束，增加注解的支持！\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--开启注解支持-->\n    <context:annotation-config/>\n    <!--指定要扫描的包，这个包下的注解就会生效-->\n    <context:component-scan base-package=\"com.koko\"/>\n</beans>\n~~~\n\n>**1. bean注入使用@Componet注解**\n\n~~~java\n//@Component 等价于<bean id=\"user\" class=\"com.koko.pojo.User\"/>\n@Component\npublic class User {\n    String name;\n}\n~~~\n\n>**2. 属性注入使用@Value注解**\n\n~~~java\n//@Component 等价于<bean id=\"user\" class=\"com.koko.pojo.User\"/>\n@Component\npublic class User {\n    @Value(\"koko\")\n    String name;\n    //@Value(\"yang\") 相当于<property name=\"name\" value=\"yang\"/>\n    @Value(\"koko\")\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n~~~\n\n>**3. 衍生注解**\n\n@Componet有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！\n\n- dao层 【@Repository】\n- service层 【@Service】\n\n- controller层 【@Controller】\n\n这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean\n\n>**4.自动装配**\n\n~~~properties\n@Autowired  自动装配通过类型、名字\n			如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value=\"xxx\")\n@Nullable   字段标记了这个注解，说明这个字段可以为null\n@Resource 自动装配通过名字，类型\n~~~\n\n>**5. 作用域**\n\n~~~java\n//类中定义\n@Scope(\"singleton\")单例模式\n@Scope(\"prototype\")原型模式    \n~~~\n\n* 类中定义\n\n>**6. 小结**\n\n1、XML 与 注解\n\n- xml更加万能，适用于任何场合！维护简单方便\n- 注解不是自己类使用不了， 维护相对复杂\n\n2、XML 与 注解最佳实践\n\n- xml用来管理bean\n- 注解只负责完成属性的注入\n- 我们在使用过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n\n~~~xml\n<!--开启注解支持-->\n<context:annotation-config/>\n<!--指定要扫描的包，这个包下的注解就会生效-->\n<context:component-scan base-package=\"com.koko\"/>\n~~~\n\n\n\n### 5.5 使用java的方式配置Spring\n\n> 与上述配置文件开发思路不同\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210117164149562.png)\n\n> 测试模块框架\n\n![image-20220209173525270](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220209173525270.png)\n\n>1、实体类\n\n~~~java\npackage com.koko.pojo;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User {\n\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n    @Value(\"koko\")\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n~~~\n\n> 2、配置类\n\n~~~java\npackage com.koko.config;\nimport com.koko.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n\n//@Configuration,这个也会被Spring容器托管，注册到容器中，因为打开注解，它本身就被定义为组件了@Component\n//@Configuration该注解代表了这是一个配置类，与applicationContext.xml一样\n@Configuration\n@ComponentScan(\"com.koko.pojo\")\n@Import(kokoConfig2.class)\npublic class kokoConfig {\n\n    //注册一个Bean，就相当于我们之前写的一个bean标签\n    //方法名字 == bean标签的id\n    //方法的返回值 == bean标签中的class属性\n\n    @Bean\n    public User getUser () {\n        return new User();//就是返回要注入到bean的对象\n    }\n}\n~~~\n\n> 3、测试类\n\n```java\n@Test\npublic void test01(){\n    AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(kokoConfig.class);\n\n    User getUser = annotationConfigApplicationContext.getBean(\"getUser\", User.class);\n    System.out.println(getUser.getName());\n\n}\n```\n\n这种纯Java的配置方式，在SpringBoot中随处可见！\n\n\n\n## 6. 代理模式（*）\n\n> 1、为什么要学习代理模式？\n\n因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】\n\n![image-20220209202921677](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220209202921677.png)\n\n\n\n### 6.1 静态代理\n\n> 1、角色分析：\n\n- 抽象角色：一般会使用接口或者抽象类来解决\n- 真实角色：被代理的角色\n- 代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作\n- 客户：访问代理对象的人\n\n>2、代码步骤：\n\n1. 接口\n2. 真实角色\n3. 代理角色\n4. 客户端访问代理角色\n5. 具体代码可参考：[多线程中的静态代理](https://blog.csdn.net/weixin_45416687/article/details/108552758)\n\n> **3、特点：代理模式**\n\n优点：\n\n- 可以使真实角色的操作更加存粹！不用去关注一些公共的业务\n- 公共交给了代理角色，实现了业务的分工\n- 公共业务发生扩展的时候，方便集中管理\n\n缺点：\n\n- 一个真实角色就会产生一个代理角色，代码量会翻倍 开发效率变低\n\n> 4、聊聊AOP\n\n![image-20220209204109716](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220209204109716.png)\n\n\n\n### 6.2 动态代理\n\n- 动态代理和静态代理角色一样\n\n- 动态代理的代理类是动态生成的，不是我们直接写好的\n\n- 动态代理分为两大类：基于接口的动态代理，基于类的动态代理\n\n  基于接口：JDK动态代理\n  基于类： cglib\n  java字节码实现： javasist\n\n> 1、需要了解两个类：\n\nProxy：代理 \n\nInvocationHandler：调用处理程序\n\n\n\n> 2、Proxy：代理 \n\n* 2-1、基本特质：\n\njava.lang.reflect.Proxy\n\nProxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。\n\n(大白话：这是一个静态类，类里边有方法得到代理类)\n\n* 2-2、动态代理类：\n\n动态代理类 （以下简称为代理类 ）是一个实现在类创建时在运行时指定的接口列表的类，具有如下所述的行为。\n\n 代理接口是由代理类实现的接口。 代理实例是代理类的一个实例。 每个代理实例都有一个关联的调用处理程序对象，它实现了接口InvocationHandler 。\n\n 通过其代理接口之一的代理实例上的方法调用将被分派到实例调用处理程序的invoke方法，传递代理实例， java.lang.reflect.Method被调用方法的java.lang.reflect.Method对象以及包含参数的类型Object Object的数组。\n\n 调用处理程序适当地处理编码方法调用，并且返回的结果将作为方法在代理实例上调用的结果返回。\n\n\n> 3、InvocationHandler：调用处理程序\n\n* 3-1、基本特质：\n\nInvocationHandler是由代理实例的调用处理程序实现的接口 。\n\n每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。\n\ninvoke(Object proxy, 方法 method, Object[] args) 处理代理实例上的方法调用并返回结果。\n\n\n\n> 4、示例编写\n\n![image-20220209230637020](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220209230637020.png)\n\n> 1、UserService接口\n\n```java\npackage com.koko.pojo;\n\npublic interface UserService {\n    public void add();\n    public void delete();\n    public void update();\n    public void select();\n}\n```\n\n> 2、接口实现类\n\n```java\npackage com.koko.pojo;\n\npublic class UserServiceImpl implements UserService{\n    public void add() {\n        System.out.println(\"增加一个用户\");\n    }\n    public void delete() {\n        System.out.println(\"删除一个用户\");\n    }\n    public void update() {\n        System.out.println(\"更新一个用户\");\n    }\n    public void select() {\n        System.out.println(\"检索一个用户\");\n    }\n}\n```\n\n> **3、创建代理工具类**\n\n```java\npackage com.koko.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class ProxyInvocationHandler implements InvocationHandler {\n\n    //被代理的接口\n    private Object target;\n\n    //接口的set方法\n    public void setTarget(Object target){\n        this.target=target;\n    }\n\n    //生成得到代理类\n    public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(),\n                target.getClass().getInterfaces(),this);\n    }\n\n    //处理代理实例，并返回结果:\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        log(method.getName());\n        Object result = method.invoke(target, args);\n        return result;\n    }\n\n    public void log(String msg){\n        System.out.println(\"执行了\"+msg+\"方法\");\n    }\n\n}\n```\n\n> 4、测试类\n\n```java\npackage com.koko.test;\n\nimport com.koko.pojo.UserService;\nimport com.koko.pojo.UserServiceImpl;\n\npublic class Client {\n    public static void main(String[] args) {\n        //真实角色\n        UserServiceImpl userService = new UserServiceImpl();\n\n        //代理角色，不存在\n        ProxyInvocationHandler proxyInvocationHandler = new ProxyInvocationHandler();\n\n        //设置要代理的对象\n        proxyInvocationHandler.setTarget(userService);\n\n        //注意要用接口强转，否则会报异常\n        UserService proxy = (UserService)proxyInvocationHandler.getProxy();\n        proxy.add();\n        proxy.delete();\n    }\n}\n```\n\n![image-20220209231314790](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220209231314790.png)\n\n\n\n> **4、动态代理的好处：**\n\n在原先代理模式的前提下：\n\n* 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n* 一个动态代理类可以代理多个类，只要是实现了同一个接口即可！\n\n\n\n## 7. AOP面向切面编程(*)\n\n### 7.1 什么是AOP\n\nAOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210120190356959.png)\n\n\n\n### 7.2 Aop在Spring中的作用\n\n==提供生命事务：允许用户自定义切面==\n\n- 横切关注点：跨越应用程序多个模块的方法或功能。即与我们的业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等。。。\n- 切面（ASPECT）：横切关注点 被模块化的特殊对象。即 它是一个类\n- 通知（Advice）：切面必须要完成的工作，即 他是类中的一个方法\n\n- 目标（target）：被通知的对象\n- 代理（Proxy）：向目标对象应用通知之后创建的对象\n- 切入点（PointCut）：切面通知 执行的\"地点\"的定义\n- 连接点（jointPoint）：与切入点匹配的执行点\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210120191529526.png)\n\nSpringAop中，通过Advice定义横切逻辑，Spring中支持的5种类型的Advice\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210120192909523.png)\n\n\n\n### 7.3 使用Spring实现Aop\n\n**【重点】使用AOP织入，需要依赖包**\n\n~~~xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n</dependency>\n~~~\n\n使用Spring实现Aop主要有三种方法：\n\n* 使用Spring的API接口\n* 自定义来实现AOP\n* 使用注解实现AOP\n\n\n\n> 项目文件\n\n![image-20220210162449493](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210162449493.png)\n\n\n\n#### **7.3.1 使用Spring的API接口**\n\neg:在执行UserService实现类的所有方法时，增加日志功能\n\n> 1、UserServer接口\n\n~~~java\npackage com.koko.service;\n\npublic interface UserService {\n    public void add();\n    public void delete();\n    public void update();\n    public void select();\n}\n~~~\n\n> 2、UserServer实现类\n\n```java\npackage com.koko.service;\n\npublic class UserServiceImpl implements UserService{\n    public void add() {\n        System.out.println(\"增加一个用户\");\n    }\n    public void delete() {\n        System.out.println(\"删除一个用户\");\n    }\n    public void update() {\n        System.out.println(\"更新一个用户\");\n    }\n    public void select() {\n        System.out.println(\"检索一个用户\");\n    }\n}\n```\n\n> 3、Log类\n\n```java\npackage com.koko.log;\n\nimport org.springframework.aop.AfterReturningAdvice;\nimport org.springframework.aop.MethodBeforeAdvice;\nimport java.lang.reflect.Method;\npublic class log implements MethodBeforeAdvice, AfterReturningAdvice {\n    //method:要执行的目标对象的方法（method being invoked）\n    //args:参数（args: arguments to the method）\n    //object:目标对象 （target：target of the method invocation）\n    public void before(Method method, Object[] args, Object target) throws Throwable {\n        System.out.println(target.getClass().getName() + \"的\" + method.getName() + \"被执行了\");\n    }\n    //returnValue:返回值\n    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n        System.out.println(\"执行了\" + method.getName() + \"方法，返回值为\" + returnValue);\n    }\n}\n```\n\n> **4、applicationContext.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--注册bean-->\n    <bean id=\"userService\" class=\"com.koko.service.UserServiceImpl\"/>\n    <bean id=\"log\" class=\"com.koko.log.log\"/>\n\n    <!--方式：使用原生Spring Api接口-->\n    <!--配置aop-->\n    <aop:config>\n        <!--切入点：execution:表达式，execution(*(修饰词) *(返回值) *(类名) *(方法名) *(参数))  ..任意参数-->\n        <aop:pointcut id=\"pointcut\" expression=\"execution(* com.koko.service.UserServiceImpl.*(..))\"/>\n\n        <!--执行环绕增加-->\n        <aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/>\n    </aop:config>\n</beans>\n```\n\n> 5、测试类\n\n```java\nimport com.koko.service.UserService;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class mytest {\n    @Test\n    public void test01(){\n        ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\n        //动态代理的代理对象是接口\n        UserService userService = classPathXmlApplicationContext.getBean(\"userService\", UserService.class);\n        userService.add();\n    }\n}\n```\n\n![image-20220210164104653](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210164104653.png)\n\n\n\n#### **7.3.2 自定义来实现AOP**\n\n【主要是切面定义】\n\n> 1、自定义类DiyPointCut\n\n```java\npackage com.koko.diy;\n\npublic class DiyPointCut {\n    public void beforeMethod () {\n        System.out.println(\"方法执行之前\");\n    }\n\n    public void afterMethod(){\n        System.out.println(\"方法执行之后\");\n    }\n}\n```\n\n> **2、applicationContext.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--注册bean-->\n    <bean id=\"userService\" class=\"com.koko.service.UserServiceImpl\"/>\n    <bean id=\"log\" class=\"com.koko.log.log\"/>\n    <bean id=\"diy\" class=\"com.koko.diy.DiyPointCut\"/>\n    <!--方式2：自定义类-->\n    <aop:config>\n        <!--<aop:aspect ref=\"diy\"> : 标注这个类为切面-->\n        <aop:aspect ref=\"diy\">\n            <!--切入点-->\n            <aop:pointcut id=\"point\" expression=\"execution(* com.koko.service.UserServiceImpl.*(..))\"/>\n            <!--通知-->\n            <aop:before method=\"beforeMethod\" pointcut-ref=\"point\"/>\n            <aop:after method=\"afterMethod\" pointcut-ref=\"point\"/>\n        </aop:aspect>\n    </aop:config>\n\n</beans>\n```\n\n![image-20220210164648987](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210164648987.png)\n\n\n\n#### **7.3.3 使用注解实现AOP**\n\n>1、注释自定义类\n\n```java\npackage com.koko.diy;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.Signature;\nimport org.aspectj.lang.annotation.*;\n\n@Aspect\nclass AnnotationPointcut {\n    @Before(\"execution(* com.koko.service.UserServiceImpl.*(..))\")\n    public void before () {\n        System.out.println(\"====方法执行前====\");\n    }\n    @After(\"execution(* com.koko.service.UserServiceImpl.*(..))\")\n    public void after () {\n        System.out.println(\"====方法执行后====\");\n    }\n    //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点\n    @Around(\"execution(* com.koko.service.UserServiceImpl.*(..))\")\n    public void around (ProceedingJoinPoint pjp) throws Throwable {\n        System.out.println(\"环绕前\");\n        Signature signature = pjp.getSignature();//获得签名\n        System.out.println(\"signature:\" + signature);\n\n        Object proceed = pjp.proceed();//执行方法\n        System.out.println(proceed);\n        System.out.println(\"环绕后\");\n    }\n}\n```\n\n> **2、applicationContext.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--注册bean-->\n    <bean id=\"userService\" class=\"com.koko.service.UserServiceImpl\"/>\n\n    <!--方式3：使用注解-->\n    <!--开启注解支持  JDK（默认proxy-target-class=\"false\"）cglib默认proxy-target-class=\"true\"）-->\n    <aop:aspectj-autoproxy proxy-target-class=\"false\"/>\n    <bean id=\"annotationPointCut\" class=\"com.koko.diy.AnnotationPointcut\"/>\n\n</beans>\n```\n\n![image-20220210165216464](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210165216464.png)\n\n\n\n## 8. 整合Mybatis（*）\n\n### 8.1 回顾Mybatis\n\n> 1、导入相关jar包\n\n* junit\n* mybatis\n* mysql数据库\n* spring相关的\n* aop织入\n* mybatis-spring\n* ......\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>spring_01_study</artifactId>\n        <groupId>com.koko</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>spring_07_mybatis</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.20</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.3.15</version>\n        </dependency>\n        <!--Spring操作数据库的话，还需要一个spring-jdbc-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>5.1.9.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>2.0.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.22</version>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <resources>\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n\n</project>\n~~~\n\n> 2、项目模块\n\n![image-20220210174521517](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210174521517.png)\n\n> 2-1、User实体类\n\n~~~java\npackage com.koko.pojo;\n\nimport lombok.Data;\n\n@Data\npublic class User {\n    private int id;\n    private String name;\n    private int pwd;\n}\n~~~\n\n> 2-2、mybatis-config.xml\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<!--configuration core file-->\n<configuration>\n\n    <typeAliases>\n        <package name=\"com.koko.pojo\"/>\n    </typeAliases>\n\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"123456\"/>\n            </dataSource>\n        </environment>\n    </environments>\n\n    <mappers>\n        <mapper class=\"com.koko.mapper.UserMapper\"/>\n    </mappers>\n</configuration>\n~~~\n\n> 2-3、接口类\n\n```java\npackage com.koko.mapper;\n\nimport com.koko.pojo.User;\nimport java.util.List;\n\npublic interface UserMapper {\n    public List<User> selectUser();\n}\n```\n\n> 2-4、接口实现类\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.koko.mapper.UserMapper\">\n\n    <select id=\"selectUser\" resultType=\"user\">\n        select * from mybatis.user;\n    </select>\n\n</mapper>\n```\n\n> 2-5、测试类\n\n```java\nimport com.koko.mapper.UserMapper;\nimport com.koko.pojo.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class mytest {\n    @Test\n    public void test01 () throws IOException {\n        String resources=\"mybatis-config.xml\";\n        InputStream in = Resources.getResourceAsStream(resources);\n        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);\n        SqlSession sqlSession = sessionFactory.openSession(true);\n\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        List<User> users = mapper.selectUser();\n\n        for (User user : users) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\n![image-20220210174851551](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210174851551.png)\n\n\n\n### 8.2 整合Mybatis方式一\n\n> 1、步骤\n\n* 编写数据源配置DataSource\n* sqlSessionFactory\n* sqlSessionTeamplate\n* 需要给接口加实现类\n* 将自己写的实现类注入Spring中\n* 测试使用即可！\n\n![image-20220210224455622](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210224455622.png)\n\n\n\n> 2、spring-dao.xml\n\n配置数据源DataSource与sqlSession\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--1、DataSource：使用Spring的数据源替换Mybatis的配置  c3p0  dbcp  druid\n    我们这里使用Spring提供的JDBC：org.springframework.jdbc.datasource-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n    </bean>\n\n    <!--2、sqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n        <!--绑定Mybatis配置文件-->\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"mapperLocations\" value=\"classpath:com/koko/mapper/*.xml\"/>\n    </bean>\n\n    <!--3、sqlSession-->\n    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <!--只能使用构造器注入sqlSessionFactory，因为没有set方法-->\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    </bean>\n</beans>\n```\n\n>3、mybatis-config.xml\n\n配置一些mybatis专属配置（让mybatis有点用！）\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<!--configuration core file-->\n<configuration>\n\n    <typeAliases>\n        <package name=\"com.koko.pojo\"/>\n    </typeAliases>\n\n</configuration>\n```\n\n>4、applicationContext.xml\n\n整合与注册bean等\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    \n    <import resource=\"spring-dao.xml\"/>\n    \n    <bean id=\"userMapper\" class=\"com.koko.mapper.UserMapperImpl\">\n        <property name=\"sqlSessionTemplate\" ref=\"sqlSession\"/>\n    </bean>\n    \n</beans>\n~~~\n\n> 5、接口实现类UserMapperImpl\n\n```java\npackage com.koko.mapper;\n\nimport com.koko.pojo.User;\nimport org.mybatis.spring.SqlSessionTemplate;\n\nimport java.util.List;\n\npublic class UserMapperImpl implements UserMapper{\n\n    //我们的所有操作，原来都是用sqlSession来执行，现在都是用sqlSessionTemplate\n    private SqlSessionTemplate sqlSessionTemplate;\n\n    public void setSqlSessionTemplate (SqlSessionTemplate sqlSessionTemplate) {\n        this.sqlSessionTemplate = sqlSessionTemplate;\n    }\n    public List<User> selectUser() {\n        UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);\n        return mapper.selectUser();\n    }\n}\n```\n\n> 6、测试类\n\n```java\n@Test\npublic void test01 (){\n    ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\n    UserMapper userMapper = classPathXmlApplicationContext.getBean(\"userMapper\", UserMapper.class);\n    List<User> userList = userMapper.selectUser();\n\n    for (User user : userList) {\n        System.out.println(user);\n    }\n}\n```\n\n![image-20220210225513041](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210225513041.png)\n\n\n\n### 8.3 整合Mybatis方式二\n\n> 1、SqlSessionDaoSupport介绍\n\nSqlSessionDaoSupport 是一个抽象的支持类，用来为你提供 SqlSession。\n\n调用 getSqlSession() 方法你会得到一个 SqlSessionTemplate，之后可以用于执行 SQL 方法，实现流程如下：\n\n![image-20220210231613916](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/image-20220210231613916.png)\n\n> 2、UserMapperImpl2类\n\nmybatis—>Spring整合实现类（自我定位）\n\n```java\npackage com.koko.mapper;\n\nimport com.koko.pojo.User;\nimport org.mybatis.spring.support.SqlSessionDaoSupport;\n\nimport java.util.List;\n\npublic class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper {\n    @Override\n    public List<User> selectUser() {\n        return getSqlSession().getMapper(UserMapper.class).selectUser();\n    }\n}\n```\n\n> 3、applicationContext.xml\n\n```xml\n<bean id=\"userMapper2\" class=\"com.koko.mapper.UserMapperImpl2\">\n    <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/>\n</bean>\n```\n\n> 4、小结\n\n==实际上是整合mybatis一与整合mybatis二是一样的方法，只不过二继承了SqlSessionDaoSupport ，在getSqlSession()，做的也是setSqlSessionTemplate==\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/08_Spring/20210126191106175.png)\n\n\n\n## 9. 声明式事务\n\n### 9.1 回顾事务\n\n* 把一组业务当做一个业务来做，要么都成功，要么都失败！\n* 事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎！\n* 确保完整性和一致性！\n\n\n\n> 事务ACID原则：\n\n* 原子性\n* 一致性\n* 隔离性\n  * 多个业务可能操作同一个资源，防止数据损坏\n* 持久性\n  * 事务一旦提交，无论系统发生什么问题，结果都不会被影响，被持久化的写到存储器中！\n\n\n\n### 9.2 Spring中的事务管理\n\n* 声明式事务：AOP（推荐）\n* 编程式事务：需要在代码中进行事务管理\n\n> spring-dao.xml中配置\n\n配置事务的传播特性 propagation:\n\n* 1、**PROPAGATION_REQUIRED**:如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择\n* 2、PROPAGATION_SUPPORTS:支持当前事务，如果没有当前事务，就以非事务方法执行。\n* 3、PROPAGATION_MANDATORY:使用当前事务，如果没有当前事务，就抛出异常。\n* 4、PROPAGATION_REQUIRES_NEW:新建事务，如果当前存在事务，把当前事务挂起。\n* 5、PROPAGATION_NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n* 6、PROPAGATION_NEVER:以非事务方式执行操作，如果当前事务存在则抛出异常。\n* 7、**PROPAGATION_NESTED**:	如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n    <import resource=\"spring-dao.xml\"/>\n\n    <bean id=\"userMapper\" class=\"com.koko.mapper.UserMapperImpl2\">\n        <property name=\"sqlSessionTemplate\" ref=\"sqlSession\"/>\n    </bean>\n    <!--配置声明事务注入-->\n    <!--要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 DataSourceTransactionManager 对象：-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <!--或者使用构造注入-->\n        <!--<constructor-arg ref=\"dataSource\" />-->\n    </bean>\n\n    <!--结合AOP实现事务的织入-->\n    <!--配置事务通知-->\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <!--给哪些方法配置事务-->\n        <tx:attributes>\n            <tx:method name=\"add\" propagation=\"REQUIRED\"/>\n            <tx:method name=\"delete\" propagation=\"REQUIRED\"/>\n            <tx:method name=\"update\" propagation=\"REQUIRED\"/>\n            <tx:method name=\"select\" read-only=\"true\"/>\n            <!--全部方法-->\n            <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n        </tx:attributes>\n    </tx:advice>\n\n    <!--配置事务切入-->\n    <aop:config>\n        <!--该包下的所有方法-->\n        <aop:pointcut id=\"txPointCut\" expression=\"execution(* com.koko.mapper.*.*(..))\"/>\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/>\n    </aop:config>\n</beans>\n~~~\n\n> 思考：\n\n为什么需要事务？\n\n* 如果不配置事务，可能存在数据提交不一致的情况\n* 如果我们不在spring中配置声明式事务，我们就需要在代码中手动配置事务！\n* 事务在项目的开发中十分重要！设计到数据的一致性和完整性问题，不容马虎！\n\n', '关于Spring的完整笔记', 4, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/20e65bba-b006-4cdb-b154-18ffc8428a05.jpg', '1', '0', 156, '0', 1, '2023-02-21 22:42:14', 1, '2023-02-21 22:42:14', 0);
INSERT INTO `sg_article` VALUES (15, 'SpringBoot完整笔记', '# SpringBoot\n\n## 目录\n\n[toc]\n\n> Java全栈工程师：\n\n* 后台开发：主打；\n* 前端：html、css、js、JQuery；\n* 运维：项目发布：服务器如何运行一个项目？Linux；\n\n![image-20220301213821437](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220301213821437.png)\n\n> 心得：\n\n* 如果程序=数据结构+算法，则为程序猿\n* 如果程序=面向对象+算法，则为码农\n\n你会成为哪种人，取决于你如何学习！\n\n\n\n## 1. SpringBoot简介\n\n### 1.1 回顾什么是Spring \n\n> 概述\n\nSpring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  。\n\n**Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。**\n\n\n\n### 1.2 Spring是如何简化Java开发的\n\n> 为了降低Java开发的复杂性，Spring采用了以下4种关键策略：\n\n1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；\n\n2、通过IOC，依赖注入（DI）和面向接口实现松耦合；\n\n3、基于切面（AOP）和惯例进行声明式编程；\n\n4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；\n\n\n\n### 1.3 什么是SpringBoot\n\n> 概述\n\n学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍；\n\n言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，  you can \"just run\"，能迅速的开发web应用，几行代码开发一个http接口。\n\n所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。\n\n是的这就是Java企业级应用->J2EE->spring->springboot的过程。\n\n随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；\n\nSpring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以**约定大于配置的核心思想**，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。\n\n简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。\n\nSpring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。\n\n> **Spring Boot的主要优点：**\n\n- 为所有Spring开发者更快的入门\n- **开箱即用**，提供各种默认配置来简化项目配置\n- 内嵌式容器简化Web项目\n- 没有冗余代码生成和XML配置的要求\n\n真的很爽，我们快速去体验开发个接口的感觉吧！\n\n\n\n## 2. 第一个程序\n\n> 准备工作\n\n我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n\n\n### 2.1 项目创建方式(-)\n\n> **1、项目创建方式一**：使用Spring Initializr 的 Web页面创建项目\n\nSpring Initializr：https://start.spring.io/\n\n1、打开  https://start.spring.io/\n\n2、填写项目信息\n\n3、点击”Generate Project“按钮生成项目；下载此项目\n\n4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。\n\n5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。\n\n![image-20220302103317481](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302103317481.png)\n\n\n\n> **2、项目创建方式二：**使用 IDEA 直接创建项目\n\n1、创建一个新项目\n\n2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现\n\n3、填写项目信息\n\n4、选择初始化的组件（初学勾选 Web 即可）\n\n5、填写项目路径\n\n6、等待项目构建成功\n\n\n\n> **3、项目结构分析：**\n\n通过上面步骤完成了基础项目的创建。就会自动生成以下文件。\n\n1、程序的主启动类\n\n2、一个 application.properties 配置文件\n\n3、一个 测试类\n\n4、一个 pom.xml\n\n\n\n### 2.2 项目创建详解(*)\n\n> 1、项目创建过程\n\n1. 选择Spring Initializr\n\n![image-20220302153444197](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302153444197.png)\n\n2. 创建项目详细信息\n\n![image-20220302153808283](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302153808283.png)\n\n3. 选择web支持\n\n![image-20220302153854102](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302153854102.png)\n\n* 此处没选web支持\n\n4. 删除多余文件\n\n![image-20220302154052439](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302154052439.png)\n\n5. 在pom.xml中配置\n\n```xml\n<!--web支持-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n* 用来支持web\n\n\n\n> 2、更改项目的端口号\n\n* 在application.properties\n\n```properties\n# 更改项目的端口号\nserver.port=8081\n```\n\n\n\n### 2.3 项目编写\n\n> 1、编写流程\n\n1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到\n\n2、在包中新建一个HelloController类\n\n```java\npackage com.koko.demo.controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"Hello World\";\n    }\n\n}\n```\n\n3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！\n\n![image-20220302111816495](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302111816495.png)\n\n简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！\n\n\n\n> 2、打包发布\n\n* 将项目打成jar包，点击 maven的 package\n\n![图片](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/640)\n\n注：如果遇到以上错误，可以配置打包时 跳过项目运行测试用例\n\n~~~xml\n<!--\n    在工作中,很多情况下我们打包是不想执行测试用例的\n    可能是测试用例不完事,或是测试用例会影响数据库数据\n    跳过测试用例执\n    -->\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-surefire-plugin</artifactId>\n    <configuration>\n        <!--跳过项目运行测试用例-->\n        <skipTests>true</skipTests>\n    </configuration>\n</plugin>\n~~~\n\n* 如果打包成功，则会在target目录下生成一个 jar 包\n\n![image-20220302125243168](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302125243168.png)\n\n打成了jar包后，就可以在任何地方运行了！OK\n\n* jar包运行\n\n![image-20220303214852888](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220303214852888.png)\n\n~~~properties\njava -jar xxx.jar\n~~~\n\n\n\n> 3、彩蛋\n\n如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案；\n\n只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。\n\n图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！\n\n![image-20220302125732171](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220302125732171.png)\n\n**SpringBoot这么简单的东西背后一定有故事，我们之后去进行一波源码分析！**\n\n\n\n### 2.4 运行原理初探\n\n#### 2.4.1 pom.xml\n\n> 1、父依赖\n\n其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.6.4</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n```\n\n点进去，发现还有一个父依赖\n\n~~~xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.6.4.RELEASE</version>\n    <relativePath>../../spring-boot-dependencies</relativePath>\n</parent>\n~~~\n\n这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；\n\n**以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；**\n\n\n\n> 2、启动器 spring-boot-starter\n\n~~~xml\n<dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-web</artifactId></dependency>\n~~~\n\n**springboot-boot-starter-xxx**：就是spring-boot的场景启动器\n\n**spring-boot-starter-web**：帮我们导入了web模块正常运行所依赖的组件；\n\nSpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；\n\n\n\n#### 2.4.2 主启动类\n\n> 1、默认的主启动类\n\n~~~java\n//@SpringBootApplication 来标注一个主程序类\n//说明这是一个Spring Boot应用\n@SpringBootApplication\npublic class SpringbootApplication {\n\n   public static void main(String[] args) {\n     //以为是启动了一个方法，没想到启动了一个服务\n      SpringApplication.run(SpringbootApplication.class, args);\n   }\n\n}\n~~~\n\n但是**一个简单的启动类并不简单！**我们来分析一下这些注解都干了什么\n\n\n\n> **2、注解**\n\n> **1、@SpringBootApplication**\n\n**1、@SpringBootApplication**\n\n作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n\n进入这个注解：可以看到上面还有很多其他注解！\n\n~~~java\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n    // ......\n}\n~~~\n\n**2、@ComponentScan**\n\n这个注解在Spring中很重要 ,它对应XML配置中的元素。\n\n作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中\n\n**3、@SpringBootConfiguration**\n\n作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；\n\n我们继续进去这个注解查看\n\n~~~java\n// 点进去得到下面的 @Component\n@Configuration\npublic @interface SpringBootConfiguration {}\n\n@Component\npublic @interface Configuration {}\n~~~\n\n这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；\n\n里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！\n\n我们回到 SpringBootApplication 注解中继续看。\n\n> **2、@EnableAutoConfiguration**\n\n**1、@EnableAutoConfiguration ：开启自动配置功能**\n\n以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；\n\n点进注解接续查看：\n\n**2、@AutoConfigurationPackage ：自动配置包**\n\n~~~java\n@Import({Registrar.class})\npublic @interface AutoConfigurationPackage {\n}\n~~~\n\n**3、@import** ：Spring底层注解@import ， 给容器中导入一个组件\n\nRegistrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；\n\n这个分析完了，退到上一步，继续看\n\n**4、@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；**\n\nAutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：\n\n1、这个类中有一个这样的方法\n\n~~~java\n// 获得候选的配置\nprotected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n    //这里的getSpringFactoriesLoaderFactoryClass（）方法\n    //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration\n    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n    Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n    return configurations;\n}\n~~~\n\n2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法\n\n~~~java\npublic static List<String> loadFactoryNames(Class<?> factoryClass, @Nullable ClassLoader classLoader) {\n    String factoryClassName = factoryClass.getName();\n    //这里它又调用了 loadSpringFactories 方法\n    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());\n}\n~~~\n\n3、我们继续点击查看 loadSpringFactories 方法\n\n~~~java\nprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身\n    MultiValueMap<String, String> result = (MultiValueMap)cache.get(classLoader);\n    if (result != null) {\n        return result;\n    } else {\n        try {\n            //去获取一个资源 \"META-INF/spring.factories\"\n            Enumeration<URL> urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\");\n            LinkedMultiValueMap result = new LinkedMultiValueMap();\n\n            //将读取到的资源遍历，封装成为一个Properties\n            while(urls.hasMoreElements()) {\n                URL url = (URL)urls.nextElement();\n                UrlResource resource = new UrlResource(url);\n                Properties properties = PropertiesLoaderUtils.loadProperties(resource);\n                Iterator var6 = properties.entrySet().iterator();\n\n                while(var6.hasNext()) {\n                    Entry<?, ?> entry = (Entry)var6.next();\n                    String factoryClassName = ((String)entry.getKey()).trim();\n                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());\n                    int var10 = var9.length;\n\n                    for(int var11 = 0; var11 < var10; ++var11) {\n                        String factoryName = var9[var11];\n                        result.add(factoryClassName, factoryName.trim());\n                    }\n                }\n            }\n\n            cache.put(classLoader, result);\n            return result;\n        } catch (IOException var13) {\n            throw new IllegalArgumentException(\"Unable to load factories from location [META-INF/spring.factories]\", var13);\n        }\n    }\n}\n~~~\n\n4、发现一个多次出现的文件：spring.factories，全局搜索它\n\n\n\n> **3、spring.factories**(*)\n\n我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！\n\n![image-20220304171510879](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304171510879.png)\n\n**WebMvcAutoConfiguration**\n\n我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration\n\n![image-20220303224038096](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220303224038096.png)\n\n可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！\n\n所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n\n\n\n> **结论：**\n\n1. SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n2. 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n3. 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n4. 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n5. 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n**现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！**\n\n\n\n#### 2.4.3 SpringApplication\n\n> 1、不简单的方法\n\n我最初以为就是运行了一个main方法，没想到却开启了一个服务；\n\n~~~java\n@SpringBootApplication\npublic class SpringbootApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootApplication.class, args);\n    }\n}\n~~~\n\n**SpringApplication.run分析**\n\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\n\n\n\n> 2、SpringApplication\n\n**这个类主要做了以下四件事情：**\n\n1、推断应用的类型是普通的项目还是Web项目\n\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n\n3、找出所有的应用程序监听器，设置到listeners属性中\n\n4、推断并设置main方法的定义类，找到运行的主类\n\n查看构造器：\n\n~~~java\npublic SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {\n    // ......\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n    this.setInitializers(this.getSpringFactoriesInstances();\n    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n    this.mainApplicationClass = this.deduceMainApplicationClass();\n}\n~~~\n\n\n\n> 3、run方法流程分析\n\n![640](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/640.jpg)\n\n\n\n## 3. yaml语法学习\n\n### 3.1 yaml概述\n\n> 1、配置文件\n\nSpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的\n\n- application.properties\n\n- - 语法结构 ：key=value\n\n- application.yml\n\n- - 语法结构 ：key：空格 value\n\n**配置文件的作用 ：**修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；\n\n比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！\n\n~~~properties\nserver.port=8081\n~~~\n\n\n\n> 2、概述\n\nYAML是 \"YAML Ain\'t a Markup Language\" （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）\n\n**这种语言以数据****作****为中心，而不是以标记语言为重点！**\n\n以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml\n\n* 传统xml配置：\n\n~~~xml\n<server>\n    <port>8081<port>\n</server>\n~~~\n\n* yaml配置：\n\n~~~yaml\nserver:\n  prot: 8080\n~~~\n\n\n\n> 3、注释：\n\n说明：语法要求严格！\n\n1、空格不能省略\n\n2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。\n\n3、属性和值的大小写都是十分敏感的。\n\n\n\n### 3.2 yaml测试(*)\n\n![image-20220304153837888](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304153837888.png)\n\n> 1、Person类\n\n```java\npackage com.koko.pojo;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n\n@Component //注册bean到容器中\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n    private String name;\n    private Integer age;\n    private Boolean happy;\n    private Date birth;\n    private Map<String,Object> maps;\n    private List<Object> lists;\n    private Dog dog;\n}\n```\n\n> 2、application.yaml\n\n```yaml\nperson:\n  name: qinjiang\n  age: 3\n  happy: false\n  birth: 2000/01/01\n  maps: {k1: v1,k2: v2}\n  lists:\n    - code\n    - girl\n    - music\n  dog:\n    name: 旺财\n    age: 1\n```\n\n> 3、springboot配置注解处理器没有找到\n\n![image-20220304154131307](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304154131307.png)\n\n* 导入依赖\n\n~~~xml\n<!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 -->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-configuration-processor</artifactId>\n  <optional>true</optional>\n</dependency>\n~~~\n\n> 4、测试\n\n~~~java\n@SpringBootTest\nclass DemoApplicationTests {\n    @Autowired\n    Person person; //将person自动注入进来\n\n    @Test\n    public void contextLoads() {\n        System.out.println(person); //打印person信息\n    }\n}\n~~~\n\n* 结果：所有值全部注入成功！\n\n![image-20220304154250202](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304154250202.png)\n\n**yaml配置注入到实体类完全OK！**\n\n\n\n> 5、配置文件占位符\n\n* 配置文件还可以编写占位符生成随机数\n\n~~~yaml\nperson:\n    name: qinjiang${random.uuid} # 随机uuid\n    age: ${random.int}  # 随机int\n    happy: false\n    birth: 2000/01/01\n    maps: {k1: v1,k2: v2}\n    lists:\n      - code\n      - girl\n      - music\n    dog:\n      name: ${person.hello:other}_旺财\n      age: 1\n~~~\n\n\n\n### 3.3 回顾properties配置\n\n我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！\n\n【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；\n\nsettings-->FileEncodings 中配置；\n\n![image-20220304154535660](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304154535660.png)\n\n\n\n> 1、新建一个实体类User\n\n~~~java\n@Component //注册bean\npublic class User {\n    private String name;\n    private int age;\n    private String sex;\n}\n~~~\n\n> 2、编辑配置文件 user.properties\n\n~~~properties\nuser1.name=kuangshen\nuser1.age=18\nuser1.sex=男\n~~~\n\n> 3、我们在User类上使用@Value来进行注入！\n\n~~~java\n@Component //注册bean\n@PropertySource(value = \"classpath:user.properties\")\npublic class User {\n    //直接使用@value\n    @Value(\"${user.name}\") //从配置文件中取值\n    private String name;\n    @Value(\"#{9*2}\")  // #{SPEL} Spring表达式\n    private int age;\n    @Value(\"男\")  // 字面量\n    private String sex;\n}\n~~~\n\n>4、Springboot测试\n\n~~~java\n@SpringBootTest\nclass DemoApplicationTests {\n\n    @Autowired\n    User user;\n\n    @Test\n    public void contextLoads() {\n        System.out.println(user);\n    }\n\n}\n~~~\n\n结果正常输出：\n\n![image-20220304154735627](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304154735627.png)\n\n\n\n> 5、对比小结\n\n@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图\n\n![image-20220304154748684](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304154748684.png)\n\n1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加\n\n2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下\n\n3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性\n\n4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持\n\n> **6、结论：**\n\n配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；\n\n如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；\n\n如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！\n\n\n\n## 4. JSR303数据校验及多环境切换\n\n### 4.1 JSR303数据校验\n\n> 1、如何使用\n\nSpringboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；\n\n~~~java\n@Component //注册bean\n@ConfigurationProperties(prefix = \"person\")\n@Validated  //数据校验\npublic class Person {\n\n    @Email(message=\"邮箱格式错误\") //name必须是邮箱格式\n    private String name;\n}\n~~~\n\n运行结果 ：default message [不是一个合法的电子邮件地址];\n\n**使用数据校验，可以保证数据的正确性；** \n\n> 2、常见参数\n\n~~~java\n@NotNull(message=\"名字不能为空\")\nprivate String userName;\n@Max(value=120,message=\"年龄最大不能查过120\")\nprivate int age;\n@Email(message=\"邮箱格式错误\")\nprivate String email;\n\n空检查\n@Null       验证对象是否为null\n@NotNull    验证对象是否不为null, 无法查检长度为0的字符串\n@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.\n@NotEmpty   检查约束元素是否为NULL或者是EMPTY.\n    \nBooelan检查\n@AssertTrue     验证 Boolean 对象是否为 true  \n@AssertFalse    验证 Boolean 对象是否为 false  \n    \n长度检查\n@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  \n@Length(min=, max=) string is between min and max included.\n\n日期检查\n@Past       验证 Date 和 Calendar 对象是否在当前时间之前  \n@Future     验证 Date 和 Calendar 对象是否在当前时间之后  \n@Pattern    验证 String 对象是否符合正则表达式的规则\n\n.......等等\n除此以外，我们还可以自定义一些数据校验规则\n~~~\n\n* 了解即可！\n\n\n\n### 4.2 多环境切换(*)\n\nprofile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；\n\n> 1、多配置文件(*)\n\n我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；\n\n**例如：**\n\n* application-test.properties 代表测试环境配置\n\n* application-dev.properties 代表开发环境配置\n\n但是Springboot并不会直接启动这些配置文件，它**默认使用application.properties主配置文件**；\n\n我们需要通过一个配置来选择需要激活的环境：\n\n~~~properties\n#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；\n#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；\nspring.profiles.active=dev\n~~~\n\n\n\n> 2、yaml的多文档块(*)\n\n和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !\n\n~~~yaml\nserver:\n  port: 8081\n#选择要激活那个环境块\nspring:\n  profiles:\n    active: prod\n\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev #配置环境的名称\n\n\n---\n\nserver:\n  port: 8084\nspring:\n  profiles: prod  #配置环境的名称\n~~~\n\n![image-20220304163111682](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304163111682.png)\n\n**注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！**\n\n\n\n> 3、配置文件加载位置\n\n**外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！**\n\n* 四种配置文件位置及运行优先级\n\n![image-20220304162647931](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304162647931.png)\n\npringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：\n\n~~~pro\n优先级1：项目路径下的config文件夹配置文件\n优先级2：项目路径下配置文件\n优先级3：资源路径下的config文件夹配置文件\n优先级4：资源路径下配置文件\n~~~\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\n\n**SpringBoot会从这四个位置全部加载主配置文件；互补配置；**\n\n我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；\n\n~~~properties\n#配置项目的访问路径\nserver.servlet.context-path=/kuang\n~~~\n\n\n\n> 4、拓展，运维小技巧\n\n指定位置加载配置文件\n\n我们还可以通过spring.config.location来改变默认的配置文件位置\n\n项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高\n\n~~~prop\njava -jar spring-boot-config.jar --spring.config.location=F:/application.properties\n~~~\n\n\n\n## 5. 自动装配原理\n\n### 5.1 自动装配原理详解\n\n> 1、概述\n\n**根据当前不同的条件判断，决定这个配置类是否生效！**\n\n- 一但这个配置类生效；这个配置类就会给容器中添加各种组件；\n- 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；\n- 所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；\n- 配置文件能配置什么就可以参照某个功能对应的这个属性类\n\n~~~java\n@ConfigurationProperties(\n    prefix = \"server\",\n    ignoreUnknownFields = true\n)\npublic class ServerProperties {\n    ...\n}\n~~~\n\n![image-20220304171818749](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304171818749.png)\n\n![image-20220304171922895](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304171922895.png)\n\n* **这就是自动装配的原理！**\n\n\n\n> 2、精髓\n\n1、SpringBoot启动会加载大量的自动配置类\n\n2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；\n\n3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）\n\n4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；\n\n* **xxxxAutoConfigurartion：自动配置类；**给容器中添加组件\n\n* **xxxxProperties:封装配置文件中相关属性；**\n\n\n\n### 5.2 @Conditional(-)\n\n了解完自动装配的原理后，我们来关注一个细节问题，**自动配置类必须在一定的条件下才能生效；**\n\n**@Conditional派生注解（Spring注解版原生的@Conditional作用）**\n\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n\n![image-20220304172107032](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220304172107032.png)\n\n**那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。**\n\n我们怎么知道哪些自动配置类生效？\n\n**我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；**\n\n> 1、application.yaml\n\n```properties\n#开启springboot的调试类\ndebug=true\n```\n\n**Positive matches:（自动配置类启用的：正匹配）**\n\n**Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）**\n\n**Unconditional classes: （没有条件的类）**\n\n【演示：查看输出的日志】\n\n掌握吸收理解原理，即可以不变应万变！\n\n\n\n## 6. SpringBoot Web开发\n\n### 6.1 Web开发静态资源处理\n\n> 1、web开发要解决的问题\n\n* 导入静态资源\n* 首页\n* jsp，模板引擎Thymeleaf\n* 装配拓展SpringMVC\n* 增删改查\n* 拦截器\n* 国际化\n\n\n\n> 2、静态资源映射规则\n\n**首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！**\n\n写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？\n\n如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！\n\n**我们先来聊聊这个静态资源映射规则：**\n\nSpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；\n\n我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；\n\n有一个方法：addResourceHandlers 添加资源处理\n\n~~~java\n@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    if (!this.resourceProperties.isAddMappings()) {\n        // 已禁用默认资源处理\n        logger.debug(\"Default resource handling disabled\");\n        return;\n    }\n    // 缓存控制\n    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\n    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n    // webjars 配置\n    if (!registry.hasMappingForPattern(\"/webjars/**\")) {\n        customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\")\n                                             .addResourceLocations(\"classpath:/META-INF/resources/webjars/\")\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    }\n    // 静态资源配置\n    String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n    if (!registry.hasMappingForPattern(staticPathPattern)) {\n        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)\n                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))\n                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));\n    }\n}\n~~~\n\n读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；\n\n\n\n> 3、什么是webjars？\n\nWebjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。\n\n使用SpringBoot需要使用Webjars，我们可以去搜索一下：\n\n网站：https://www.webjars.org \n\n要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！\n\n~~~xml\n<dependency>\n    <groupId>org.webjars</groupId>\n    <artifactId>jquery</artifactId>\n    <version>3.4.1</version>\n</dependency>\n~~~\n\n* 导入完毕，查看webjars目录结构，并访问Jquery.js文件！\n\n![image-20220305092535179](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220305092535179.png)\n\n访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.4.1/jquery.js\n\n![image-20220305092650355](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220305092650355.png)\n\n\n\n>4、第二种静态资源映射规律\n\n1. 在springboot，我们可以使用一下方式处理静态数据\n   * webjars  `localhost:8080/webjars/`\n   * public,static,/**,resources `localhost:8080/`\n\n2. 优先级：resources>static(默认)>public \n\n\n\n> 5、自定义静态资源路径\n\n我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；\n\n~~~properties\nspring.resources.static-locations=classpath:/coding/,classpath:/koko/\n~~~\n\n一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！\n\n\n\n> 6、拓展：网站图标说明(-)\n\n与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。\n\n1、关闭SpringBoot默认图标\n\n~~~properties\n#关闭默认图标\nspring.mvc.favicon.enabled=false\n~~~\n\n2、自己放一个图标在静态资源目录下，我放在 public 目录下\n\n3、清除浏览器缓存！刷新网页，发现图标已经变成自己的了！\n\n注：maven中的spring-boot-starter-parent的版本要低才行，已经被淘汰（了解即可）\n\n\n\n### 6.2 Thymeleaf\n\n> 1、模板引擎介绍\n\n前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。\n\njsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，**他现在默认是不支持jsp的**。\n\n那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？\n\n**SpringBoot推荐你可以来使用模板引擎：**\n\n模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：\n\n![image-20220305094354752](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220305094354752.png)\n\n模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。\n\n我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。\n\n\n\n> 2、引入Thymeleaf\n\n怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：\n\nThymeleaf 官网：https://www.thymeleaf.org/\n\nThymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf\n\nSpring官方文档：找到我们对应的版本\n\nhttps://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter \n\n找到对应的pom依赖：可以适当点进源码看下本来的包！\n\n~~~xml\n<!--thymeleaf-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n~~~\n\nMaven会自动下载jar包，我们可以去看下下载的东西；\n\n![image-20220305094518743](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220305094518743.png)\n\n\n\n> 3、测试\n\n1、编写一个indexController\n\n```java\npackage com.koko.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class indexController {\n\n    @RequestMapping(\"/h1\")\n    public String test01(Model model){\n        //存数据\n        model.addAttribute(\"msg\",\"Hello,Thymeleaf\");\n        //classpath:/templates/index.html\n        return \"index\";\n    }\n\n}\n```\n\n2、编写一个测试页面  index.html 放在 templates 目录下\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>koko</title>\n</head>\n<body>\n<h1>测试页面</h1>\n\n<!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样-->\n<div th:text=\"${msg}\"></div>\n\n</body>\n</html>\n```\n\n3、启动项目请求测试\n\n![image-20220305094732925](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220305094732925.png)\n\n\n\n> **4、Thymeleaf的使用语法**\n\n**1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！**\n\n![image-20220305094921146](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220305094921146.png)\n\n**2、我们能写哪些表达式呢？**\n\n~~~properties\nSimple expressions:（表达式语法）\nVariable Expressions: ${...}：获取变量值；OGNL；\n    1）、获取对象的属性、调用方法\n    2）、使用内置的基本对象：#18\n         #ctx : the context object.\n         #vars: the context variables.\n         #locale : the context locale.\n         #request : (only in Web Contexts) the HttpServletRequest object.\n         #response : (only in Web Contexts) the HttpServletResponse object.\n         #session : (only in Web Contexts) the HttpSession object.\n         #servletContext : (only in Web Contexts) the ServletContext object.\n\n    3）、内置的一些工具对象：\n　　　　　　#execInfo : information about the template being processed.\n　　　　　　#uris : methods for escaping parts of URLs/URIs\n　　　　　　#conversions : methods for executing the configured conversion service (if any).\n　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.\n　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.\n　　　　　　#numbers : methods for formatting numeric objects.\n　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.\n　　　　　　#objects : methods for objects in general.\n　　　　　　#bools : methods for boolean evaluation.\n　　　　　　#arrays : methods for arrays.\n　　　　　　#lists : methods for lists.\n　　　　　　#sets : methods for sets.\n　　　　　　#maps : methods for maps.\n　　　　　　#aggregates : methods for creating aggregates on arrays or collections.\n==================================================================================\n\n  Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；\n  Message Expressions: #{...}：获取国际化内容\n  Link URL Expressions: @{...}：定义URL；\n  Fragment Expressions: ~{...}：片段引用表达式\n\nLiterals（字面量）\n      Text literals: \'one text\' , \'Another one!\' ,…\n      Number literals: 0 , 34 , 3.0 , 12.3 ,…\n      Boolean literals: true , false\n      Null literal: null\n      Literal tokens: one , sometext , main ,…\n      \nText operations:（文本操作）\n    String concatenation: +\n    Literal substitutions: |The name is ${name}|\n    \nArithmetic operations:（数学运算）\n    Binary operators: + , - , * , / , %\n    Minus sign (unary operator): -\n    \nBoolean operations:（布尔运算）\n    Binary operators: and , or\n    Boolean negation (unary operator): ! , not\n    \nComparisons and equality:（比较运算）\n    Comparators: > , < , >= , <= ( gt , lt , ge , le )\n    Equality operators: == , != ( eq , ne )\n    \nConditional operators:条件运算（三元运算符）\n    If-then: (if) ? (then)\n    If-then-else: (if) ? (then) : (else)\n    Default: (value) ?: (defaultvalue)\n    \nSpecial tokens:\n    No-Operation: _\n~~~\n\n\n\n> 5、练习测试：\n\n1、 indexController\n\n```java\n@RequestMapping(\"/t2\")\npublic String test2(Map<String,Object> map){\n    //存入数据\n    map.put(\"msg\",\"<h1>Hello</h1>\");\n    map.put(\"users\", Arrays.asList(\"koko01\",\"koko02\"));\n    //classpath:/templates/test.html\n    return \"index\";\n}\n```\n\n2、index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>koko</title>\n</head>\n<body>\n<h1>测试页面</h1>\n\n<div th:text=\"${msg}\"></div>\n<!--不转义-->\n<div th:utext=\"${msg}\"></div>\n\n<!--遍历数据-->\n<!--th:each每次遍历都会生成当前这个标签：官网#9-->\n<h4 th:each=\"user :${users}\" th:text=\"${user}\"></h4>\n\n<h4>\n    <!--行内写法：官网#12-->\n    <span th:each=\"user:${users}\">[[${user}]]</span>\n</h4>\n\n</body>\n</html>\n```\n\n3、启动项目测试！\n\n![image-20220305095352725](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220305095352725.png)\n\n**我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！**\n\n\n\n### 6.3 MVC自动配置原理\n\n> 1、学习网站\n\n[狂神说SpringBoot12：MVC自动配置原理 (qq.com)](https://mp.weixin.qq.com/s?__biz=Mzg2NTAzMTExNg%3D%3D&chksm=ce610708f9168e1ee95b9f6135574cbea2d2b90ac3d0f7b6766d5260be0d711bbb73e678c6b5&idx=1&mid=2247483819&scene=21&sn=b9009aaa2a9af9d681a131b3a49d8848#wechat_redirect)\n\n在springboot中，有非常多的xxxx Configuration 帮助我们进行扩展配置，只要看到了这个定性，我们就要注意了！\n\n* 暂时看不懂，到时候回头来看\n\n\n\n### 6.4 开发网站心得\n\n> 1、如何写一个网站\n\n1. 前端搞定：页面长什么样：数据\n2. 设计数据库（数据库设计难点！）\n3. 前端让他能够自动运行，独立化工程\n4. 数据接口如何对接：json，对象 all in one！\n5. 前后端联调测试！\n\n> 2、小心得\n\n1. 有一套自己熟悉的后台模板：工作必要！——>x-admin\n2. 前端界面：至少自己能够通过前端框架，组合出来一个网站页面\n   	- index\n       		- about\n       		- blog\n           		- post\n           		- user\n3. 让这个页面能够独立运行！\n\n> 3、后面的学习内容\n\n* 整合JDBC\n* **整合Mybatis**\n* **整合Druid**\n* **Shiro：安全**\n* **Spring Security：安全**\n* 异步任务~，邮件发送，定时任务\n* Swagger\n* Dubbo + Zookeeper\n\n\n\n## 7. SpingBoot整合\n\n### 7.1 整合JDBC\n\n> 1、SpringData简介\n\n对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。\n\nSpring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。\n\nSping Data 官网：https://spring.io/projects/spring-data\n\n数据库相关的启动器 ：可以参考官方文档：\n\nhttps://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter\n\n> 2、测试\n\n1. 创建项目：springboot_04_jdbc\n\n![image-20220307103108945](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307103108945.png)\n\n2. 项目建好之后，发现自动帮我们导入了如下的启动器：\n\n~~~xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <scope>runtime</scope>\n</dependency>\n~~~\n\n3. application.yml配置文件连接数据库\n\n![image-20220307105758420](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307105758420.png)\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone=UTC解决时区的报错\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n4. 测试类测试\n\n```java\npackage com.koko.springboot_04_jdbc;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n@SpringBootTest\nclass Springboot04JdbcApplicationTests {\n\n    //DI注入数据源\n    @Autowired\n    DataSource dataSource;\n\n    @Test\n    public void contextLoads() throws SQLException {\n        //看一下默认数据源\n        System.out.println(dataSource.getClass());\n        //获得连接\n        Connection connection =   dataSource.getConnection();\n        System.out.println(connection);\n        //关闭连接\n        connection.close();\n    }\n\n}\n```\n\n![image-20220307103548468](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307103548468.png)\n\n5. 小结\n\nSpring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源\n\n**HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；**\n\n**可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。**\n\n关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate\n\n> 3、JDBCTemplate\n\n1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；\n\n2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。\n\n3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。\n\n4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用\n\n5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类\n\n**JdbcTemplate主要提供以下几类方法：**\n\n- execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；\n- update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；\n- query方法及queryForXXX方法：用于执行查询相关语句；\n- call方法：用于执行存储过程、函数相关语句。\n\n> 4、测试\n\n1. JdbcController类\n\n![image-20220307110053917](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307110053917.png)\n\n```java\npackage com.koko.Controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\nimport java.util.Map;\n\n\n@RestController\npublic class JdbcController {\n\n    @Autowired\n    JdbcTemplate jdbcTemplate;\n\n    @GetMapping(\"/list\")\n    public List<Map<String, Object>> userList(){\n        String sql = \"select * from user\";\n        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);\n        return maps;\n    }\n\n    //新增一个用户\n    @GetMapping(\"/add\")\n    public String addUser(){\n        //插入语句，注意时间问题\n        String sql = \"insert into user(id, name,pwd)\" +\n                \" values (4,\'赵六\',\'123\')\";\n        jdbcTemplate.update(sql);\n\n        //查询\n        return \"add_ok\";\n    }\n\n    //修改用户信息\n    @GetMapping(\"/update/{id}\")\n    public String updateUser(@PathVariable(\"id\") int id){\n        //插入语句，注意时间问题\n        String sql = \"update user set name=?,pwd=? where id=\"+id;\n\n        //封装\n        Object[] objects = new Object[2];\n        objects[0]=\"小明\";\n        objects[1]=\"123456\";\n        jdbcTemplate.update(sql,objects);\n\n        //查询\n        return \"update_ok\";\n    }\n\n    //删除用户\n    @GetMapping(\"/delete/{id}\")\n    public String deleteUser(@PathVariable(\"id\") int id){\n        //插入语句，注意时间问题\n        String sql = \"delete from user where id = ?\";\n        jdbcTemplate.update(sql,id);\n\n        //查询\n        return \"delete_ok\";\n    }\n\n}\n```\n\n* 进行测试即可完成CURD的基本操作！\n\n\n\n### 7.2 整合Druid\n\n> 1、Druid简介\n\nJava程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。\n\nDruid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。\n\nDruid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。\n\nDruid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。\n\nSpring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。\n\nGithub地址：https://github.com/alibaba/druid/\n\n**com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：**\n\n![image-20220307114416400](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307114416400.png)\n\n![image-20220307114427303](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307114427303.png)\n\n![image-20220307114437419](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307114437419.png)\n\n> 2、配置数据源\n\n1. 添加上 Druid 数据源依赖\n\n```xml\n<!--druid-->\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.2.8</version>\n</dependency>\n```\n\n2. application.yml\n\n~~~yml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    #?serverTimezone=UTC解决时区的报错\n    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源\n\n	#拓展功能\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n\n	#特定功能\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n~~~\n\n3. 导入Log4j 的依赖\n\n```xml\n<!--log4j-->\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n```\n\n4. DruidConfig配置类\n\n现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；\n\n```java\npackage com.koko.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport javax.sql.DataSource;\n\n@Configuration\npublic class DruidConfig {\n\n    /*\n       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建\n       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效\n       @ConfigurationProperties(prefix = \"spring.datasource\")：作用就是将 全局配置文件中\n       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中\n     */\n    @ConfigurationProperties(prefix = \"spring.datasource\")\n    @Bean\n    public DataSource druidDataSource() {\n        return new DruidDataSource();\n    }\n\n}\n```\n\n5. 测试类\n\n```java\npackage com.koko.springboot_04_jdbc;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\n@SpringBootTest\nclass Springboot04JdbcApplicationTests {\n\n    //DI注入数据源\n    @Autowired\n    DataSource dataSource;\n\n    @Test\n    public void contextLoads() throws SQLException {\n        //看一下默认数据源\n        System.out.println(dataSource.getClass());\n\n        //获得连接\n        Connection connection =   dataSource.getConnection();\n        System.out.println(connection);\n\n        DruidDataSource druidDataSource = (DruidDataSource) dataSource;\n        System.out.println(\"druidDataSource 数据源最大连接数：\" + druidDataSource.getMaxActive());\n        System.out.println(\"druidDataSource 数据源初始化连接数：\" + druidDataSource.getInitialSize());\n\n        //关闭连接\n        connection.close();\n    }\n\n}\n```\n\n![image-20220307113339964](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307113339964.png)\n\n>3、配置Druid数据源监控\n\nDruid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。\n\n所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；\n\n1. Druidconfig\n\n```java\n//配置 Druid 监控管理后台的Servlet；\n//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式\n@Bean\npublic ServletRegistrationBean statViewServlet() {\n    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\");\n\n    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet\n    // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到\n    Map<String, String> initParams = new HashMap<>();\n    initParams.put(\"loginUsername\", \"admin\"); //后台管理界面的登录账号\n    initParams.put(\"loginPassword\", \"123456\"); //后台管理界面的登录密码\n\n    //后台允许谁可以访问\n    //initParams.put(\"allow\", \"localhost\")：表示只有本机可以访问\n    //initParams.put(\"allow\", \"\")：为空或者为null时，表示允许所有访问\n    initParams.put(\"allow\", \"\");\n    //deny：Druid 后台拒绝谁访问\n    //initParams.put(\"kuangshen\", \"192.168.1.20\");表示禁止此ip访问\n\n    //设置初始化参数\n    bean.setInitParameters(initParams);\n    return bean;\n}\n```\n\n2. 测试\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307122434447.png\" alt=\"image-20220307122434447\" style=\"zoom:67%;\" />\n\n![image-20220307122413869](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307122413869.png)\n\n> 4、配置 Druid web 监控 filter 过滤器\n\n1. Druidconfig\n\n```java\n//配置 Druid 监控 之  web 监控的 filter\n//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计\n@Bean\npublic FilterRegistrationBean webStatFilter() {\n    FilterRegistrationBean bean = new FilterRegistrationBean();\n    bean.setFilter(new WebStatFilter());\n\n    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计\n    Map<String, String> initParams = new HashMap<>();\n    initParams.put(\"exclusions\", \"*.js,*.css,/druid/*,/jdbc/*\");\n    bean.setInitParameters(initParams);\n\n    //\"/*\" 表示过滤所有请求\n    bean.setUrlPatterns(Arrays.asList(\"/*\"));\n    return bean;\n}\n```\n\n* 平时在工作中，按需求进行配置即可，主要用作监控！\n\n\n\n### 7.3 整合Mybatis\n\n> 1、简介\n\n官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\n\nMaven仓库地址：https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1\n\n> 2、测试\n\n1. 导入 MyBatis 所需要的依赖\n\n```xml\n<!--mybatis整合依赖-->\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.2.2</version>\n</dependency>\n```\n\n2. application.yml\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\n    driver-class-name: com.mysql.cj.jdbc.Driver\nmybatis:\n  type-aliases-package: com.koko.pojo\n  mapper-locations: classpath:mybatis/mapper/*.xml\n```\n\n* 连接上数据库\n\n3. User实体类\n\n```java\npackage com.koko.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@AllArgsConstructor\n@Data\n@NoArgsConstructor\npublic class User {\n\n    private int id;\n    private String name;\n    private String pwd;\n\n}\n```\n\n4. UserMapper类\n\n```java\npackage com.koko.mapper;\n\nimport com.koko.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n//@Mapper : 表示本类是一个 MyBatis 的 Mapper\n@Mapper\n@Repository\npublic interface UserMapper {\n\n    //获取所有员工信息\n    List<User> getUser();\n\n    //查询员工\n    User getUserById(Integer id);\n\n    //增加员工\n    int addUser(User user);\n\n    //修改员工\n    int updateUser(User user);\n\n    //删除员工\n    int deleteUser(int id);\n\n}\n```\n\n5. UserMapper.xml\n\n**对应的Mapper映射文件**\n\n![image-20220307155324539](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220307155324539.png)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.koko.mapper.UserMapper\">\n\n    <select id=\"getUser\" resultType=\"User\">\n       select * from user;\n    </select>\n\n    <select id=\"getUserById\" resultType=\"User\" parameterType=\"int\">\n       select * from user where id = #{id};\n    </select>\n\n    <insert id=\"addUser\" parameterType=\"User\">\n        insert into user (id,name,pwd) values (#{id},#{name},#{pwd})\n    </insert>\n\n    <update id=\"updateUser\" parameterType=\"User\">\n        update user set name=#{name},pwd=#{pwd} where id=#{id}\n    </update>\n\n    <delete id=\"deleteUser\" parameterType=\"int\">\n        delete from user where id = #{id}\n    </delete>\n\n</mapper>\n```\n\n6. maven配置资源过滤问题\n\n~~~xml\n<resources>\n    <resource>\n        <directory>src/main/java</directory>\n        <includes>\n            <include>**/*.xml</include>\n        </includes>\n        <filtering>true</filtering>\n    </resource>\n</resources>\n~~~\n\n7. UserController\n\n```java\npackage com.koko.controller;\n\nimport com.koko.mapper.UserMapper;\nimport com.koko.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n@RestController\npublic class UserController {\n\n    @Autowired\n    UserMapper userMapper;\n\n    @GetMapping(\"/getUser\")\n    public List<User> getUser(){\n        return userMapper.getUser();\n    }\n\n    @GetMapping(\"/getUserById/{id}\")\n    public User getUserById(@PathVariable(\"id\")int id){\n        return userMapper.getUserById(id);\n    }\n\n    @GetMapping(\"/addUser\")\n    public String addUser(){\n        userMapper.addUser(new User(5,\"小小\",\"123456\"));\n        return \"ok\";\n    }\n\n    @GetMapping(\"/updateUser\")\n    public String updateUser(){\n        userMapper.updateUser(new User(5,\"大大\",\"123456\"));\n        return \"ok\";\n    }\n\n    @GetMapping(\"/deleteUser\")\n    public String deleteUser(){\n        userMapper.deleteUser(5);\n        return \"ok\";\n    }\n\n}\n```\n\n> 8、上线测试！\n\n\n\n## 8. SpringSecurity\n\n### 8.1 SpringSecurity简介\n\n> 1、web安全简介\n\n在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。\n\n市面上存在比较有名的：Shiro，Spring Security ！\n\n\n\n> 2、测试\n\n1. 导入项目的web模板和thymeleaf模板\n\n```xml\n<!--thymeleaf-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n```\n\n2. 导入静态模板\n\n![image-20220308095552271](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308095552271.png)\n\n3. RouterController控制跳转\n\n```java\npackage com.koko.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class RouterController {\n\n    @RequestMapping({\"/\",\"/index\"})\n    public String index(){\n        return \"index\";\n    }\n\n    @RequestMapping(\"/toLogin\")\n    public String toLogin(){\n        return \"views/login\";\n    }\n\n    @RequestMapping(\"/level1/{id}\")\n    public String level1(@PathVariable(\"id\") int id){\n        return \"views/level1/\"+id;\n    }\n\n    @RequestMapping(\"/level2/{id}\")\n    public String level2(@PathVariable(\"id\") int id){\n        return \"views/level2/\"+id;\n    }\n\n    @RequestMapping(\"/level3/{id}\")\n    public String level3(@PathVariable(\"id\") int id){\n        return \"views/level3/\"+id;\n    }\n\n}\n```\n\n4. 测试\n\n![image-20220308095703375](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308095703375.png)\n\n\n\n> 3、Spring Security概述\n\nSpring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！\n\n记住几个类：\n\n- WebSecurityConfigurerAdapter：自定义Security策略\n- AuthenticationManagerBuilder：自定义认证策略\n- @EnableWebSecurity：开启WebSecurity模式\n\nSpring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。\n\n**“认证”（Authentication）**\n\n身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。\n\n身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。\n\n **“授权” （Authorization）**\n\n授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。\n\n这个概念是通用的，而不是只在Spring Security 中存在。\n\n\n\n### 8.2 认证和授权\n\n> 1、测试\n\n目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能\n\n1. 引入 Spring Security 模块\n\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n\n2. 编写 Spring Security 配置类\n\n```java\npackage com.koko.config;\n\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@EnableWebSecurity // 开启WebSecurity模式\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    //1、授权\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        // 定制请求的授权规则\n        // 首页所有人可以访问\n        http.authorizeRequests().antMatchers(\"/\").permitAll()\n                .antMatchers(\"/level1/**\").hasRole(\"vip1\")\n                .antMatchers(\"/level2/**\").hasRole(\"vip2\")\n                .antMatchers(\"/level3/**\").hasRole(\"vip3\");\n\n        // 1-1、开启自动配置的登录功能\n        // /login 请求来到登录页\n        // /login?error 重定向到这里表示登录失败\n        http.formLogin();\n    }\n\n    //2、认证\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        //在内存中定义，也可以在jdbc中去拿....\n        //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。\n        //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密\n        //2-1、spring security 官方推荐的是使用bcrypt加密方式。\n\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())\n                .withUser(\"koko1\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\")\n                .and()\n                .withUser(\"koko2\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\")\n                .and()\n                .withUser(\"koko3\").password(new BCryptPasswordEncoder().encode(\"123456\")).roles(\"vip1\",\"vip2\",\"vip3\");\n    }\n\n}\n```\n\n3. 测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！\n\n\n\n### 8.3 权限控制和注销\n\n> 1、测试\n\n1. 导入springsecurity5依赖\n\n```xml\n<!--springsecurity5-->\n<dependency>\n    <groupId>org.thymeleaf.extras</groupId>\n    <artifactId>thymeleaf-extras-springsecurity5</artifactId>\n    <version>3.0.4.RELEASE</version>\n</dependency>\n```\n\n2. 修改前端页面index.html\n\n* 导入命名空间\n\n```properties\nxmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\"\n```\n\n* 修改导航栏，增加认证判断\n\n```html\n<!--登录注销-->\n<div class=\"right menu\">\n\n   <!--如果未登录-->\n   <div sec:authorize=\"!isAuthenticated()\">\n       <a class=\"item\" th:href=\"@{/login}\">\n           <i class=\"address card icon\"></i> 登录\n       </a>\n   </div>\n\n   <!--如果已登录-->\n   <div sec:authorize=\"isAuthenticated()\">\n       <a class=\"item\">\n           <i class=\"address card icon\"></i>\n          用户名：<span sec:authentication=\"principal.username\"></span>\n          角色：<span sec:authentication=\"principal.authorities\"></span>\n       </a>\n   </div>\n\n   <div sec:authorize=\"isAuthenticated()\">\n       <a class=\"item\" th:href=\"@{/logout}\">\n           <i class=\"address card icon\"></i> 注销\n       </a>\n   </div>\n</div>\n```\n\n3. SecurityConfig配置类\n\n```java\n//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求\nhttp.csrf().disable();\n// .logoutSuccessUrl(\"/\"); 注销成功来到首页\nhttp.logout().logoutSuccessUrl(\"/\");\n```\n\n4. index.html\n\n* 角色功能块认证\n\n```html\n<!-- sec:authorize=\"hasRole(\'vip1\')\" -->\n<div class=\"column\" sec:authorize=\"hasRole(\'vip1\')\">\n   <div class=\"ui raised segment\">\n       <div class=\"ui\">\n           <div class=\"content\">\n               <h5 class=\"content\">Level 1</h5>\n               <hr>\n               <div><a th:href=\"@{/level1/1}\"><i class=\"bullhorn icon\"></i> Level-1-1</a></div>\n               <div><a th:href=\"@{/level1/2}\"><i class=\"bullhorn icon\"></i> Level-1-2</a></div>\n               <div><a th:href=\"@{/level1/3}\"><i class=\"bullhorn icon\"></i> Level-1-3</a></div>\n           </div>\n       </div>\n   </div>\n</div>\n\n<div class=\"column\" sec:authorize=\"hasRole(\'vip2\')\">\n   <div class=\"ui raised segment\">\n       <div class=\"ui\">\n           <div class=\"content\">\n               <h5 class=\"content\">Level 2</h5>\n               <hr>\n               <div><a th:href=\"@{/level2/1}\"><i class=\"bullhorn icon\"></i> Level-2-1</a></div>\n               <div><a th:href=\"@{/level2/2}\"><i class=\"bullhorn icon\"></i> Level-2-2</a></div>\n               <div><a th:href=\"@{/level2/3}\"><i class=\"bullhorn icon\"></i> Level-2-3</a></div>\n           </div>\n       </div>\n   </div>\n</div>\n\n<div class=\"column\" sec:authorize=\"hasRole(\'vip3\')\">\n   <div class=\"ui raised segment\">\n       <div class=\"ui\">\n           <div class=\"content\">\n               <h5 class=\"content\">Level 3</h5>\n               <hr>\n               <div><a th:href=\"@{/level3/1}\"><i class=\"bullhorn icon\"></i> Level-3-1</a></div>\n               <div><a th:href=\"@{/level3/2}\"><i class=\"bullhorn icon\"></i> Level-3-2</a></div>\n               <div><a th:href=\"@{/level3/3}\"><i class=\"bullhorn icon\"></i> Level-3-3</a></div>\n           </div>\n       </div>\n   </div>\n</div>\n```\n\n5. 测试\n\n* vip1\n\n![image-20220308143706147](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308143706147.png)\n\n* vip2\n\n![image-20220308143735450](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308143735450.png)\n\n* vip3\n\n![image-20220308143758640](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308143758640.png)\n\n* 权限控制和注销搞定！\n\n\n\n### 8.4 记住我及首页定制\n\n> 1、“记住我”功能实现\n\n1. SecurityConfig配置类\n\n* 在SecurityConfig配置类中的configure方法中定义方法\n\n```java\n//定制请求的授权规则\n@Override\nprotected void configure(HttpSecurity http) throws Exception {\n   //记住我\n   http.rememberMe();\n}\n```\n\n2. 运行测试\n\n* 登录时点击记住我功能，之后关闭浏览器，然后重新打开浏览器访问，发现用户依旧存在，因为spring security帮我们将登录信息存储在Cookie中14天！！！\n* 点击注销时，spring security 帮我们自动删除了这个 Cookie！\n\n\n\n> 2、定制登录页功能实现\n\n1. index.html\n\n* 将登录界面跳转的路径更改\n\n```html\n<!--如果未登录-->\n<div sec:authorize=\"!isAuthenticated()\">\n    <a class=\"item\" th:href=\"@{/toLogin}\">\n        <i class=\"address card icon\"></i> 登录\n    </a>\n</div>\n```\n\n2. login.html请求\n\n```html\n<a class=\"item\" th:href=\"@{/toLogin}\">\n    <i class=\"address card icon\"></i> 登录\n</a>\n```\n\n* 账号密码部分\n\n```html\n<form th:action=\"@{/login}\" method=\"post\">\n    <div class=\"field\">\n        <label>Username</label>\n        <div class=\"ui left icon input\">\n            <input type=\"text\" placeholder=\"Username\" name=\"username\">\n            <i class=\"user icon\"></i>\n        </div>\n    </div>\n    <div class=\"field\">\n        <label>Password</label>\n        <div class=\"ui left icon input\">\n            <input type=\"password\" name=\"password\">\n            <i class=\"lock icon\"></i>\n        </div>\n    </div>\n    <input type=\"submit\" class=\"ui blue submit button\"/>\n    <div class=\"field\">\n        <input type=\"checkbox\" name=\"remember\"> 记住我\n    </div>\n</form>\n```\n\n3. SecurityConfig配置类\n\n```java\n//1、开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！\n// /login 请求来到登录页\n// /login?error 重定向到这里表示登录失败\nhttp.formLogin()\n  .usernameParameter(\"username\")\n  .passwordParameter(\"password\")\n  .loginPage(\"/toLogin\")\n  .loginProcessingUrl(\"/login\"); // 登陆表单提交请求\n\n//4、定制记住我的参数！\nhttp.rememberMe().rememberMeParameter(\"remember\");\n```\n\n4. 测试\n\n* 登录界面\n\n![image-20220308152709796](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308152709796.png)\n\n* 进入首页\n\n![image-20220308152728718](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308152728718.png)\n\n\n\n## 9. Shiro\n\n### 9.1 Shiro简介\n\n> 1、什么是Shiro?\n\n* Apache Shiro是一个Java 的安全(权限)框架。\n* Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境。\n* Shiro可以完成，认证，授权，加密，会话管理，Web集成，缓存等.\n* 下载地址: http://shiro.apache.org/\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/20201103221329444.png)\n\n\n\n> 2、shiro的功能\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/20201103223432234.png)\n\n* Authentication: 身份认证、登录，验证用户是不是拥有相应的身份;\n* Authorization:授权,即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能否进行什么操作，如:验证某个用户是否拥有某个角色，或者细粒度的验证某个用户对某个资源是否具有某个权限!\n* Session Manager: 会话管理，即用户登录后就是第1次会话，在没有退出之前，它的所有信息都在会话中;会话可以是普通的JavaSE环境，也可以是Web环境;\n* Cryptography: 加密,保护数据的安全性，如密码加密存储到数据库中，而不是明文存储;\n* Web Support: Web支持，可以非常容易的集成到Web环境;\n* Caching: 缓存，比如用户登录后，其用户信息，拥有的角色、权限不必每次去查,这样可以提高效率\n* Concurrency: Shiro支持多线程应用的并发验证，即，如在一个线程中开启另-一个线程,能把权限自动的传\n  播过去\n* Testing:提供测试支持;\n* RunAs:允许一个用户假装为另-一个用户(如果他们允许)的身份进行访问;\n* Remember Me:记住我，这个是非常常见的功能，即一次登录后， 下次再来的话不用登录了\n\n\n\n> 3、Shiro架构\n\n1. 外部结构\n\n从外部来看`Shiro`,即从应用程序角度来观察如何使用`shiro`完成工作：\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/20201103223750298.png)\n\n* subject: 应用代码直接交互的对象是Subject, 也就是说Shiro的对外API核心就是Subject, Subject代表了当前的用户，这个用户不-定是一个具体的人，与当前应用交互的任何东西都是Subject,如网络爬虫，机器人等，与Subject的所有交互都会委托给SecurityManager; Subject其实是一一个门面， SecurityManageer 才是\n  实际的执行者\n* SecurityManager: 安全管理器，即所有与安全有关的操作都会与SercurityManager交互, 并且它管理着所有的Subject,可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC的DispatcherServlet的角色\n* Realm: Shiro从Realm获取安全数据 (如用户,角色，权限)，就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较，来确定用户的身份是否合法;也需要从Realm得到用户相应的角色、权限，进行验证用户的操作是否能够进行，可以把Realm看DataSource;\n\n2. 内部结构\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/20201103224134417.png)\n\n* Subject: 任何可以与应用交互的用户;\n* Security Manager:相当于SpringMVC中的DispatcherSerlet; 是Shiro的心脏， 所有具体的交互都通过Security Manager进行控制，它管理者所有的Subject, 且负责进行认证,授权，会话，及缓存的管理。\n* Authenticator:负责Subject认证， 是-一个扩展点，可以自定义实现;可以使用认证策略(Authentication Strategy)，即什么情况下算用户认证通过了;\n* Authorizer:授权器，即访问控制器，用来决定主体是否有权限进行相应的操作;即控制着用户能访问应用中\n  的那些功能;\n* Realm: 可以有-一个或者多个的realm, 可以认为是安全实体数据源，即用于获取安全实体的，可以用JDBC实现，也可以是内存实现等等，由用户提供;所以- -般在应用中都需要实现自己的realm\n* SessionManager:管理Session生 命周期的组件,而Shiro并不仅仅可以用在Web环境，也可以用在普通的JavaSE环境中\n* CacheManager: 缓存控制器，来管理如用户，角色，权限等缓存的;因为这些数据基本上很少改变,放到缓存中后可以提高访问的性能;\n* Cryptography:密码模块，Shiro 提高了一些常见的加密组件用于密码加密， 解密等\n\n\n\n### 9.2 Shiro快速开始\n\n> 1、准备工作\n\n官方项目路径：[mirrors / apache / shiro · GitCode](https://gitcode.net/mirrors/apache/shiro?utm_source=csdn_github_accelerator)\n\n1. 创建一个普通的maven项目，然后删除`src`目录，创建一个新model——>hello-shiro\n\n![image-20220308160221697](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308160221697.png)\n\n2. pom.xml\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/20201103233846303.png)\n\n~~~xml\n<dependencies>\n        <dependency>\n            <groupId>org.apache.shiro</groupId>\n            <artifactId>shiro-core</artifactId>\n            <version>1.4.1</version>\n        </dependency>\n\n        <!-- configure logging -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>jcl-over-slf4j</artifactId>\n            <version>1.7.21</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.21</version>\n        </dependency>\n\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n</dependencies>\n~~~\n\n3. log4j.properties 和 shiro.ini\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/20201103234457922.png)\n\n* log4j.properties\n\n```properties\nlog4j.rootLogger=INFO, stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n\n\n# General Apache libraries\nlog4j.logger.org.apache=WARN\n\n# Spring\nlog4j.logger.org.springframework=WARN\n\n# Default Shiro logging\nlog4j.logger.org.apache.shiro=INFO\n\n# Disable verbose logging\nlog4j.logger.org.apache.shiro.util.ThreadContext=WARN\nlog4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN\n```\n\n* shiro.ini\n\n```ini\n[users]\n# user \'root\' with password \'secret\' and the \'admin\' role\nroot = secret, admin\n# user \'guest\' with the password \'guest\' and the \'guest\' role\nguest = guest, guest\n# user \'presidentskroob\' with password \'12345\' (\"That\'s the same combination on\n# my luggage!!!\" ;)), and role \'president\'\npresidentskroob = 12345, president\n# user \'darkhelmet\' with password \'ludicrousspeed\' and roles \'darklord\' and \'schwartz\'\ndarkhelmet = ludicrousspeed, darklord, schwartz\n# user \'lonestarr\' with password \'vespa\' and roles \'goodguy\' and \'schwartz\'\nlonestarr = vespa, goodguy, schwartz\n\n# -----------------------------------------------------------------------------\n# Roles with assigned permissions\n#\n# Each line conforms to the format defined in the\n# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc\n# -----------------------------------------------------------------------------\n[roles]\n# \'admin\' role has all permissions, indicated by the wildcard \'*\'\nadmin = *\n# The \'schwartz\' role can do anything (*) with any lightsaber:\nschwartz = lightsaber:*\n# The \'goodguy\' role is allowed to \'drive\' (action) the winnebago (type) with\n# license plate \'eagle5\' (instance specific id)\ngoodguy = winnebago:drive:eagle5\n```\n\n4. java包下的Quickstart运行类\n\n```java\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.Factory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class Quickstart {\n\n    private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);\n\n\n    public static void main(String[] args) {\n\n        //可以删除\n        Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n        SecurityManager securityManager = factory.getInstance();\n        SecurityUtils.setSecurityManager(securityManager);\n\n        // get the currently executing user:\n        //获取当前用户的对象 Subject\n        Subject currentUser = SecurityUtils.getSubject();\n\n        // 通过当前用户拿到Session\n        Session session = currentUser.getSession();\n\n        session.setAttribute(\"someKey\", \"aValue\");\n        String value = (String) session.getAttribute(\"someKey\");\n        if (value.equals(\"aValue\")) {\n            log.info(\"Retrieved the correct value! [\" + value + \"]\");\n        }\n\n        // 判断当前的用户是否被认证\n        if (!currentUser.isAuthenticated()) {\n\n            //Token : 令牌，没有获取，随机\n            UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\");\n            token.setRememberMe(true); //设置记住我\n\n            try {\n                currentUser.login(token); //执行了登录操作~\n            } catch (UnknownAccountException uae) {\n                log.info(\"There is no user with username of \" + token.getPrincipal());\n            } catch (IncorrectCredentialsException ice) {\n                log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\");\n            } catch (LockedAccountException lae) {\n                log.info(\"The account for username \" + token.getPrincipal() + \" is locked.  \" +\n                        \"Please contact your administrator to unlock it.\");\n            }\n            // ... catch more exceptions here (maybe custom ones specific to your application?\n            catch (AuthenticationException ae) {\n                //unexpected condition?  error?\n            }\n        }\n\n        //say who they are:\n        //print their identifying principal (in this case, a username):\n        log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\");\n\n        //test a role:\n        if (currentUser.hasRole(\"schwartz\")) {\n            log.info(\"May the Schwartz be with you!\");\n        } else {\n            log.info(\"Hello, mere mortal.\");\n        }\n\n        //粗粒度\n        //test a typed permission (not instance-level)\n        if (currentUser.isPermitted(\"lightsaber:wield\")) {\n            log.info(\"You may use a lightsaber ring.  Use it wisely.\");\n        } else {\n            log.info(\"Sorry, lightsaber rings are for schwartz masters only.\");\n        }\n\n        //细粒度\n        //a (very powerful) Instance Level permission:\n        if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) {\n            log.info(\"You are permitted to \'drive\' the winnebago with license plate (id) \'eagle5\'.  \" +\n                    \"Here are the keys - have fun!\");\n        } else {\n            log.info(\"Sorry, you aren\'t allowed to drive the \'eagle5\' winnebago!\");\n        }\n\n        //注销\n        //all done - log out!\n        currentUser.logout();\n\n        //结束启动\n        System.exit(0);\n    }\n}\n```\n\n5. 运行结果\n\n![image-20220308160652254](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308160652254.png)\n\n\n\n> 2、Quickstart类简述原理\n\n* 将在SpringBoot中集成~\n\n~~~java\n//1、获取当前用户的对象 Subject\nSubject currentUser = SecurityUtils.getSubject();\n//2、通过当前用户拿到Session\nSession session = currentUser.getSession();\n//3、判断当前的用户是否被认证\ncurrentUser.isAuthenticated()\n//4、获得当前用户的认证\ncurrentUser.getPrincipal()\n//5、当前用户是否有某个角色\ncurrentUser.hasRole(\"schwartz\")\n//6、根据不同的角色获取不同的权限\ncurrentUser.isPermitted(\"lightsaber:wield\")\n//7、注销\ncurrentUser.logout();\n~~~\n\n\n\n### 9.3 SpringBoot整合Shiro环境搭建\n\n> 1、基础配置\n\n1. 新建SpringBoot项目,勾选`web`和`thymeleaf`\n\n![image-20220308174850795](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308174850795.png)\n\n2. `templates`下新建`index.html`\n\n~~~html\n<!DOCTYPE html>\n<html lang=\"en\"\n      xmlns:th=\"https://www.thymeleaf.org\"\n      xmlns:shiro=\"https://www.thymeleaf.org/thymeleaf-extras-shiro\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>首页</h1>\n\n<p th:text=\"${msg}\"></p>\n\n</body>\n</html>\n~~~\n\n3. `controller`包下新建`MyController`\n\n~~~java\npackage com.koko.controller;\n\nimport org.apache.catalina.security.SecurityUtil;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.subject.Subject;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpSession;\n\n@Controller\npublic class MyController {\n\n    @RequestMapping({\"/\",\"/index\"})\n    public String toIndex(Model model){\n        model.addAttribute(\"msg\",\"hello,shiro\");\n        return \"index\";\n    }\n}\n~~~\n\n4. 测试\n\n![在这里插入图片描述](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/20201104093253194.png)\n\n> 2、测试\n\n1. shiro-spring的maven包\n\n```xml\n<!--shiro-->\n<dependency>\n    <groupId>org.apache.shiro</groupId>\n    <artifactId>shiro-spring</artifactId>\n    <version>1.4.1</version>\n</dependency>\n```\n\n2. 配置类\n\n![image-20220308175303217](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308175303217.png)\n\n* UserRealm\n\n```java\npackage com.koko.config;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\n//自定义的 UserRealm\npublic class UserRealm extends AuthorizingRealm {\n\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        System.out.println(\"执行了=>授权doGetAuthorizationInfo\");\n        return null;\n    }\n\n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        System.out.println(\"执行了=>认证doGetAuthenticationInfo\");\n        return null;\n    }\n}\n```\n\n* ShiroConfig\n\n```java\npackage com.koko.config;\n\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n@Configuration\npublic class ShiroConfig {\n\n    //ShiroFilterFactoryBean:3\n    @Bean\n    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n        //设置安全管理器\n        bean.setSecurityManager(defaultWebSecurityManager);\n\n        return bean;\n    }\n\n\n    //DefaultWebSecurityManager:2\n    @Bean(name=\"securityManager\")\n    public DefaultWebSecurityManager DefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        //关联UserRealm\n        securityManager.setRealm(userRealm);\n        return securityManager;\n    }\n\n\n    //创建 realm 对象:需要自定义类:1\n    @Bean\n    public UserRealm userRealm(){\n        return new UserRealm();\n    }\n\n}\n```\n\n3. 导入静态资源\n\n![image-20220308175417861](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308175417861.png)\n\n* add 和 update页面只有一个普通的h1标签\n\n* index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\"\n      xmlns:th=\"https://www.thymeleaf.org\"\n      xmlns:shiro=\"https://www.thymeleaf.org/thymeleaf-extras-shiro\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>首页</h1>\n\n<p th:text=\"${msg}\"></p>\n\n<a th:href=\"@{/user/add}\">add</a>\n<a th:href=\"@{/user/update}\">update</a>\n\n</body>\n</html>\n```\n\n4. MyController控制类\n\n```java\npackage com.koko.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\npublic class MyController {\n\n    @RequestMapping({\"/\",\"/index\"})\n    public String toIndex(Model model){\n        model.addAttribute(\"msg\",\"hello,Shiro\");\n        return \"index\";\n    }\n\n    @RequestMapping(\"/user/add\")\n    public String toAdd(Model model){\n        return \"user/add\";\n    }\n\n    @RequestMapping(\"/user/update\")\n    public String toUpdate(Model model){\n        return \"user/update\";\n    }\n\n}\n```\n\n5. 测试\n\n![image-20220308175623118](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220308175623118.png)\n\n* 可以正常地进行页面跳转！为后面做准备\n\n\n\n### 9.4 登录拦截\n\n> 1、具体实现\n\n1. ShiroConfig类\n\n* 在 ShiroFilterFactoryBean:3 方法中加入下面代码\n\n~~~java\n/*\n        * anon:无需认证就可以访问\n        * authc:必须认证了才能访问\n        * user:必须拥有 记住我 功能才能用\n        * perms:拥有对某个资源的权限才能访问\n        * role:拥有某个角色权限才能访问\n        * */\n\n//拦截\nMap<String,String> filterMap = new LinkedHashMap<>();\nfilterMap.put(\"/user/*\",\"authc\");\nbean.setFilterChainDefinitionMap(filterMap);\n\n//设置登录的请求\nbean.setLoginUrl(\"/toLogin\");\n~~~\n\n2. MyController类中添加跳转事务\n\n```java\n@RequestMapping(\"/toLogin\")\npublic String toLogin(){\n    return \"login\";\n}\n```\n\n3. 在templates包下添加login页面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>登录</h1>\n\n<hr>\n<form action=\"\">\n    <p>用户名: <input type=\"text\" name=\"username\"></p>\n    <p>密码: <input type=\"text\" name=\"password\"></p>\n    <p><input type=\"submit\"></p>\n</form>\n\n</body>\n</html>\n```\n\n4. 测试\n\n* 点击update时\n\n![image-20220309095604186](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309095604186.png)\n\n* 页面被拦截，回到登录页面\n\n![image-20220309095635639](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309095635639.png)\n\n\n\n### 9.5 用户认证\n\n> 1、实现流程\n\n1. UserRealm\n\n* 认证方法\n\n```java\n//认证\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    System.out.println(\"执行了=>认证doGetAuthenticationInfo\");\n\n    //取数据\n    String name=\"root\";\n    String password=\"123456\";\n\n    UsernamePasswordToken userToken = (UsernamePasswordToken) token;\n\n    if(!userToken.getUsername().equals(name)){\n        return null; //抛出异常 UnknownAccountException\n    }\n\n    //密码认证，shiro做~\n    return new SimpleAuthenticationInfo(\"\",password,\"\");\n}\n```\n\n2. MyController页面跳转类\n\n```java\n@RequestMapping(\"/login\")\npublic String login(String username,String password,Model model){\n    //获取当前的用户\n    Subject subject = SecurityUtils.getSubject();\n    //封装用户的登录信息\n    UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n    try{\n        subject.login(token);   //执行登录方法，如果没有异常就说明ok了\n        return \"index\";\n    }catch (UnknownAccountException e){\n        model.addAttribute(\"msg\",\"用户名错误\");\n        return \"login\";\n    }catch (IncorrectCredentialsException e){\n        model.addAttribute(\"msg\",\"密码错误\");\n        return \"login\";\n    }\n}\n```\n\n3. 更改login.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"https://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>登录</h1>\n\n<hr>\n\n<p th:text=\"${msg}\" style=\"color:red\"></p>\n\n<form th:action=\"@{/login}\">\n    <p>用户名: <input type=\"text\" name=\"username\"></p>\n    <p>密码: <input type=\"text\" name=\"password\"></p>\n    <p><input type=\"submit\"></p>\n</form>\n\n</body>\n</html>\n```\n\n* 测试，当用户成功登录后才有权限使用`add`和`update`功能\n\n* 原理：调用shiro中的认证功能！\n\n![image-20220309102740828](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309102740828.png)\n\n\n\n### 9.6 Shiro整合mybatis\n\n> 1、项目框架\n\n* 项目结构\n\n![image-20220309110758128](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309110758128.png)\n\n* 数据库的user表\n\n![image-20220309111532330](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309111532330.png)\n\n\n\n> 2、项目实现流程\n\n1. maven导入包\n\n```xml\n<!--shiro整合mybatis-->\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.28</version>\n</dependency>\n\n<dependency>\n    <groupId>log4j</groupId>\n    <artifactId>log4j</artifactId>\n    <version>1.2.17</version>\n</dependency>\n\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.2.8</version>\n</dependency>\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.2.2</version>\n</dependency>\n\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.22</version>\n    <scope>provided</scope>\n</dependency>\n```\n\n2. application.yml\n\n```yml\nspring:\n  datasource:\n    username: root\n    password: 123456\n    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&characterEncoding=UTF-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n\n    #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n    #druid 数据源专有配置\n    initialSize: 5\n    minIdle: 5\n    maxActive: 20\n    maxWait: 60000\n    timeBetweenEvictionRunsMillis: 60000\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: false\n    testOnReturn: false\n    poolPreparedStatements: true\n\n    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j\n    filters: stat,wall,log4j\n    maxPoolPreparedStatementPerConnectionSize: 20\n    useGlobalDataSourceStat: true\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n\nmybatis:\n  type-aliases-package: com.koko.pojo\n  mapper-locations: classpath:mapper/*.xml\n```\n\n3. 实体类User\n\n```java\npackage com.koko.pojo;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User {\n    \n    private int id;\n    private String name;\n    private String pwd;\n    private String perms;\n    \n}\n```\n\n4. mapper层\n\n* UserMapper接口类\n\n```java\npackage com.koko.mapper;\n\nimport com.koko.pojo.User;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.springframework.stereotype.Repository;\n\n@Mapper//这个注解表示了这是一个mybatis的mapper类\n@Repository\npublic interface UserMapper {\n\n    public User queryUserByName(String name);\n\n}\n```\n\n* UserMapper接口实现类`UserMapper.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.koko.mapper.UserMapper\">\n\n    <select id=\"queryUserByName\" resultType=\"User\" parameterType=\"String\">\n        select * from user where name=#{name}\n    </select>\n\n</mapper>\n```\n\n5. service层\n\n* UserService业务接口类\n\n```java\npackage com.koko.service;\n\nimport com.koko.pojo.User;\n\npublic interface UserService {\n\n    User queryUserByName(String name);\n\n}\n```\n\n* UserService业务接口实现类`UserServiceImpl`	\n\n```java\npackage com.koko.service;\n\nimport com.koko.mapper.UserMapper;\nimport com.koko.pojo.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl implements UserService{\n    @Autowired\n    UserMapper userMapper;\n\n    @Override\n    public User queryUserByName(String name) {\n        return userMapper.queryUserByName(name);\n    }\n}\n```\n\n6. UserRealm类\n\n```java\n@Autowired\nUserService userService;\n\n//认证\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    System.out.println(\"执行了=>认证doGetAuthenticationInfo\");\n\n    UsernamePasswordToken userToken = (UsernamePasswordToken) token;\n    //连接真实的数据库\n    User user = userService.queryUserByName(userToken.getUsername());\n\n    if(user==null){\n        return null; //抛出异常 UnknownAccountException\n    }\n\n    //密码认证，shiro做~,加密了\n    //MD5 及 MD5盐值加密\n    return new SimpleAuthenticationInfo(\"\",user.getPwd(),\"\");\n}\n```\n\n7. 测试\n\n![image-20220309111652894](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309111652894.png)\n\n* 成功连接上数据库\n\n\n\n### 9.7 Shiro请求授权实现\n\n> 1、实现流程\n\n1. 数据库层面\n\n* 添加多一个字段，用来存储用户的授权\n\n![image-20220309114233530](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309114233530.png)\n\n![image-20220309114330161](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309114330161.png)\n\n* 项目所要用的数据库\n\n![image-20220309115429273](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309115429273.png)\n\n* 记得实体类添加上新字段\n\n2. ShiroConfig配置类\n\n* ShiroFilterFactoryBean:3 方法\n\n```java\n@Bean\npublic ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n    ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n    //设置安全管理器\n    bean.setSecurityManager(defaultWebSecurityManager);\n\n    /*\n    * anon:无需认证就可以访问\n    * authc:必须认证了才能访问\n    * user:必须拥有 记住我 功能才能用\n    * perms:拥有对某个资源的权限才能访问\n    * role:拥有某个角色权限才能访问\n    * */\n\n    //拦截\n    Map<String,String> filterMap = new LinkedHashMap<>();\n\n    //授权，正常情况下，没有授权会跳转到未授权页面401\n    filterMap.put(\"/user/add\",\"perms[user:add]\");\n    filterMap.put(\"/user/update\",\"perms[user:update]\");\n\n    filterMap.put(\"/user/*\",\"authc\");\n    bean.setFilterChainDefinitionMap(filterMap);\n\n    //设置登录的请求\n    bean.setLoginUrl(\"/toLogin\");\n    //未授权页面\n    bean.setUnauthorizedUrl(\"/noauth\");\n\n    return bean;\n}\n```\n\n* 只要添加授权代码\n\n```java\n//授权，正常情况下，没有授权会跳转到未授权页面401\nfilterMap.put(\"/user/add\",\"perms[user:add]\");\nfilterMap.put(\"/user/update\",\"perms[user:update]\");\n\n//未授权页面\nbean.setUnauthorizedUrl(\"/noauth\");\n```\n\n3. UserRealm配置类\n\n~~~java\n//授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        System.out.println(\"执行了=>授权doGetAuthorizationInfo\");\n\n        //SimpleAuthorizationInfo\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        //info.addStringPermission(\"user:add\");\n\n        //拿到当前登录的这个对象\n        Subject subject = SecurityUtils.getSubject();\n        User currentUser = (User) subject.getPrincipal();\n\n        //设置当前用户的权限\n        info.addStringPermission(currentUser.getPerms());\n\n        return info;\n    }\n~~~\n\n* 认证类中返回值修改\n\n```java\n//密码认证，shiro做~,加密了\n//MD5 及 MD5盐值加密\nreturn new SimpleAuthenticationInfo(user,user.getPwd(),\"\");\n```\n\n4. MyController\n\n```java\n@RequestMapping(\"/noauth\")\n@ResponseBody\npublic String unauthorized(){\n    return \"需要授权才能访问该页面\";\n}\n```\n\n5. 测试\n\n* 以小明为例\n\n* 进入add页面成功！\n\n![image-20220309124903409](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309124903409.png)\n\n* 进入update页面失败，没有权限！\n\n![image-20220309124918941](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309124918941.png)\n\n\n\n### 9.8 Shiro整合Thymeleaf\n\n> 1、实现流程\n\n1. 导入shiro-thymeleaf整合包\n\n```xml\n<!--shiro-thymeleaf整合-->\n<dependency>\n    <groupId>com.github.theborakompanioni</groupId>\n    <artifactId>thymeleaf-extras-shiro</artifactId>\n    <version>2.1.0</version>\n</dependency>\n```\n\n2. ShiroConfig类\n\n```java\n//整合shiroDialect:用来整合shiro thymeleaf\n@Bean\npublic ShiroDialect getShiroDialect(){\n    return new ShiroDialect();\n}\n```\n\n3. 修改登陆页面index.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\"\n      xmlns:th=\"https://www.thymeleaf.org\"\n      xmlns:shiro=\"https://www.thymeleaf.org/thymeleaf-extras-shiro\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n\n<h1>首页</h1>\n\n<div shiro:notAuthenticated>\n    <a th:href=\"@{/toLogin}\">登录</a>\n</div>\n\n<!--<div shiro:Authenticated=\"*:*\">-->\n<!--    <a href=\"#\" th:href=\"@{/logout}\">注销</a>-->\n<!--</div>-->\n\n<p th:text=\"${msg}\"></p>\n\n<div shiro:hasPermission=\"user:add\">\n    <a th:href=\"@{/user/add}\">add</a>\n</div>\n\n<div shiro:hasPermission=\"user:update\">\n    <a th:href=\"@{/user/update}\">update</a>\n</div>\n\n</body>\n</html>\n```\n\n4. 测试\n\n* 只有添加权限的小明同学\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309155649622.png\" alt=\"image-20220309155649622\" style=\"zoom:50%;\" />\n\n* 只有修改权限的李四同学\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309155727468.png\" alt=\"image-20220309155727468\" style=\"zoom:50%;\" />\n\n* 没有权限的王五同学\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220309155803021.png\" alt=\"image-20220309155803021\" style=\"zoom:50%;\" />\n\n* 测试成功！！！\n\n\n\n## 10. 异步、邮件任务、定时\n\n### 10.1 异步\n\n> 1、为什么要使用异步处理任务？\n\n异步处理任务，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。\n\n> 2、测试\n\n1. 在业务层service中定义AsyncService类\n\n```java\npackage com.koko.service;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class AsyncService {\n\n    //告诉Spring这是一个异步方法\n    @Async\n    public void hello(){\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"业务进行中....\");\n    }\n\n}\n```\n\n2. AsyncController控制类\n\n```java\npackage com.koko.controller;\n\nimport com.koko.service.AsyncService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class AsyncController {\n\n    @Autowired\n    AsyncService asyncService;\n\n    //简单跳转\n    @GetMapping(\"/hello\")\n    public String hello(){\n        asyncService.hello();\n        return \"success\";\n    }\n\n}\n```\n\n3. Springboor09TestApplication\n\n* 在SpringBoot测试类中添加注释\n\n```java\npackage com.koko;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync //开启异步注解功能\n@SpringBootApplication\npublic class Springboor09TestApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Springboor09TestApplication.class, args);\n    }\n\n}\n```\n\n4. 测试：http://localhost:8080/hello\n\n* 网页瞬间响应，后台代码依旧执行\n\n\n\n### 10.2 邮件任务\n\n> 1、概述\n\n邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持\n\n- 邮件发送需要引入spring-boot-start-mail\n- SpringBoot 自动配置MailSenderAutoConfiguration\n- 定义MailProperties内容，配置在application.yml中\n- 自动装配JavaMailSender\n- 测试邮件发送\n\n> 2、测试\n\n1. 导入spring-boot-starter-mail依赖\n\n```xml\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\n* 如果导入失败，则降spring-boot-starter-parent版本！！！\n\n```xml\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.5.6</version>\n    <relativePath/> <!-- lookup parent from repository -->\n</parent>\n```\n\n2. 配置文件application.properties\n\n```properties\nspring.mail.username=2427886409@qq.com\nspring.mail.password=tacbzldrjdavebea	# 授权码\nspring.mail.host=smtp.qq.com\n# qq需要配置ssl\nspring.mail.properties.mail.smtp.ssl.enable=true\n```\n\n* 获取授权码：在QQ邮箱中的设置->账户->开启pop3和smtp服务\n\n3. 测试类中进行测试\n\n```java\n@Autowired\nJavaMailSenderImpl mailSender;\n\n@Test\npublic void contextLoads() {\n    //邮件设置1：一个简单的邮件\n    SimpleMailMessage message = new SimpleMailMessage();\n    message.setSubject(\"1、简单的邮件\");\n    message.setText(\"helloworld\");\n\n    message.setTo(\"2427886409@qq.com\");\n    message.setFrom(\"2427886409@qq.com\");\n    mailSender.send(message);\n}\n\n@Test\npublic void contextLoads2() throws MessagingException {\n    //邮件设置2：一个复杂的邮件\n    MimeMessage mimeMessage = mailSender.createMimeMessage();\n    MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);\n\n    helper.setSubject(\"2、复杂的邮件\");\n    helper.setText(\"<b style=\'color:red\'>helloworld</b>\",true);\n\n    //发送附件\n    helper.addAttachment(\"1.jpg\",new File(\"C:\\\\Users\\\\koko\\\\Desktop\\\\蜡笔小新.ico\"));\n    helper.addAttachment(\"2.jpg\",new File(\"C:\\\\Users\\\\koko\\\\Desktop\\\\蜡笔小新.ico\"));\n\n    helper.setTo(\"2427886409@qq.com\");\n    helper.setFrom(\"2427886409@qq.com\");\n\n    mailSender.send(mimeMessage);\n}\n```\n\n4. 测试：\n\n* 简单的邮件发送\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311122757343.png\" alt=\"image-20220311122757343\"  />\n\n* 复杂的邮件发送\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311123154653.png\" alt=\"image-20220311123154653\" style=\"zoom:50%;\" />\n\n查看邮箱，邮件接收成功！\n\n我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！\n\n\n\n### 10.3 定时任务\n\n> 1、概述\n\n项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。\n\n- TaskExecutor接口\n- TaskScheduler接口\n\n两个注解：\n\n- @EnableScheduling  //SpringBoot启动类\n- @Scheduled  //执行方法\n\n\n\n> 2、测试\n\n1. ScheduledService业务类\n\n```java\npackage com.koko.service;\n\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class ScheduledService {\n\n    //秒   分   时     日   月   周几\n    //0 * * * * MON-FRI\n    //注意cron表达式的用法；\n    @Scheduled(cron = \"0 * * * * 0-7\")\n    public void hello(){\n        System.out.println(\"hello.....\");\n    }\n\n}\n```\n\n2. 在SpringBoot测试类中添加注释\n\n```java\n@EnableScheduling //开启基于注解的定时任务\n```\n\n3. 我们来详细了解下cron表达式\n\nhttp://www.bejson.com/othertools/cron/\n\n4. 常用的表达式\n\n```properties\n（1）0/2 * * * * ?   表示每2秒 执行任务\n（1）0 0/2 * * * ?   表示每2分钟 执行任务\n（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务\n（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业\n（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作\n（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点\n（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时\n（6）0 0 12 ? * WED   表示每个星期三中午12点\n（7）0 0 12 * * ?   每天中午12点触发\n（8）0 15 10 ? * *   每天上午10:15触发\n（9）0 15 10 * * ?     每天上午10:15触发\n（10）0 15 10 * * ?   每天上午10:15触发\n（11）0 15 10 * * ? 2005   2005年的每天上午10:15触发\n（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发\n（13）0 0/5 14 * * ?   在每天下午2点到下午2:55期间的每5分钟触发\n（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发\n（15）0 0-5 14 * * ?   在每天下午2点到下午2:05期间的每1分钟触发\n（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发\n（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发\n（18）0 15 10 15 * ?   每月15日上午10:15触发\n（19）0 15 10 L * ?   每月最后一日的上午10:15触发\n（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发\n（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发\n（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发\n```\n\n\n\n\n\n## 11. Dubbo和Zookeeper集成\n\n### 11.1 分布式理论\n\n> **1、什么是分布式系统？**\n\n在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；\n\n分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是**利用更多的机器，处理更多的数据**。\n\n分布式系统（distributed system）是建立在网络之上的软件系统。\n\n首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。\n\n> 2、Dubbo文档\n\n随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需**一个治理系统**确保架构有条不紊的演进。\n\n在Dubbo的官网文档有这样一张图\n\n![image-20220311214745570](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311214745570.png)\n\n\n\n> 1、单一应用架构\n\n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。\n\n![image-20220311214819155](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311214819155.png)\n\n适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。\n\n1、性能扩展比较难\n\n2、协同开发问题\n\n3、不利于升级维护\n\n> 2、垂直应用架构\n\n当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。\n\n![image-20220311214936464](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311214936464.png)\n\n通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。\n\n缺点：公用模块无法重复利用，开发性的浪费\n\n> 3、分布式服务架构\n\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。\n\n![image-20220311215008041](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311215008041.png)\n\n> 4、流动计算架构\n\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于**提高机器利用率的资源调度和治理中心**(SOA)[ Service Oriented Architecture]是关键。\n\n![image-20220311215040262](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311215040262.png)\n\n\n\n### 11.2 什么是RPC\n\n> 1、概述\n\nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；\n\n推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b\n\n**RPC基本原理**\n\n![image-20220311215125107](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311215125107.png)\n\n**步骤解析：**\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311215143733.png\" alt=\"image-20220311215143733\" style=\"zoom: 50%;\" />\n\nRPC两个核心模块：通讯，序列化。\n\n\n\n### 11.3 测试环境搭建\n\n> 1、Dubbo\n\nApache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。\n\ndubbo官网 http://dubbo.apache.org/zh-cn/index.html\n\n1.了解Dubbo的特性\n\n2.查看官方文档\n\n**dubbo基本概念**\n\n<img src=\"https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311215250368.png\" alt=\"image-20220311215250368\" style=\"zoom:80%;\" />\n\n**服务提供者**（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。\n\n**服务消费者**（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\n**注册中心**（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者\n\n**监控中心**（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心\n\n**调用关系说明**\n\nl 服务容器负责启动，加载，运行服务提供者。\n\nl 服务提供者在启动时，向注册中心注册自己提供的服务。\n\nl 服务消费者在启动时，向注册中心订阅自己所需的服务。\n\nl 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n\nl 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n\nl 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n\n\n> 2、Dubbo环境搭建（Window下安装zookeeper）\n\n点进dubbo官方文档，推荐我们使用Zookeeper 注册中心\n\n下载链接：[Apache ZooKeeper](https://zookeeper.apache.org/releases.html#download)\n\n下载版本：3.8.0\n\n![image-20220311215554775](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311215554775.png)\n\n* 注意：3.5版本后要下载bin文件\n\n1. 解压后打开conf，将zoo_sample.cfg复制一份改名为zoo.cfg\n\n* 将dataDir=./删掉，加入下列命令\n\n~~~properties\ndataDir=D:\\Java_Tools\\zookeeper\\apache-zookeeper-3.8.0-bin\\data\naudit.enable=true\n~~~\n\n2. 打开bin文件夹的zkServer.cmd（注意要用管理员模式）\n\n![image-20220311220017093](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/11_SpringBoot/image-20220311220017093.png)\n\n* 完毕！\n\n> 总结\n\n1. 小结\n\nzookeeper：注册中心\n\ndubbo-admin：一个监控管理后台~查看我们注册了哪些服务，哪些服务被消费了~\n\nDubbo：jar包\n\n2. 步骤\n\n前提：zookeeper服务已经开启！\n\n1. 提供者提供服务\n   1. 导入依赖\n   2. 配置注册中心的地址，以及服务发现名，和要扫描的包~\n   3. 在想要被注册的服务上面~ 增加一个注解 @Service\n2. 消费者如何消费\n   1. 导入依赖\n   2. 配置注册中心的地址，配置自己的服务名\n   3. 从远程注入服务~ @Reference\n\n\n\n## 12. 富文本编辑器\n\n### 12.1 简介\n\n思考：我们平时在博客园，或者CSDN等平台进行写作的时候，有同学思考过他们的编辑器是怎么实现的吗？\n\n在博客园后台的选项设置中，可以看到一个文本编辑器的选项：\n\n![image-20220426114156402](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/images/image-20220426114156402.png)\n\n其实这个就是富文本编辑器，市面上有许多非常成熟的富文本编辑器，比如：\n\n- **Editor.md**——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费\n\n- - 官网：https://pandao.github.io/editor.md/\n\n- **wangEditor**——基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。\n\n- - 官网：http://www.wangeditor.com/\n\n- **TinyMCE**——TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。\n\n- - 官网：https://www.tiny.cloud/docs/demo/full-featured/\n  - 博客园\n\n- **百度ueditor**——UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了\n\n- - 官网：https://ueditor.baidu.com/website/onlinedemo.html\n\n- **kindeditor**——界面经典。\n\n- - 官网：http://kindeditor.net/demo.php\n\n- **Textbox**——Textbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。\n\n- - 官网：https://textbox.io/\n\n- **CKEditor**——国外的，界面美观。\n\n- - 官网：https://ckeditor.com/ckeditor-5/demo/\n\n- **quill**——功能强大，还可以编辑公式等\n\n- - 官网：https://quilljs.com/\n\n- **simditor**——界面美观，功能较全。\n\n- - 官网：https://simditor.tower.im/\n\n- **summernote**——UI好看，精美\n\n- - 官网：https://summernote.org/\n\n- **jodit**——功能齐全\n\n- - 官网：https://xdsoft.net/jodit/\n\n- **froala Editor**——界面非常好看，功能非常强大，非常好用（非免费）\n\n- - 官网：https://www.froala.com/wysiwyg-editor\n\n总之，目前可用的富文本编辑器有很多......这只是其中的一部分\n\n### 12.2 Editor.md\n\n我这里使用的就是Editor.md，作为一个资深码农，Markdown必然是我们程序猿最喜欢的格式，看下面，就爱上了！\n\n![image-20220426114223808](https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/images/image-20220426114223808.png)\n\n我们可以在官网下载它：https://pandao.github.io/editor.md/ ， 得到它的压缩包！\n\n解压以后，在examples目录下面，可以看到他的很多案例使用！学习，其实就是看人家怎么写的，然后进行模仿就好了！\n\n我们可以将整个解压的文件倒入我们的项目，将一些无用的测试和案例删掉即可！\n\n\n\n### 12.3 基础工程搭建\n\narticle：文章表\n\n| 字段    |          | 备注         |\n| ------- | -------- | ------------ |\n| id      | int      | 文章的唯一ID |\n| author  | varchar  | 作者         |\n| title   | varchar  | 标题         |\n| content | longtext | 文章的内容   |\n\n建表SQL：\n\n```mysql\nCREATE TABLE `article` (\n`id` int(10) NOT NULL AUTO_INCREMENT COMMENT \'int文章的唯一ID\',\n`author` varchar(50) NOT NULL COMMENT \'作者\',\n`title` varchar(100) NOT NULL COMMENT \'标题\',\n`content` longtext NOT NULL COMMENT \'文章的内容\',\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```\n\n> 基础项目搭建\n\n1、建一个SpringBoot项目配置\n\n```yml\nspring:\ndatasource:\n  username: root\n  password: 123456\n  #?serverTimezone=UTC解决时区的报错\n  url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\n  driver-class-name: com.mysql.cj.jdbc.Driver\n<resources>\n   <resource>\n       <directory>src/main/java</directory>\n       <includes>\n           <include>**/*.xml</include>\n       </includes>\n       <filtering>true</filtering>\n   </resource>\n</resources>\n```\n\n2、实体类：\n\n```java\n//文章类\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Article implements Serializable {\n\n   private int id; //文章的唯一ID\n   private String author; //作者名\n   private String title; //标题\n   private String content; //文章的内容\n\n}\n```\n\n3、mapper接口：\n\n```java\n@Mapper\n@Repository\npublic interface ArticleMapper {\n   //查询所有的文章\n   List<Article> queryArticles();\n\n   //新增一个文章\n   int addArticle(Article article);\n\n   //根据文章id查询文章\n   Article getArticleById(int id);\n\n   //根据文章id删除文章\n   int deleteArticleById(int id);\n\n}\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n       \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"com.kuang.mapper.ArticleMapper\">\n\n   <select id=\"queryArticles\" resultType=\"Article\">\n      select * from article\n   </select>\n   \n   <select id=\"getArticleById\" resultType=\"Article\">\n      select * from article where id = #{id}\n   </select>\n   \n   <insert id=\"addArticle\" parameterType=\"Article\">\n      insert into article (author,title,content) values (#{author},#{title},#{content});\n   </insert>\n   \n   <delete id=\"deleteArticleById\" parameterType=\"int\">\n      delete from article where id = #{id}\n   </delete>\n   \n</mapper>\n```\n\n**既然已经提供了 myBatis 的映射配置文件，自然要告诉 spring boot 这些文件的位置**\n\n```yml\nmybatis:\nmapper-locations: classpath:com/kuang/mapper/*.xml\ntype-aliases-package: com.kuang.pojo\n```\n\n编写一个Controller测试下，是否ok；\n\n\n\n### 12.4 文章编辑整合(*)\n\n1、导入 editor.md 资源 ，删除多余文件\n\n2、编辑文章页面 editor.html、需要引入 jQuery；\n\n```html\n<!DOCTYPE html>\n<html class=\"x-admin-sm\" lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\">\n\n<head>\n   <meta charset=\"UTF-8\">\n   <title>秦疆\'Blog</title>\n   <meta name=\"renderer\" content=\"webkit\">\n   <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n   <meta name=\"viewport\" content=\"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi\" />\n   <!--Editor.md-->\n   <link rel=\"stylesheet\" th:href=\"@{/editormd/css/editormd.css}\"/>\n   <link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\" />\n</head>\n\n<body>\n\n<div class=\"layui-fluid\">\n   <div class=\"layui-row layui-col-space15\">\n       <div class=\"layui-col-md12\">\n           <!--博客表单-->\n           <form name=\"mdEditorForm\">\n               <div>\n                  标题：<input type=\"text\" name=\"title\">\n               </div>\n               <div>\n                  作者：<input type=\"text\" name=\"author\">\n               </div>\n               <div id=\"article-content\">\n                   <textarea name=\"content\" id=\"content\" style=\"display:none;\"> </textarea>\n               </div>\n           </form>\n\n       </div>\n   </div>\n</div>\n</body>\n\n<!--editormd-->\n<script th:src=\"@{/editormd/lib/jquery.min.js}\"></script>\n<script th:src=\"@{/editormd/editormd.js}\"></script>\n\n<script type=\"text/javascript\">\n   var testEditor;\n\n   //window.onload = function(){ }\n   $(function() {\n       testEditor = editormd(\"article-content\", {\n           width : \"95%\",\n           height : 400,\n           syncScrolling : \"single\",\n           path : \"../editormd/lib/\",\n           saveHTMLToTextarea : true,    // 保存 HTML 到 Textarea\n           emoji: true,\n           theme: \"dark\",//工具栏主题\n           previewTheme: \"dark\",//预览主题\n           editorTheme: \"pastel-on-dark\",//编辑主题\n           tex : true,                   // 开启科学公式TeX语言支持，默认关闭\n           flowChart : true,             // 开启流程图支持，默认关闭\n           sequenceDiagram : true,       // 开启时序/序列图支持，默认关闭,\n           //图片上传\n           imageUpload : true,\n           imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],\n           imageUploadURL : \"/article/file/upload\",\n           onload : function() {\n               console.log(\'onload\', this);\n          },\n           /*指定需要显示的功能按钮*/\n           toolbarIcons : function() {\n               return [\"undo\",\"redo\",\"|\",\n                   \"bold\",\"del\",\"italic\",\"quote\",\"ucwords\",\"uppercase\",\"lowercase\",\"|\",\n                   \"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"|\",\n                   \"list-ul\",\"list-ol\",\"hr\",\"|\",\n                   \"link\",\"reference-link\",\"image\",\"code\",\"preformatted-text\",\n                   \"code-block\",\"table\",\"datetime\",\"emoji\",\"html-entities\",\"pagebreak\",\"|\",\n                   \"goto-line\",\"watch\",\"preview\",\"fullscreen\",\"clear\",\"search\",\"|\",\n                   \"help\",\"info\",\"releaseIcon\", \"index\"]\n          },\n\n           /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/\n           toolbarIconTexts : {\n               releaseIcon : \"<span bgcolor=\\\"gray\\\">发布</span>\",\n               index : \"<span bgcolor=\\\"red\\\">返回首页</span>\",\n          },\n\n           /*给自定义按钮指定回调函数*/\n           toolbarHandlers:{\n               releaseIcon : function(cm, icon, cursor, selection) {\n                   //表单提交\n                   mdEditorForm.method = \"post\";\n                   mdEditorForm.action = \"/article/addArticle\";//提交至服务器的路径\n                   mdEditorForm.submit();\n              },\n               index : function(){\n                   window.location.href = \'/\';\n              },\n          }\n      });\n  });\n</script>\n\n</html>\n```\n\n3、编写Controller，进行跳转，以及保存文章\n\n```java\n@Controller\n@RequestMapping(\"/article\")\npublic class ArticleController {\n\n   @GetMapping(\"/toEditor\")\n   public String toEditor(){\n       return \"editor\";\n  }\n   \n   @PostMapping(\"/addArticle\")\n   public String addArticle(Article article){\n       articleMapper.addArticle(article);\n       return \"editor\";\n  }\n   \n}\n```\n\n> 图片上传问题\n\n1、前端js中添加配置\n\n```js\n//图片上传\nimageUpload : true,\nimageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],\nimageUploadURL : \"/article/file/upload\", // //这个是上传图片时的访问地址\n```\n\n2、后端请求，接收保存这个图片, 需要导入 FastJson 的依赖！\n\n```java\n//博客图片上传问题\n@RequestMapping(\"/file/upload\")\n@ResponseBody\npublic JSONObject fileUpload(@RequestParam(value = \"editormd-image-file\", required = true) MultipartFile file, HttpServletRequest request) throws IOException {\n   //上传路径保存设置\n\n   //获得SpringBoot当前项目的路径：System.getProperty(\"user.dir\")\n   String path = System.getProperty(\"user.dir\")+\"/upload/\";\n\n   //按照月份进行分类：\n   Calendar instance = Calendar.getInstance();\n   String month = (instance.get(Calendar.MONTH) + 1)+\"月\";\n   path = path+month;\n\n   File realPath = new File(path);\n   if (!realPath.exists()){\n       realPath.mkdir();\n  }\n\n   //上传文件地址\n   System.out.println(\"上传文件保存地址：\"+realPath);\n\n   //解决文件名字问题：我们使用uuid;\n   String filename = \"ks-\"+UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n   //通过CommonsMultipartFile的方法直接写文件（注意这个时候）\n   file.transferTo(new File(realPath +\"/\"+ filename));\n\n   //给editormd进行回调\n   JSONObject res = new JSONObject();\n   res.put(\"url\",\"/upload/\"+month+\"/\"+ filename);\n   res.put(\"success\", 1);\n   res.put(\"message\", \"upload success!\");\n\n   return res;\n}\n```\n\n3、解决文件回显显示的问题，设置虚拟目录映射！在我们自己拓展的MvcConfig中进行配置即可！\n\n```java\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n   // 文件保存在真实目录/upload/下，\n   // 访问的时候使用虚路径/upload，比如文件名为1.png，就直接/upload/1.png就ok了。\n   @Override\n   public void addResourceHandlers(ResourceHandlerRegistry registry) {\n       registry.addResourceHandler(\"/upload/**\")\n          .addResourceLocations(\"file:\"+System.getProperty(\"user.dir\")+\"/upload/\");\n  }\n\n}\n```\n\n> 表情包问题\n\n自己手动下载，emoji 表情包，放到图片路径下：\n\n修改editormd.js文件\n\n```js\n// Emoji graphics files url path\neditormd.emoji     = {\n   path : \"../editormd/plugins/emoji-dialog/emoji/\",\n   ext   : \".png\"\n};\n```\n\n\n\n### 12.5 文章展示\n\n1、Controller 中增加方法\n\n```java\n@GetMapping(\"/{id}\")\npublic String show(@PathVariable(\"id\") int id,Model model){\n   Article article = articleMapper.getArticleById(id);\n   model.addAttribute(\"article\",article);\n   return \"article\";\n}\n```\n\n2、编写页面 article.html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n   <meta charset=\"UTF-8\">\n   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n   <title th:text=\"${article.title}\"></title>\n</head>\n<body>\n\n<div>\n   <!--文章头部信息：标题，作者，最后更新日期，导航-->\n   <h2 style=\"margin: auto 0\" th:text=\"${article.title}\"></h2>\n  作者：<span style=\"float: left\" th:text=\"${article.author}\"></span>\n   <!--文章主体内容-->\n   <div id=\"doc-content\">\n       <textarea style=\"display:none;\" placeholder=\"markdown\" th:text=\"${article.content}\"></textarea>\n   </div>\n\n</div>\n\n<link rel=\"stylesheet\" th:href=\"@{/editormd/css/editormd.preview.css}\" />\n<script th:src=\"@{/editormd/lib/jquery.min.js}\"></script>\n<script th:src=\"@{/editormd/lib/marked.min.js}\"></script>\n<script th:src=\"@{/editormd/lib/prettify.min.js}\"></script>\n<script th:src=\"@{/editormd/lib/raphael.min.js}\"></script>\n<script th:src=\"@{/editormd/lib/underscore.min.js}\"></script>\n<script th:src=\"@{/editormd/lib/sequence-diagram.min.js}\"></script>\n<script th:src=\"@{/editormd/lib/flowchart.min.js}\"></script>\n<script th:src=\"@{/editormd/lib/jquery.flowchart.min.js}\"></script>\n<script th:src=\"@{/editormd/editormd.js}\"></script>\n\n<script type=\"text/javascript\">\n   var testEditor;\n   $(function () {\n       testEditor = editormd.markdownToHTML(\"doc-content\", {//注意：这里是上面DIV的id\n           htmlDecode: \"style,script,iframe\",\n           emoji: true,\n           taskList: true,\n           tocm: true,\n           tex: true, // 默认不解析\n           flowChart: true, // 默认不解析\n           sequenceDiagram: true, // 默认不解析\n           codeFold: true\n      });});\n</script>\n</body>\n</html>\n```\n\n重启项目，访问进行测试！大功告成！\n\n小结：\n\n有了富文本编辑器，我们网站的功能就会又多一项，大家到了这里完全可以有时间写一个属于自己的博客网站了，根据所学的知识是完全没有任何问题的！\n\n\n\n## 13. 回顾和展望\n\n回顾以前，架构！\n\n~~~bash\n三层架构 + MVC\n	架构 -->解耦\n\n开发框架\n    Spring\n		IOC		AOP\n			IOC : 控制反转\n			 	泡温泉,泡茶泡友\n				附近的人,打招呼。加微信,聊天,天天聊>约泡\n				浴场(容器):温泉,茶庄泡友\n				直接进温泉,就有人和你一起了!\n原来我们都是自己一步步操作,现在交给容器了!我们需要什么就去拿就可以了\n                \n             AOP:切面(本质,动态代理）\n为了解什么?不影响业本来的情况下,实现动态增加功能,大量应用在日志,事务等等\n                    \n	Spring是一个轻量级的Java开源框架，容器\n        目的：解决企业开发的复杂性问题\n        Spring是春天，但配置文件繁琐\n\n    SpringBoot\n      	SpringBoot ,新代javaEE的开发标准,开箱即用!>拿过来就可以用,\n        它自动帮我们配置了非常多的东西,我们拿来即用,\n        特性:约定大于配置!\n                    \n随着公司体系越来越大,用户越来越多\n                    \n微服务架构—>新架构\n	模块化,功能化!\n	用户,支付,签到,娱乐…;\n	如果一台服务器解决不了就再增加一台服务器! --横向扩展\n	假设A服务器占用98%资源B服务器只占用了10%.–负载均衡;\n\n	将原来的整体项,分成模块化,用户就是一个单独的项目,签到也是一个单独的项目,项目和项目之前需要通信,如何通信\n	用户非常多而到十分少给用户多一点服务器,给签到少一点服务器\n微服务架构问题?\n                    \n分布式架构会遇到的四个核心题?\n   	1.这么多服务,客户端该如何去访?\n    2.这么多服务,服务之间如何进行通信?\n    3.这么多服务,如何治理呢?\n    4.服务挂了,怎么办?\n        \n解决方案:                    \n	Springcloud是一套生态，就是来解决以上分布式架构的4个问题\n    想使用Spring Clould ,必须要掌握 springBoot , 因为Springcloud是基于springBoot ;\n\n	1. spring Cloud NetFlix ,出来了一套解决方案！一站式解决方案。可以直接使用\n	Api网关 , zuul组件\n	Feign --> Httpclient —> http通信方式,同步并阻塞\n	服务注册与发现 , Eureka\n	熔断机制 , Hystrix\n                    \n2018年年底,NetFlix 宣布无限期停止维护。生态不再维护,就会脱节。\n\n	2. Apache Dubbo zookeeper ,第二套解决方案\n	API:没有!要么找第三方组件,要么自己实现\n	Dubbo 是一个高性能的基于ava实现的RPC通信框架!2.6.x\n	服务注册与发现 , zookeeper :动物管理者 ( Hadoop , Hive )\n	没有:借助了Hystrix\n                    \n不完善，Dubbo\n\n	3. SpringCloud Alibaba 一站式解决方案\n\n目前又提出了新的思路:\n	服务网格：也许是下一代维服务标准，Service mesh\n	代表解决方案：istio（未来可能需要掌握）\n\n万变不离其宗,一通百通！\n	1.API网关 ， 服务路由\n	2.HTTP，RPC框架，异步调用\n	3.服务注册与发现，高可用\n	4.熔断机制，服务降级\n         \n为什么要解决这个问题？因为网络是不可靠的!!!\n~~~\n\n', '关于SpringBoot的完整笔记', 4, 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/a0b60e2a-dad6-4756-ad24-cc6761470d60.jpg', '1', '0', 117, '0', 1, '2023-02-21 22:42:59', 1, '2023-02-21 22:42:59', 0);

-- ----------------------------
-- Table structure for sg_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `sg_article_tag`;
CREATE TABLE `sg_article_tag`  (
  `article_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `tag_id` bigint(20) NOT NULL DEFAULT 0 COMMENT '标签id',
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章标签关联表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sg_article_tag
-- ----------------------------
INSERT INTO `sg_article_tag` VALUES (1, 4);
INSERT INTO `sg_article_tag` VALUES (2, 1);
INSERT INTO `sg_article_tag` VALUES (2, 4);
INSERT INTO `sg_article_tag` VALUES (3, 4);
INSERT INTO `sg_article_tag` VALUES (3, 5);
INSERT INTO `sg_article_tag` VALUES (6, 1);
INSERT INTO `sg_article_tag` VALUES (6, 5);
INSERT INTO `sg_article_tag` VALUES (7, 4);
INSERT INTO `sg_article_tag` VALUES (7, 5);
INSERT INTO `sg_article_tag` VALUES (9, 2);
INSERT INTO `sg_article_tag` VALUES (10, 2);
INSERT INTO `sg_article_tag` VALUES (10, 12);
INSERT INTO `sg_article_tag` VALUES (11, 2);
INSERT INTO `sg_article_tag` VALUES (11, 12);
INSERT INTO `sg_article_tag` VALUES (12, 5);
INSERT INTO `sg_article_tag` VALUES (13, 5);
INSERT INTO `sg_article_tag` VALUES (14, 3);
INSERT INTO `sg_article_tag` VALUES (15, 3);
INSERT INTO `sg_article_tag` VALUES (16, 2);

-- ----------------------------
-- Table structure for sg_category
-- ----------------------------
DROP TABLE IF EXISTS `sg_category`;
CREATE TABLE `sg_category`  (
  `id` bigint(200) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类名',
  `pid` bigint(200) NULL DEFAULT -1 COMMENT '父分类id，如果没有父分类为-1',
  `description` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '描述',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '状态0:正常,1禁用',
  `create_by` bigint(200) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(200) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(11) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '分类表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sg_category
-- ----------------------------
INSERT INTO `sg_category` VALUES (1, 'Java', -1, 'Java后端的内容', '0', NULL, NULL, NULL, '2023-02-27 08:45:17', 0);
INSERT INTO `sg_category` VALUES (2, '408计算机', -1, '数据结构、计组、操作系统、计网', '0', NULL, NULL, NULL, '2023-02-21 22:11:40', 0);
INSERT INTO `sg_category` VALUES (3, '设计模式', -1, '关于设计模式的内容', '0', 1, '2023-02-18 09:49:06', NULL, '2023-02-21 22:13:30', 0);
INSERT INTO `sg_category` VALUES (4, 'Spring', -1, 'Spring相关的内容', '0', 1, '2023-02-21 22:13:50', 1, '2023-02-21 22:13:50', 0);
INSERT INTO `sg_category` VALUES (5, '后端底层知识', -1, '关于后端底层的知识', '0', 1, '2023-02-21 22:14:17', 1, '2023-02-21 22:14:17', 0);

-- ----------------------------
-- Table structure for sg_comment
-- ----------------------------
DROP TABLE IF EXISTS `sg_comment`;
CREATE TABLE `sg_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '评论类型（0代表文章评论，1代表友链评论）',
  `article_id` bigint(20) NULL DEFAULT NULL COMMENT '文章id',
  `root_id` bigint(20) NULL DEFAULT -1 COMMENT '根评论id',
  `content` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论内容',
  `to_comment_user_id` bigint(20) NULL DEFAULT -1 COMMENT '所回复的目标评论的userid',
  `to_comment_id` bigint(20) NULL DEFAULT -1 COMMENT '回复目标评论id',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 37 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sg_comment
-- ----------------------------
INSERT INTO `sg_comment` VALUES (1, '0', 1, -1, 'asS', -1, -1, 1, '2022-01-29 07:59:22', 1, '2022-01-29 07:59:22', 0);
INSERT INTO `sg_comment` VALUES (2, '0', 1, -1, '[哈哈]SDAS', -1, -1, 1, '2022-01-29 08:01:24', 1, '2022-01-29 08:01:24', 0);
INSERT INTO `sg_comment` VALUES (3, '0', 1, -1, '是大多数', -1, -1, 1, '2022-01-29 16:07:24', 1, '2022-01-29 16:07:24', 0);
INSERT INTO `sg_comment` VALUES (4, '0', 1, -1, '撒大声地', -1, -1, 1, '2022-01-29 16:12:09', 1, '2022-01-29 16:12:09', 0);
INSERT INTO `sg_comment` VALUES (5, '0', 1, -1, '你再说什么', -1, -1, 1, '2022-01-29 18:19:56', 1, '2022-01-29 18:19:56', 0);
INSERT INTO `sg_comment` VALUES (6, '0', 1, -1, 'hffd', -1, -1, 1, '2022-01-29 22:13:52', 1, '2022-01-29 22:13:52', 0);
INSERT INTO `sg_comment` VALUES (9, '0', 1, 2, '你说什么', 1, 2, 1, '2022-01-29 22:18:40', 1, '2022-01-29 22:18:40', 0);
INSERT INTO `sg_comment` VALUES (10, '0', 1, 2, '哈哈哈哈[哈哈]', 1, 9, 1, '2022-01-29 22:29:15', 1, '2022-01-29 22:29:15', 0);
INSERT INTO `sg_comment` VALUES (11, '0', 1, 2, 'we全文', 1, 10, 3, '2022-01-29 22:29:55', 1, '2022-01-29 22:29:55', 0);
INSERT INTO `sg_comment` VALUES (12, '0', 1, -1, '王企鹅', -1, -1, 1, '2022-01-29 22:30:20', 1, '2022-01-29 22:30:20', 0);
INSERT INTO `sg_comment` VALUES (13, '0', 1, -1, '什么阿是', -1, -1, 1, '2022-01-29 22:30:56', 1, '2022-01-29 22:30:56', 0);
INSERT INTO `sg_comment` VALUES (14, '0', 1, -1, '新平顶山', -1, -1, 1, '2022-01-29 22:32:51', 1, '2022-01-29 22:32:51', 0);
INSERT INTO `sg_comment` VALUES (15, '0', 1, -1, '2222', -1, -1, 1, '2022-01-29 22:34:38', 1, '2022-01-29 22:34:38', 0);
INSERT INTO `sg_comment` VALUES (16, '0', 1, 2, '3333', 1, 11, 1, '2022-01-29 22:34:47', 1, '2022-01-29 22:34:47', 0);
INSERT INTO `sg_comment` VALUES (17, '0', 1, 2, '回复weqedadsd', 3, 11, 1, '2022-01-29 22:38:00', 1, '2022-01-29 22:38:00', 0);
INSERT INTO `sg_comment` VALUES (18, '0', 1, -1, 'sdasd', -1, -1, 1, '2022-01-29 23:18:19', 1, '2022-01-29 23:18:19', 0);
INSERT INTO `sg_comment` VALUES (19, '0', 1, -1, '111', -1, -1, 1, '2022-01-29 23:22:23', 1, '2022-01-29 23:22:23', 0);
INSERT INTO `sg_comment` VALUES (20, '0', 1, 1, '你说啥？', 1, 1, 1, '2022-01-30 10:06:21', 1, '2022-01-30 10:06:21', 0);
INSERT INTO `sg_comment` VALUES (21, '0', 1, -1, '友链添加个呗', -1, -1, 1, '2022-01-30 10:06:50', 1, '2022-01-30 10:06:50', 0);
INSERT INTO `sg_comment` VALUES (22, '1', 1, -1, '友链评论2', -1, -1, 1, '2022-01-30 10:08:28', 1, '2022-01-30 10:08:28', 0);
INSERT INTO `sg_comment` VALUES (23, '1', 1, 22, '回复友链评论3', 1, 22, 1, '2022-01-30 10:08:50', 1, '2022-01-30 10:08:50', 0);
INSERT INTO `sg_comment` VALUES (24, '1', 1, -1, '友链评论4444', -1, -1, 1, '2022-01-30 10:09:03', 1, '2022-01-30 10:09:03', 0);
INSERT INTO `sg_comment` VALUES (25, '1', 1, 22, '收到的', 1, 22, 1, '2022-01-30 10:13:28', 1, '2022-01-30 10:13:28', 0);
INSERT INTO `sg_comment` VALUES (26, '0', 1, -1, 'sda', -1, -1, 1, '2022-01-30 10:39:05', 1, '2022-01-30 10:39:05', 0);
INSERT INTO `sg_comment` VALUES (27, '0', 1, 1, '说你咋地', 1, 20, 14787164048662, '2022-01-30 17:19:30', 14787164048662, '2022-01-30 17:19:30', 0);
INSERT INTO `sg_comment` VALUES (28, '0', 1, 1, 'sdad', 1, 1, 14787164048662, '2022-01-31 11:11:20', 14787164048662, '2022-01-31 11:11:20', 0);
INSERT INTO `sg_comment` VALUES (29, '0', 1, -1, '你说是的ad', -1, -1, 14787164048662, '2022-01-31 14:10:11', 14787164048662, '2022-01-31 14:10:11', 0);
INSERT INTO `sg_comment` VALUES (30, '0', 1, 1, '撒大声地', 1, 1, 14787164048662, '2022-01-31 20:19:18', 14787164048662, '2022-01-31 20:19:18', 0);
INSERT INTO `sg_comment` VALUES (31, '0', 1, -1, '666', -1, -1, 1, '2023-02-16 13:19:18', 1, '2023-02-16 13:19:18', 0);
INSERT INTO `sg_comment` VALUES (32, '0', 1, -1, '666', -1, -1, 1, '2023-02-16 13:22:47', 1, '2023-02-16 13:22:47', 0);
INSERT INTO `sg_comment` VALUES (33, '0', 1, 32, '66[嘻嘻]', 1, 32, 1, '2023-02-16 13:24:43', 1, '2023-02-16 13:24:43', 0);
INSERT INTO `sg_comment` VALUES (34, '1', 1, -1, '666', -1, -1, 1, '2023-02-16 15:17:56', 1, '2023-02-16 15:17:56', 0);
INSERT INTO `sg_comment` VALUES (35, '1', 1, 34, '6个勾八[挖鼻]', 1, 34, 1, '2023-02-16 15:23:07', 1, '2023-02-16 15:23:07', 0);
INSERT INTO `sg_comment` VALUES (36, '1', 1, 34, '666', 1, 35, 1, '2023-02-21 22:31:28', 1, '2023-02-21 22:31:28', 0);

-- ----------------------------
-- Table structure for sg_link
-- ----------------------------
DROP TABLE IF EXISTS `sg_link`;
CREATE TABLE `sg_link`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `logo` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `description` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `address` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网站地址',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '2' COMMENT '审核状态 (0代表审核通过，1代表审核未通过，2代表未审核)',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '友链' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sg_link
-- ----------------------------
INSERT INTO `sg_link` VALUES (1, '百度', 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Frecom%2F2016%2F05%2F10%2F146286696706220328.PNG&refer=http%3A%2F%2Fn1.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646205529&t=f942665181eb9b0685db7a6f59d59975', '百度友链', 'https://www.baidu.com', '0', NULL, '2022-01-13 08:25:47', NULL, '2023-02-27 08:45:01', 0);
INSERT INTO `sg_link` VALUES (2, 'BiliBili', 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/bilibili友链.jpg', 'BiliBili友链', 'https://www.bilibili.com/', '0', NULL, '2022-01-13 09:06:10', NULL, '2023-02-27 09:16:06', 0);
INSERT INTO `sg_link` VALUES (3, 'CSDN', 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/CSDN友链.png', 'CSDN友链', 'https://blog.csdn.net/', '0', NULL, '2022-01-13 09:23:01', NULL, '2023-02-21 22:00:10', 0);
INSERT INTO `sg_link` VALUES (4, '666', '666', '666', '666', '2', 1, '2023-02-18 09:07:27', NULL, '2023-02-19 11:24:05', 1);
INSERT INTO `sg_link` VALUES (5, 'Leetcode', 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/5c070e25-ce0f-48c0-a2e8-c87b664cc34f.jpg', 'Leetcode友链', 'https://leetcode.cn/', '0', 1, '2023-02-21 22:02:02', NULL, '2023-02-27 09:30:07', 0);
INSERT INTO `sg_link` VALUES (6, 'Gitee', 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/Gitee友链.png', 'Gitee友链', 'https://gitee.com/', '0', 1, '2023-02-21 22:02:59', 1, '2023-02-21 22:02:59', 0);
INSERT INTO `sg_link` VALUES (7, 'GitHub', 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/GitHub友链.jpg', 'GitHub友链', 'https://github.com/', '0', 1, '2023-02-21 22:03:45', NULL, '2023-02-21 22:03:47', 0);

-- ----------------------------
-- Table structure for sg_tag
-- ----------------------------
DROP TABLE IF EXISTS `sg_tag`;
CREATE TABLE `sg_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标签名',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '标签' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sg_tag
-- ----------------------------
INSERT INTO `sg_tag` VALUES (1, 'Mybatis', NULL, NULL, NULL, '2023-02-27 08:45:53', '关于Mybatis的标签', 0);
INSERT INTO `sg_tag` VALUES (2, 'Java', NULL, '2022-01-11 09:20:55', NULL, '2023-02-21 21:46:39', '关于Java的标签', 0);
INSERT INTO `sg_tag` VALUES (3, 'Spring', NULL, '2022-01-11 09:21:07', NULL, '2023-02-27 08:44:56', '关于Spring的标签', 0);
INSERT INTO `sg_tag` VALUES (4, 'C#', NULL, '2022-01-13 15:22:43', NULL, '2023-02-21 21:47:22', '关于C++++的标签', 0);
INSERT INTO `sg_tag` VALUES (5, '计算机底层', NULL, '2022-01-13 15:22:47', NULL, '2023-02-21 21:48:52', '关于计算机底层的标签', 0);
INSERT INTO `sg_tag` VALUES (7, 'c#', 1, '2023-02-18 06:25:12', 1, '2023-02-18 06:25:12', 'c++++', 1);
INSERT INTO `sg_tag` VALUES (9, '999', 1, '2023-02-18 06:26:37', NULL, '2023-02-18 08:06:03', '999', 1);
INSERT INTO `sg_tag` VALUES (12, '后端底层知识', 1, '2023-02-21 21:49:14', NULL, '2023-02-27 08:46:20', '关于后端底层知识的标签', 0);

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单ID',
  `menu_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '菜单名称',
  `parent_id` bigint(20) NULL DEFAULT 0 COMMENT '父菜单ID',
  `order_num` int(4) NULL DEFAULT 0 COMMENT '显示顺序',
  `path` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '路由地址',
  `component` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '组件路径',
  `is_frame` int(1) NULL DEFAULT 1 COMMENT '是否为外链（0是 1否）',
  `menu_type` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',
  `visible` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `status` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `perms` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '#' COMMENT '菜单图标',
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建者',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新者',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '备注',
  `del_flag` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2029 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '菜单权限表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, '系统管理', 0, 1, 'system', NULL, 1, 'M', '0', '0', '', 'system', 0, '2021-11-12 10:46:19', 0, NULL, '系统管理目录', '0');
INSERT INTO `sys_menu` VALUES (100, '用户管理', 1, 1, 'user', 'system/user/index', 1, 'C', '0', '0', 'system:user:list', 'user', 0, '2021-11-12 10:46:19', 1, '2022-07-31 15:47:58', '用户管理菜单', '0');
INSERT INTO `sys_menu` VALUES (101, '角色管理', 1, 2, 'role', 'system/role/index', 1, 'C', '0', '0', 'system:role:list', 'peoples', 0, '2021-11-12 10:46:19', 0, NULL, '角色管理菜单', '0');
INSERT INTO `sys_menu` VALUES (102, '菜单管理', 1, 3, 'menu', 'system/menu/index', 1, 'C', '0', '0', 'system:menu:list', 'tree-table', 0, '2021-11-12 10:46:19', 0, NULL, '菜单管理菜单', '0');
INSERT INTO `sys_menu` VALUES (1001, '用户查询', 100, 1, '', '', 1, 'F', '0', '0', 'system:user:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1002, '用户新增', 100, 2, '', '', 1, 'F', '0', '0', 'system:user:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1003, '用户修改', 100, 3, '', '', 1, 'F', '0', '0', 'system:user:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1004, '用户删除', 100, 4, '', '', 1, 'F', '0', '0', 'system:user:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1005, '用户导出', 100, 5, '', '', 1, 'F', '0', '0', 'system:user:export', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1006, '用户导入', 100, 6, '', '', 1, 'F', '0', '0', 'system:user:import', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1007, '重置密码', 100, 7, '', '', 1, 'F', '0', '0', 'system:user:resetPwd', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1008, '角色查询', 101, 1, '', '', 1, 'F', '0', '0', 'system:role:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1009, '角色新增', 101, 2, '', '', 1, 'F', '0', '0', 'system:role:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1010, '角色修改', 101, 3, '', '', 1, 'F', '0', '0', 'system:role:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1011, '角色删除', 101, 4, '', '', 1, 'F', '0', '0', 'system:role:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1012, '角色导出', 101, 5, '', '', 1, 'F', '0', '0', 'system:role:export', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1013, '菜单查询', 102, 1, '', '', 1, 'F', '0', '0', 'system:menu:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1014, '菜单新增', 102, 2, '', '', 1, 'F', '0', '0', 'system:menu:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1015, '菜单修改', 102, 3, '', '', 1, 'F', '0', '0', 'system:menu:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (1016, '菜单删除', 102, 4, '', '', 1, 'F', '0', '0', 'system:menu:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `sys_menu` VALUES (2017, '内容管理', 0, 4, 'content', NULL, 1, 'M', '0', '0', NULL, 'table', NULL, '2022-01-08 02:44:38', 1, '2022-07-31 12:34:23', '', '0');
INSERT INTO `sys_menu` VALUES (2018, '分类管理', 2017, 1, 'category', 'content/category/index', 1, 'C', '0', '0', 'content:category:list', 'example', NULL, '2022-01-08 02:51:45', NULL, '2022-01-08 02:51:45', '', '0');
INSERT INTO `sys_menu` VALUES (2019, '文章管理', 2017, 0, 'article', 'content/article/index', 1, 'C', '0', '0', 'content:article:list', 'build', NULL, '2022-01-08 02:53:10', NULL, '2022-01-08 02:53:10', '', '0');
INSERT INTO `sys_menu` VALUES (2021, '标签管理', 2017, 6, 'tag', 'content/tag/index', 1, 'C', '0', '0', 'content:tag:index', 'button', NULL, '2022-01-08 02:55:37', NULL, '2022-01-08 02:55:50', '', '0');
INSERT INTO `sys_menu` VALUES (2022, '友链管理', 2017, 4, 'link', 'content/link/index', 1, 'C', '0', '0', 'content:link:list', '404', NULL, '2022-01-08 02:56:50', NULL, '2022-01-08 02:56:50', '', '0');
INSERT INTO `sys_menu` VALUES (2023, '写博文', 0, 0, 'write', 'content/article/write/index', 1, 'C', '0', '0', 'content:article:writer', 'build', NULL, '2022-01-08 03:39:58', 1, '2022-07-31 22:07:05', '', '0');
INSERT INTO `sys_menu` VALUES (2024, '友链新增', 2022, 0, '', NULL, 1, 'F', '0', '0', 'content:link:add', '#', NULL, '2022-01-16 07:59:17', NULL, '2022-01-16 07:59:17', '', '0');
INSERT INTO `sys_menu` VALUES (2025, '友链修改', 2022, 1, '', NULL, 1, 'F', '0', '0', 'content:link:edit', '#', NULL, '2022-01-16 07:59:44', NULL, '2022-01-16 07:59:44', '', '0');
INSERT INTO `sys_menu` VALUES (2026, '友链删除', 2022, 1, '', NULL, 1, 'F', '0', '0', 'content:link:remove', '#', NULL, '2022-01-16 08:00:05', NULL, '2022-01-16 08:00:05', '', '0');
INSERT INTO `sys_menu` VALUES (2027, '友链查询', 2022, 2, '', NULL, 1, 'F', '0', '0', 'content:link:query', '#', NULL, '2022-01-16 08:04:09', NULL, '2022-01-16 08:04:09', '', '0');
INSERT INTO `sys_menu` VALUES (2028, '导出分类', 2018, 1, '', NULL, 1, 'F', '0', '0', 'content:category:export', '#', NULL, '2022-01-21 07:06:59', NULL, '2022-01-21 07:06:59', '', '0');

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名称',
  `role_key` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色权限字符串',
  `role_sort` int(4) NOT NULL COMMENT '显示顺序',
  `status` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色状态（0正常 1停用）',
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建者',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新者',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '备注',
  `del_flag` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '删除标志（0代表存在 1代表删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色信息表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (1, '超级管理员', 'admin', 1, '0', 0, '2021-11-12 10:46:19', NULL, '2023-09-04 17:23:22', '超级管理员', '0');
INSERT INTO `sys_role` VALUES (2, '普通角色', 'common', 2, '0', 0, '2021-11-12 10:46:19', NULL, '2023-04-09 15:04:41', '普通角色', '0');
INSERT INTO `sys_role` VALUES (11, '嘎嘎嘎', 'aggag', 5, '0', NULL, '2022-01-06 14:07:40', NULL, '2023-02-21 13:36:51', '666', '1');
INSERT INTO `sys_role` VALUES (12, '友链审核员', 'link', 1, '0', NULL, '2022-01-16 06:49:30', NULL, '2022-01-16 08:05:09', NULL, '0');
INSERT INTO `sys_role` VALUES (13, '69', '666', 1, '1', 1, '2023-02-21 11:20:43', NULL, '2023-02-21 13:37:54', '666', '1');
INSERT INTO `sys_role` VALUES (14, '999', '66', 0, '1', 1, '2023-02-21 11:25:41', NULL, '2023-02-21 13:33:58', NULL, '1');
INSERT INTO `sys_role` VALUES (15, '888', '888', 2, '0', 1, '2023-02-21 13:39:04', NULL, '2023-02-21 21:41:27', '888', '1');

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  `menu_id` bigint(20) NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色和菜单关联表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (0, 0);
INSERT INTO `sys_role_menu` VALUES (2, 1);
INSERT INTO `sys_role_menu` VALUES (2, 102);
INSERT INTO `sys_role_menu` VALUES (2, 1013);
INSERT INTO `sys_role_menu` VALUES (2, 1014);
INSERT INTO `sys_role_menu` VALUES (2, 1015);
INSERT INTO `sys_role_menu` VALUES (2, 1016);
INSERT INTO `sys_role_menu` VALUES (2, 2000);
INSERT INTO `sys_role_menu` VALUES (3, 2);
INSERT INTO `sys_role_menu` VALUES (3, 3);
INSERT INTO `sys_role_menu` VALUES (3, 4);
INSERT INTO `sys_role_menu` VALUES (3, 100);
INSERT INTO `sys_role_menu` VALUES (3, 101);
INSERT INTO `sys_role_menu` VALUES (3, 103);
INSERT INTO `sys_role_menu` VALUES (3, 104);
INSERT INTO `sys_role_menu` VALUES (3, 105);
INSERT INTO `sys_role_menu` VALUES (3, 106);
INSERT INTO `sys_role_menu` VALUES (3, 107);
INSERT INTO `sys_role_menu` VALUES (3, 108);
INSERT INTO `sys_role_menu` VALUES (3, 109);
INSERT INTO `sys_role_menu` VALUES (3, 110);
INSERT INTO `sys_role_menu` VALUES (3, 111);
INSERT INTO `sys_role_menu` VALUES (3, 112);
INSERT INTO `sys_role_menu` VALUES (3, 113);
INSERT INTO `sys_role_menu` VALUES (3, 114);
INSERT INTO `sys_role_menu` VALUES (3, 115);
INSERT INTO `sys_role_menu` VALUES (3, 116);
INSERT INTO `sys_role_menu` VALUES (3, 500);
INSERT INTO `sys_role_menu` VALUES (3, 501);
INSERT INTO `sys_role_menu` VALUES (3, 1001);
INSERT INTO `sys_role_menu` VALUES (3, 1002);
INSERT INTO `sys_role_menu` VALUES (3, 1003);
INSERT INTO `sys_role_menu` VALUES (3, 1004);
INSERT INTO `sys_role_menu` VALUES (3, 1005);
INSERT INTO `sys_role_menu` VALUES (3, 1006);
INSERT INTO `sys_role_menu` VALUES (3, 1007);
INSERT INTO `sys_role_menu` VALUES (3, 1008);
INSERT INTO `sys_role_menu` VALUES (3, 1009);
INSERT INTO `sys_role_menu` VALUES (3, 1010);
INSERT INTO `sys_role_menu` VALUES (3, 1011);
INSERT INTO `sys_role_menu` VALUES (3, 1012);
INSERT INTO `sys_role_menu` VALUES (3, 1017);
INSERT INTO `sys_role_menu` VALUES (3, 1018);
INSERT INTO `sys_role_menu` VALUES (3, 1019);
INSERT INTO `sys_role_menu` VALUES (3, 1020);
INSERT INTO `sys_role_menu` VALUES (3, 1021);
INSERT INTO `sys_role_menu` VALUES (3, 1022);
INSERT INTO `sys_role_menu` VALUES (3, 1023);
INSERT INTO `sys_role_menu` VALUES (3, 1024);
INSERT INTO `sys_role_menu` VALUES (3, 1025);
INSERT INTO `sys_role_menu` VALUES (3, 1026);
INSERT INTO `sys_role_menu` VALUES (3, 1027);
INSERT INTO `sys_role_menu` VALUES (3, 1028);
INSERT INTO `sys_role_menu` VALUES (3, 1029);
INSERT INTO `sys_role_menu` VALUES (3, 1030);
INSERT INTO `sys_role_menu` VALUES (3, 1031);
INSERT INTO `sys_role_menu` VALUES (3, 1032);
INSERT INTO `sys_role_menu` VALUES (3, 1033);
INSERT INTO `sys_role_menu` VALUES (3, 1034);
INSERT INTO `sys_role_menu` VALUES (3, 1035);
INSERT INTO `sys_role_menu` VALUES (3, 1036);
INSERT INTO `sys_role_menu` VALUES (3, 1037);
INSERT INTO `sys_role_menu` VALUES (3, 1038);
INSERT INTO `sys_role_menu` VALUES (3, 1039);
INSERT INTO `sys_role_menu` VALUES (3, 1040);
INSERT INTO `sys_role_menu` VALUES (3, 1041);
INSERT INTO `sys_role_menu` VALUES (3, 1042);
INSERT INTO `sys_role_menu` VALUES (3, 1043);
INSERT INTO `sys_role_menu` VALUES (3, 1044);
INSERT INTO `sys_role_menu` VALUES (3, 1045);
INSERT INTO `sys_role_menu` VALUES (3, 1046);
INSERT INTO `sys_role_menu` VALUES (3, 1047);
INSERT INTO `sys_role_menu` VALUES (3, 1048);
INSERT INTO `sys_role_menu` VALUES (3, 1049);
INSERT INTO `sys_role_menu` VALUES (3, 1050);
INSERT INTO `sys_role_menu` VALUES (3, 1051);
INSERT INTO `sys_role_menu` VALUES (3, 1052);
INSERT INTO `sys_role_menu` VALUES (3, 1053);
INSERT INTO `sys_role_menu` VALUES (3, 1054);
INSERT INTO `sys_role_menu` VALUES (3, 1055);
INSERT INTO `sys_role_menu` VALUES (3, 1056);
INSERT INTO `sys_role_menu` VALUES (3, 1057);
INSERT INTO `sys_role_menu` VALUES (3, 1058);
INSERT INTO `sys_role_menu` VALUES (3, 1059);
INSERT INTO `sys_role_menu` VALUES (3, 1060);
INSERT INTO `sys_role_menu` VALUES (3, 2000);
INSERT INTO `sys_role_menu` VALUES (12, 2017);
INSERT INTO `sys_role_menu` VALUES (12, 2022);
INSERT INTO `sys_role_menu` VALUES (12, 2024);
INSERT INTO `sys_role_menu` VALUES (12, 2025);
INSERT INTO `sys_role_menu` VALUES (12, 2026);
INSERT INTO `sys_role_menu` VALUES (12, 2027);
INSERT INTO `sys_role_menu` VALUES (15, 1);
INSERT INTO `sys_role_menu` VALUES (15, 102);
INSERT INTO `sys_role_menu` VALUES (15, 1013);
INSERT INTO `sys_role_menu` VALUES (15, 1014);
INSERT INTO `sys_role_menu` VALUES (15, 1015);
INSERT INTO `sys_role_menu` VALUES (15, 1016);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '用户类型：0代表普通用户，1代表管理员',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新人',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `del_flag` int(11) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1, 'cocochimp', 'cocochimp', '$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy', '1', '0', '23412332@qq.com', '18888888888', '0', 'https://cocochimp-markdown-img.oss-cn-beijing.aliyuncs.com/save/101a3099-ab72-43b3-871f-23684caecef1.jfif', NULL, '2022-01-05 09:01:56', NULL, '2023-02-21 21:42:04', 0);
INSERT INTO `sys_user` VALUES (2, 'cocochimp1', 'cocochimp1', '$2a$10$ydv3rLkteFnRx9xelQ7elOiVhFvXOooA98xCqk/omh7G94R.K/E3O', '1', '0', NULL, '16666666666', '0', NULL, NULL, '2022-01-05 13:28:43', NULL, '2023-02-18 10:26:34', 0);
INSERT INTO `sys_user` VALUES (3, 'cocochimp2', 'cocochimp2', '$2a$10$kY4T3SN7i4muBccZppd2OOkhxMN6yt8tND1sF89hXOaFylhY2T3he', '1', '0', '23412332@qq.com', '19098790742', '0', NULL, NULL, '2023-02-19 10:16:36', NULL, '2023-02-19 10:16:42', 0);
INSERT INTO `sys_user` VALUES (4, 'cocochimp3', 'cocochimp3', '', '1', '0', NULL, '18246845873', '1', NULL, NULL, '2022-01-06 03:51:13', NULL, '2022-01-06 07:00:50', 0);
INSERT INTO `sys_user` VALUES (5, 'cocochimp4', 'cocochimp4', '$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy', '1', '0', '2312321@qq.com', '17777777777', '0', NULL, NULL, '2022-01-16 06:54:26', NULL, '2023-02-21 12:50:50', 0);
INSERT INTO `sys_user` VALUES (6, 'cocochimp5', 'cocochimp5', '$2a$10$y3k3fnMZsBNihsVLXWfI8uMNueVXBI08k.LzWYaKsW8CW7xXy18wC', '0', '0', 'weixin@qq.com', '18888888888', NULL, NULL, -1, '2022-01-30 17:18:44', -1, '2022-01-30 17:18:44', 0);

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  PRIMARY KEY (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户和角色关联表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (1, 1);
INSERT INTO `sys_user_role` VALUES (2, 2);
INSERT INTO `sys_user_role` VALUES (5, 2);
INSERT INTO `sys_user_role` VALUES (6, 12);

SET FOREIGN_KEY_CHECKS = 1;
